From c8c85c9fd81b47dbfb141ba5e9d85c62c0d5bfd0 Mon Sep 17 00:00:00 2001
From: dawnzju <chenhui8945@163.com>
Date: Wed, 22 Jun 2022 15:56:06 +0800
Subject: [PATCH 5/5] test

---
 src/cpu/o3/lsq_impl.hh                             |    4 -
 src/cpu/pred/BranchPredictor.py                    |  194 ----
 src/cpu/pred/SConscript                            |    3 -
 src/cpu/pred/loop_predictor.cc                     |    9 -
 src/cpu/pred/loop_predictor.hh                     |    2 -
 src/cpu/pred/multiperspective_perceptron.cc        |   37 +-
 src/cpu/pred/multiperspective_perceptron.hh        |   12 +-
 src/cpu/pred/statistical_corrector.cc              |   58 +-
 src/cpu/pred/statistical_corrector.hh              |   39 +-
 src/cpu/pred/tage_base.cc                          |   49 +-
 src/cpu/pred/tage_base.hh                          |   15 +-
 src/cpu/pred/tage_sc_l.cc                          |    9 +-
 src/cpu/pred/tage_sc_l.hh                          |    2 +-
 src/cpu/pred/tage_sc_l_64KB.cc                     |    9 +-
 src/cpu/pred/tage_sc_l_64KB.hh                     |    2 +-
 src/cpu/pred/tage_sc_l_8KB.cc                      |   11 +-
 src/cpu/pred/tage_sc_l_8KB.hh                      |    4 +-
 src/cpu/simple/taskGraph.json                      |    1 +
 src/cpu/taskGraph.json                             |    1 +
 .../GarnetSyntheticTraffic.cc                      | 1155 +++++++++++++++++++-
 .../GarnetSyntheticTraffic.hh                      |  103 +-
 .../GarnetSyntheticTraffic.py                      |    2 +
 src/mem/packet.hh                                  |    2 +
 src/mem/packet_queue.cc                            |    9 +-
 src/mem/protocol/RubySlicc_Types.sm                |    2 +
 src/mem/ruby/filters/AbstractBloomFilter.hh        |  107 +-
 src/mem/ruby/filters/BlockBloomFilter.cc           |  114 +-
 src/mem/ruby/filters/BlockBloomFilter.hh           |   32 +-
 src/mem/ruby/filters/BulkBloomFilter.cc            |  209 +++-
 src/mem/ruby/filters/BulkBloomFilter.hh            |   41 +-
 src/mem/ruby/filters/H3BloomFilter.cc              |  151 ++-
 src/mem/ruby/filters/H3BloomFilter.hh              |   69 +-
 src/mem/ruby/filters/LSB_CountingBloomFilter.cc    |  111 +-
 src/mem/ruby/filters/LSB_CountingBloomFilter.hh    |   35 +-
 src/mem/ruby/filters/MultiBitSelBloomFilter.cc     |  137 ++-
 src/mem/ruby/filters/MultiBitSelBloomFilter.hh     |   61 +-
 src/mem/ruby/filters/MultiGrainBloomFilter.cc      |  143 ++-
 src/mem/ruby/filters/MultiGrainBloomFilter.hh      |   40 +-
 src/mem/ruby/filters/NonCountingBloomFilter.cc     |  108 +-
 src/mem/ruby/filters/NonCountingBloomFilter.hh     |   44 +-
 src/mem/ruby/filters/SConscript                    |    2 -
 src/mem/ruby/network/MessageBuffer.cc              |    2 +-
 src/mem/ruby/network/MessageBuffer.hh              |    1 +
 src/mem/ruby/network/Network.py                    |    2 +-
 src/mem/ruby/network/garnet2.0/CommonTypes.hh      |    6 +
 src/mem/ruby/network/garnet2.0/CreditLink.cc       |   72 ++
 src/mem/ruby/network/garnet2.0/CreditLink.hh       |    2 +
 src/mem/ruby/network/garnet2.0/CrossbarSwitch.cc   |   16 +-
 src/mem/ruby/network/garnet2.0/GarnetNetwork.cc    |  273 ++++-
 src/mem/ruby/network/garnet2.0/GarnetNetwork.hh    |   47 +-
 src/mem/ruby/network/garnet2.0/GarnetNetwork.py    |   12 +
 src/mem/ruby/network/garnet2.0/InputUnit.cc        |  313 +++++-
 src/mem/ruby/network/garnet2.0/InputUnit.hh        |   42 +
 src/mem/ruby/network/garnet2.0/NetworkInterface.cc |   73 +-
 src/mem/ruby/network/garnet2.0/NetworkInterface.hh |    1 +
 src/mem/ruby/network/garnet2.0/NetworkLink.cc      |   97 +-
 src/mem/ruby/network/garnet2.0/NetworkLink.hh      |    7 +-
 src/mem/ruby/network/garnet2.0/OutVcState.cc       |    4 +-
 src/mem/ruby/network/garnet2.0/OutVcState.hh       |    1 +
 src/mem/ruby/network/garnet2.0/OutputUnit.cc       |   95 +-
 src/mem/ruby/network/garnet2.0/OutputUnit.hh       |   48 +-
 src/mem/ruby/network/garnet2.0/Router.cc           |  738 ++++++++++++-
 src/mem/ruby/network/garnet2.0/Router.hh           |  142 ++-
 src/mem/ruby/network/garnet2.0/RoutingUnit.cc      |   80 +-
 src/mem/ruby/network/garnet2.0/RoutingUnit.hh      |   10 +-
 src/mem/ruby/network/garnet2.0/SConscript          |    2 +
 src/mem/ruby/network/garnet2.0/SSR.cc              |   47 +
 src/mem/ruby/network/garnet2.0/SSR.hh              |  102 ++
 src/mem/ruby/network/garnet2.0/SwitchAllocator.cc  |  229 +++-
 src/mem/ruby/network/garnet2.0/SwitchAllocator.hh  |   18 +-
 src/mem/ruby/network/garnet2.0/flit.cc             |    1 +
 src/mem/ruby/network/garnet2.0/flit.hh             |    6 +-
 src/mem/ruby/network/garnet2.0/task.hh             |   20 +
 src/mem/ruby/network/simple/PerfectSwitch.cc       |    2 +-
 src/mem/ruby/network/simple/SimpleNetwork.cc       |    4 +-
 src/mem/ruby/network/simple/SimpleNetwork.hh       |   21 +-
 src/mem/ruby/network/simple/SimpleNetwork.py       |   22 +-
 src/mem/ruby/slicc_interface/AbstractController.cc |    2 +-
 src/mem/ruby/slicc_interface/Message.hh            |    6 +
 src/mem/ruby/slicc_interface/RubyRequest.hh        |    1 +
 src/mem/ruby/system/DMASequencer.cc                |    2 +
 src/mem/ruby/system/GPUCoalescer.cc                |    1 +
 src/mem/ruby/system/Sequencer.cc                   |    4 +
 src/mem/ruby/system/VIPERCoalescer.cc              |    6 +
 src/sim/clocked_object.hh                          |    1 +
 src/systemc/ext/systemc                            |    3 +-
 src/taskGraph.json                                 |    1 +
 87 files changed, 4788 insertions(+), 935 deletions(-)
 create mode 100644 src/cpu/simple/taskGraph.json
 create mode 100644 src/cpu/taskGraph.json
 create mode 100644 src/mem/ruby/network/garnet2.0/CreditLink.cc
 create mode 100644 src/mem/ruby/network/garnet2.0/SSR.cc
 create mode 100644 src/mem/ruby/network/garnet2.0/SSR.hh
 create mode 100644 src/mem/ruby/network/garnet2.0/task.hh
 create mode 100644 src/taskGraph.json

diff --git a/src/cpu/o3/lsq_impl.hh b/src/cpu/o3/lsq_impl.hh
index d4e0a28..70621a5 100644
--- a/src/cpu/o3/lsq_impl.hh
+++ b/src/cpu/o3/lsq_impl.hh
@@ -724,10 +724,6 @@ LSQ<Impl>::pushRequest(const DynInstPtr& inst, bool isLoad, uint8_t *data,
         inst->setRequest();
         req->taskId(cpu->taskId());
 
-        // There might be fault from a previous execution attempt if this is
-        // a strictly ordered load
-        inst->getFault() = NoFault;
-
         req->initiateTranslation();
     }
 
diff --git a/src/cpu/pred/BranchPredictor.py b/src/cpu/pred/BranchPredictor.py
index 1196405..967489a 100644
--- a/src/cpu/pred/BranchPredictor.py
+++ b/src/cpu/pred/BranchPredictor.py
@@ -133,7 +133,6 @@ class TAGEBase(SimObject):
     logUResetPeriod = Param.Unsigned(18,
         "Log period in number of branches to reset TAGE useful counters")
     numUseAltOnNa = Param.Unsigned(1, "Number of USE_ALT_ON_NA counters")
-    initialTCounterValue = Param.Int(1 << 17, "Initial value of tCounter")
     useAltOnNaBits = Param.Unsigned(4, "Size of the USE_ALT_ON_NA counter(s)")
 
     maxNumAlloc = Param.Unsigned(1,
@@ -211,7 +210,6 @@ class TAGE_SC_L_TAGE(TAGEBase):
     pathHistBits = 27
     maxNumAlloc = 2
     logUResetPeriod = 10
-    initialTCounterValue = 1 << 9
     useAltOnNaBits = 5
     # TODO No speculation implemented as of now
     speculativeHistUpdate = False
@@ -336,20 +334,14 @@ class StatisticalCorrector(SimObject):
     bwnb = Param.Unsigned("Num global backward branch GEHL lengths")
     bwm = VectorParam.Int("Global backward branch GEHL lengths")
     logBwnb = Param.Unsigned("Log num of global backward branch GEHL entries")
-    bwWeightInitValue = Param.Int(
-     "Initial value of the weights of the global backward branch GEHL entries")
 
     lnb = Param.Unsigned("Num first local history GEHL lenghts")
     lm = VectorParam.Int("First local history GEHL lengths")
     logLnb = Param.Unsigned("Log number of first local history GEHL entries")
-    lWeightInitValue = Param.Int(
-        "Initial value of the weights of the first local history GEHL entries")
 
     inb = Param.Unsigned(1, "Num IMLI GEHL lenghts")
     im = VectorParam.Int([8], "IMLI history GEHL lengths")
     logInb = Param.Unsigned("Log number of IMLI GEHL entries")
-    iWeightInitValue = Param.Int(
-        "Initial value of the weights of the IMLI history GEHL entries")
 
     logBias = Param.Unsigned("Log size of Bias tables")
 
@@ -370,9 +362,6 @@ class StatisticalCorrector(SimObject):
 
     scCountersWidth = Param.Unsigned(6, "Statistical corrector counters width")
 
-    initialUpdateThresholdValue = Param.Int(0,
-        "Initial pUpdate threshold counter value")
-
 # TAGE-SC-L branch predictor as desribed in
 # https://www.jilp.org/cbp2016/paper/AndreSeznecLimited.pdf
 # It is a modified LTAGE predictor plus a statistical corrector predictor
@@ -436,15 +425,12 @@ class TAGE_SC_L_64KB_StatisticalCorrector(StatisticalCorrector):
     bwnb = 3
     bwm = [40, 24, 10]
     logBwnb = 10
-    bwWeightInitValue = 7
 
     lnb = 3
     lm = [11, 6, 3]
     logLnb = 10
-    lWeightInitValue = 7
 
     logInb = 8
-    iWeightInitValue = 7
 
 class TAGE_SC_L_8KB_StatisticalCorrector(StatisticalCorrector):
     type = 'TAGE_SC_L_8KB_StatisticalCorrector'
@@ -461,15 +447,12 @@ class TAGE_SC_L_8KB_StatisticalCorrector(StatisticalCorrector):
     bwnb = 2
     logBwnb = 7
     bwm = [16, 8]
-    bwWeightInitValue = 7
 
     lnb = 2
     logLnb = 7
     lm = [6, 3]
-    lWeightInitValue = 7
 
     logInb = 7
-    iWeightInitValue = 7
 
 # 64KB TAGE-SC-L branch predictor as described in
 # http://www.jilp.org/cbp2016/paper/AndreSeznecLimited.pdf
@@ -553,9 +536,6 @@ class MultiperspectivePerceptron(BranchPredictor):
     speculative_update = Param.Bool(False,
         "Use speculative update for histories")
 
-    initial_ghist_length = Param.Int(1, "Initial GHist length value")
-    ignore_path_size = Param.Bool(False, "Ignore the path storage")
-
 class MultiperspectivePerceptron8KB(MultiperspectivePerceptron):
     type = 'MultiperspectivePerceptron8KB'
     cxx_class = 'MultiperspectivePerceptron8KB'
@@ -577,177 +557,3 @@ class MultiperspectivePerceptron64KB(MultiperspectivePerceptron):
     imli_mask1 = 0xc1000
     imli_mask4 = 0x80008000
     recencypos_mask = 0x100000090
-
-class MPP_TAGE(TAGEBase):
-    type = 'MPP_TAGE'
-    cxx_class = 'MPP_TAGE'
-    cxx_header = 'cpu/pred/multiperspective_perceptron_tage.hh'
-    nHistoryTables = 15
-    pathHistBits = 27
-    instShiftAmt = 0
-    histBufferSize = 16384
-    maxHist = 4096;
-    tagTableTagWidths = [0, 7, 9, 9, 9, 10, 11, 11, 12, 12,
-                         12, 13, 14, 15, 15, 15]
-    logTagTableSizes = [14, 10, 11, 11, 11, 11, 11, 12, 12,
-                         10, 11, 11, 9, 7, 7, 8]
-    tunedHistoryLengths = VectorParam.Unsigned([0, 5, 12, 15, 21, 31, 43, 64,
-        93, 137, 200, 292, 424, 612, 877, 1241], "Tuned history lengths")
-
-    logUResetPeriod = 10
-    initialTCounterValue = 0
-    numUseAltOnNa = 512
-    speculativeHistUpdate = False
-
-class MPP_LoopPredictor(LoopPredictor):
-    type = 'MPP_LoopPredictor'
-    cxx_class = 'MPP_LoopPredictor'
-    cxx_header = 'cpu/pred/multiperspective_perceptron_tage.hh'
-    useDirectionBit = True
-    useHashing = True
-    useSpeculation = False
-    loopTableConfidenceBits = 4
-    loopTableAgeBits = 4
-    initialLoopAge = 7
-    initialLoopIter = 0
-    loopTableIterBits = 12
-    optionalAgeReset = False
-    restrictAllocation = True
-    logSizeLoopPred = 6
-    loopTableTagBits = 10
-
-class MPP_StatisticalCorrector(StatisticalCorrector):
-    type = 'MPP_StatisticalCorrector'
-    cxx_class = 'MPP_StatisticalCorrector'
-    cxx_header = 'cpu/pred/multiperspective_perceptron_tage.hh'
-    abstract = True
-
-    # Unused in this Statistical Corrector
-    bwnb = 0
-    bwm = [ ]
-    logBwnb = 0
-    bwWeightInitValue = -1
-
-    # Unused in this Statistical Corrector
-    logInb = 0
-    iWeightInitValue = -1
-
-    extraWeightsWidth = 0
-    pUpdateThresholdWidth = 10
-    initialUpdateThresholdValue = 35
-    logSizeUp = 5
-
-    lnb = 3
-    lm = [11, 6, 3]
-    logLnb = 10
-    lWeightInitValue = -1
-
-    gnb = Param.Unsigned(4, "Num global branch GEHL lengths")
-    gm = VectorParam.Int([27, 22, 17, 14], "Global branch GEHL lengths")
-    logGnb = Param.Unsigned(10, "Log number of global branch GEHL entries")
-
-    pnb = Param.Unsigned(4, "Num variation global branch GEHL lengths")
-    pm = VectorParam.Int([16, 11, 6, 3],
-        "Variation global branch GEHL lengths")
-    logPnb = Param.Unsigned(9,
-        "Log number of variation global branch GEHL entries")
-
-class MultiperspectivePerceptronTAGE(MultiperspectivePerceptron):
-    type = 'MultiperspectivePerceptronTAGE'
-    cxx_class = 'MultiperspectivePerceptronTAGE'
-    cxx_header = 'cpu/pred/multiperspective_perceptron_tage.hh'
-    abstract = True
-    instShiftAmt = 4
-
-    imli_mask1 = 0x70
-    imli_mask4 = 0
-    num_filter_entries = 0
-    num_local_histories = 0
-    recencypos_mask = 0 # Unused
-    threshold = -1
-    initial_ghist_length = 0
-    ignore_path_size = True
-    n_sign_bits = 1;
-
-    tage = Param.TAGEBase("Tage object")
-    loop_predictor = Param.LoopPredictor("Loop predictor")
-    statistical_corrector = Param.StatisticalCorrector("Statistical Corrector")
-
-class MPP_StatisticalCorrector_64KB(MPP_StatisticalCorrector):
-    type = 'MPP_StatisticalCorrector_64KB'
-    cxx_class = 'MPP_StatisticalCorrector_64KB'
-    cxx_header = 'cpu/pred/multiperspective_perceptron_tage_64KB.hh'
-
-    logBias = 8
-
-    snb = Param.Unsigned(4, "Num second local history GEHL lenghts")
-    sm = VectorParam.Int([16, 11, 6, 3], "Second local history GEHL lengths")
-    logSnb = Param.Unsigned(9,
-        "Log number of second local history GEHL entries")
-
-    tnb = Param.Unsigned(3, "Num third local history GEHL lenghts")
-    tm = VectorParam.Int([22, 17, 14], "Third local history GEHL lengths")
-    logTnb = Param.Unsigned(9,
-        "Log number of third local history GEHL entries")
-
-    numEntriesSecondLocalHistories = Param.Unsigned(16,
-        "Number of entries for second local histories")
-    numEntriesThirdLocalHistories = Param.Unsigned(16,
-        "Number of entries for second local histories")
-
-    numEntriesFirstLocalHistories = 256
-
-class MultiperspectivePerceptronTAGE64KB(MultiperspectivePerceptronTAGE):
-    type = 'MultiperspectivePerceptronTAGE64KB'
-    cxx_class = 'MultiperspectivePerceptronTAGE64KB'
-    cxx_header = 'cpu/pred/multiperspective_perceptron_tage_64KB.hh'
-
-    budgetbits = 65536 * 8 + 2048
-
-    tage = MPP_TAGE()
-    loop_predictor = MPP_LoopPredictor()
-    statistical_corrector = MPP_StatisticalCorrector_64KB()
-
-class MPP_TAGE_8KB(MPP_TAGE):
-    type = 'MPP_TAGE_8KB'
-    cxx_class = 'MPP_TAGE_8KB'
-    cxx_header = 'cpu/pred/multiperspective_perceptron_tage_8KB.hh'
-    nHistoryTables = 10
-    tagTableTagWidths = [0, 7, 7, 7, 8, 9, 10, 10, 11, 13, 13]
-    logTagTableSizes = [12, 8, 8, 9, 9, 8, 8, 8, 7, 6, 7]
-    tunedHistoryLengths = [0, 4, 8, 13, 23, 36, 56, 93, 145, 226, 359]
-
-class MPP_LoopPredictor_8KB(MPP_LoopPredictor):
-    type = 'MPP_LoopPredictor_8KB'
-    cxx_class = 'MPP_LoopPredictor_8KB'
-    cxx_header = 'cpu/pred/multiperspective_perceptron_tage_8KB.hh'
-    loopTableIterBits = 10
-    logSizeLoopPred = 4
-
-class MPP_StatisticalCorrector_8KB(MPP_StatisticalCorrector):
-    type = 'MPP_StatisticalCorrector_8KB'
-    cxx_class = 'MPP_StatisticalCorrector_8KB'
-    cxx_header = 'cpu/pred/multiperspective_perceptron_tage_8KB.hh'
-
-    logBias = 7
-
-    lnb = 2
-    lm = [8, 3]
-    logLnb = 9
-
-    logGnb = 9
-
-    logPnb = 7
-
-    numEntriesFirstLocalHistories = 64
-
-class MultiperspectivePerceptronTAGE8KB(MultiperspectivePerceptronTAGE):
-    type = 'MultiperspectivePerceptronTAGE8KB'
-    cxx_class = 'MultiperspectivePerceptronTAGE8KB'
-    cxx_header = 'cpu/pred/multiperspective_perceptron_tage_8KB.hh'
-
-    budgetbits = 8192 * 8 + 2048
-
-    tage = MPP_TAGE_8KB()
-    loop_predictor = MPP_LoopPredictor_8KB()
-    statistical_corrector = MPP_StatisticalCorrector_8KB()
diff --git a/src/cpu/pred/SConscript b/src/cpu/pred/SConscript
index 9775d4c..27821a4 100644
--- a/src/cpu/pred/SConscript
+++ b/src/cpu/pred/SConscript
@@ -51,9 +51,6 @@ Source('ltage.cc')
 Source('multiperspective_perceptron.cc')
 Source('multiperspective_perceptron_8KB.cc')
 Source('multiperspective_perceptron_64KB.cc')
-Source('multiperspective_perceptron_tage.cc')
-Source('multiperspective_perceptron_tage_8KB.cc')
-Source('multiperspective_perceptron_tage_64KB.cc')
 Source('statistical_corrector.cc')
 Source('tage_sc_l.cc')
 Source('tage_sc_l_8KB.cc')
diff --git a/src/cpu/pred/loop_predictor.cc b/src/cpu/pred/loop_predictor.cc
index abcaac4..bd32e41 100644
--- a/src/cpu/pred/loop_predictor.cc
+++ b/src/cpu/pred/loop_predictor.cc
@@ -360,15 +360,6 @@ LoopPredictor::regStats()
               "the prediction is wrong");
 }
 
-size_t
-LoopPredictor::getSizeInBits() const
-{
-    return (1ULL << logSizeLoopPred) *
-        ((useSpeculation ? 3 : 2) * loopTableIterBits +
-        loopTableConfidenceBits + loopTableTagBits +
-        loopTableAgeBits + useDirectionBit);
-}
-
 LoopPredictor *
 LoopPredictorParams::create()
 {
diff --git a/src/cpu/pred/loop_predictor.hh b/src/cpu/pred/loop_predictor.hh
index 5706c45..bc62698 100644
--- a/src/cpu/pred/loop_predictor.hh
+++ b/src/cpu/pred/loop_predictor.hh
@@ -259,7 +259,5 @@ class LoopPredictor : public SimObject
     void regStats() override;
 
     LoopPredictor(LoopPredictorParams *p);
-
-    size_t getSizeInBits() const;
 };
 #endif//__CPU_PRED_LOOP_PREDICTOR_HH__
diff --git a/src/cpu/pred/multiperspective_perceptron.cc b/src/cpu/pred/multiperspective_perceptron.cc
index d081b49..47bbb02 100644
--- a/src/cpu/pred/multiperspective_perceptron.cc
+++ b/src/cpu/pred/multiperspective_perceptron.cc
@@ -38,7 +38,6 @@
 
 #include "cpu/pred/multiperspective_perceptron.hh"
 
-#include "base/random.hh"
 #include "debug/Branch.hh"
 
 int
@@ -122,21 +121,15 @@ MultiperspectivePerceptron::MultiperspectivePerceptron(
     tuneonly(p->tuneonly), extra_rounds(p->extra_rounds), speed(p->speed),
     budgetbits(p->budgetbits), speculative_update(p->speculative_update),
     threadData(p->numThreads, nullptr), doing_local(false),
-    doing_recency(false), assoc(0), ghist_length(p->initial_ghist_length),
-    modghist_length(1), path_length(1), thresholdCounter(0),
-    theta(p->initial_theta), extrabits(0), imli_counter_bits(4),
-    modhist_indices(), modhist_lengths(), modpath_indices(), modpath_lengths()
+    doing_recency(false), assoc(0), ghist_length(1), modghist_length(1),
+    path_length(1), randSeed(0xdeadbeef), thresholdCounter(0),
+    theta(p->initial_theta), imli_counter_bits(4), modhist_indices(),
+    modhist_lengths(), modpath_indices(), modpath_lengths()
 {
     fatal_if(speculative_update, "Speculative update not implemented");
 }
 
 void
-MultiperspectivePerceptron::setExtraBits(int bits)
-{
-    extrabits = bits;
-}
-
-void
 MultiperspectivePerceptron::init()
 {
     createSpecs();
@@ -154,7 +147,7 @@ MultiperspectivePerceptron::init()
         static_cast<const MultiperspectivePerceptronParams *>(params());
 
     computeBits(p->num_filter_entries, p->num_local_histories,
-                p->local_history_length, p->ignore_path_size);
+                p->local_history_length);
 
     for (int i = 0; i < threadData.size(); i += 1) {
         threadData[i] = new ThreadData(p->num_filter_entries,
@@ -170,24 +163,19 @@ MultiperspectivePerceptron::init()
 
 void
 MultiperspectivePerceptron::computeBits(int num_filter_entries,
-        int nlocal_histories, int local_history_length, bool ignore_path_size)
-{
-    int totalbits = extrabits;
+        int nlocal_histories, int local_history_length) {
+    int totalbits = 0;
     for (auto &imli_bits : imli_counter_bits) {
         totalbits += imli_bits;
     }
     totalbits += ghist_length;
-    if (!ignore_path_size) {
-        totalbits += path_length * 16;
-    }
+    totalbits += path_length * 16;
     totalbits += (threshold >= 0) ? (tunebits * specs.size()) : 0;
     for (auto &len : modhist_lengths) {
         totalbits += len;
     }
-    if (!ignore_path_size) {
-        for (auto &len : modpath_lengths) {
-            totalbits += 16 * len;
-        }
+    for (auto &len : modpath_lengths) {
+        totalbits += 16 * len;
     }
     totalbits += doing_local ? (nlocal_histories * local_history_length) : 0;
     totalbits += doing_recency ? (assoc * 16) : 0;
@@ -494,7 +482,7 @@ MultiperspectivePerceptron::train(ThreadID tid, MPPBranchInfo &bi, bool taken)
             do {
                 // udpate a random weight
                 int besti = -1;
-                int nrand = random_mt.random<int>() % specs.size();
+                int nrand = rand_r(&randSeed) % specs.size();
                 int pout;
                 found = false;
                 for (int j = 0; j < specs.size(); j += 1) {
@@ -657,8 +645,7 @@ MultiperspectivePerceptron::update(ThreadID tid, Addr instPC, bool taken,
         // filter, blow a random filter entry away
         if (decay && transition &&
             ((threadData[tid]->occupancy > decay) || (decay == 1))) {
-            int rnd = random_mt.random<int>() %
-                      threadData[tid]->filterTable.size();
+            int rnd = rand_r(&randSeed) % threadData[tid]->filterTable.size();
             FilterEntry &frand = threadData[tid]->filterTable[rnd];
             if (frand.seenTaken && frand.seenUntaken) {
                 threadData[tid]->occupancy -= 1;
diff --git a/src/cpu/pred/multiperspective_perceptron.hh b/src/cpu/pred/multiperspective_perceptron.hh
index 9d45032..e81bd8e 100644
--- a/src/cpu/pred/multiperspective_perceptron.hh
+++ b/src/cpu/pred/multiperspective_perceptron.hh
@@ -358,9 +358,9 @@ class MultiperspectivePerceptron : public BPredUnit
     int ghist_length;
     int modghist_length;
     int path_length;
+    unsigned int randSeed;
     int thresholdCounter;
     int theta;
-    int extrabits;
     std::vector<int> imli_counter_bits;
     std::vector<int> modhist_indices;
     std::vector<int> modhist_lengths;
@@ -416,10 +416,9 @@ class MultiperspectivePerceptron : public BPredUnit
      * @param num_filter_entries number of entries of the filter
      * @param nlocal_histories number of local history entries
      * @param local_history_length size of each local history entry
-     * @param ignore_path_size ignore the path length storage
      */
     void computeBits(int num_filter_entries, int nlocal_histories,
-            int local_history_length, bool ignore_path_size);
+            int local_history_length);
 
     /**
      * Creates the tables of the predictor
@@ -1014,13 +1013,6 @@ class MultiperspectivePerceptron : public BPredUnit
     public:
     MultiperspectivePerceptron(const MultiperspectivePerceptronParams *params);
 
-    /**
-     * Sets the starting number of storage bits to compute the number of
-     * table entries
-     * @param bits number of bits used
-     */
-    void setExtraBits(int bits);
-
     void init() override;
 
     void uncondBranch(ThreadID tid, Addr pc, void * &bp_history) override;
diff --git a/src/cpu/pred/statistical_corrector.cc b/src/cpu/pred/statistical_corrector.cc
index 8ddae9b..ebacd4d 100644
--- a/src/cpu/pred/statistical_corrector.cc
+++ b/src/cpu/pred/statistical_corrector.cc
@@ -69,34 +69,17 @@
 {
     wb.resize(1 << logSizeUps, 4);
 
-    initGEHLTable(lnb, lm, lgehl, logLnb, wl, p->lWeightInitValue);
-    initGEHLTable(bwnb, bwm, bwgehl, logBwnb, wbw, p->bwWeightInitValue);
-    initGEHLTable(inb, im, igehl, logInb, wi, p->iWeightInitValue);
+    initGEHLTable(lnb, lm, lgehl, logLnb, wl, 7);
+    initGEHLTable(bwnb, bwm, bwgehl, logBwnb, wbw, 7);
+    initGEHLTable(inb, im, igehl, logInb, wi, 7);
 
     updateThreshold = 35 << 3;
 
-    pUpdateThreshold.resize(1 << logSizeUp, p->initialUpdateThresholdValue);
+    pUpdateThreshold.resize(1 << logSizeUp, 0);
 
     bias.resize(1 << logBias);
     biasSK.resize(1 << logBias);
     biasBank.resize(1 << logBias);
-}
-
-StatisticalCorrector::BranchInfo*
-StatisticalCorrector::makeBranchInfo()
-{
-    return new BranchInfo();
-}
-
-StatisticalCorrector::SCThreadHistory*
-StatisticalCorrector::makeThreadHistory()
-{
-    return new SCThreadHistory();
-}
-
-void
-StatisticalCorrector::initBias()
-{
     for (int j = 0; j < (1 << logBias); j++) {
         switch (j & 3) {
           case 0:
@@ -123,6 +106,18 @@ StatisticalCorrector::initBias()
     }
 }
 
+StatisticalCorrector::BranchInfo*
+StatisticalCorrector::makeBranchInfo()
+{
+    return new BranchInfo();
+}
+
+StatisticalCorrector::SCThreadHistory*
+StatisticalCorrector::makeThreadHistory()
+{
+    return new SCThreadHistory();
+}
+
 void
 StatisticalCorrector::initGEHLTable(unsigned numLenghts,
     std::vector<int> lengths, std::vector<int8_t> * & table,
@@ -223,7 +218,7 @@ bool
 StatisticalCorrector::scPredict(ThreadID tid, Addr branch_pc, bool cond_branch,
                      BranchInfo* bi, bool prev_pred_taken, bool bias_bit,
                      bool use_conf_ctr, int8_t conf_ctr, unsigned conf_bits,
-                     int hitBank, int altBank, int64_t phist, int init_lsum)
+                     int hitBank, int altBank, int64_t phist)
 {
     bool pred_taken = prev_pred_taken;
     if (cond_branch) {
@@ -237,7 +232,7 @@ StatisticalCorrector::scPredict(ThreadID tid, Addr branch_pc, bool cond_branch,
             bi->highConf = (abs(2 * conf_ctr + 1) >= (1<<conf_bits) - 1);
         }
 
-        int lsum = init_lsum;
+        int lsum = 0;
 
         int8_t ctr = bias[getIndBias(branch_pc, bi, bias_bit)];
         lsum += (2 * ctr + 1);
@@ -285,14 +280,9 @@ StatisticalCorrector::scPredict(ThreadID tid, Addr branch_pc, bool cond_branch,
 }
 
 void
-StatisticalCorrector::scHistoryUpdate(Addr branch_pc,
-        const StaticInstPtr &inst, bool taken, BranchInfo * tage_bi,
-        Addr corrTarget)
+StatisticalCorrector::scHistoryUpdate(Addr branch_pc, int brtype, bool taken,
+                           BranchInfo * tage_bi, Addr corrTarget)
 {
-    int brtype = inst->isDirectCtrl() ? 0 : 2;
-    if (! inst->isUncondCtrl()) {
-        ++brtype;
-    }
     // Non speculative SC histories update
     if (brtype & 1) {
         if (corrTarget < branch_pc) {
@@ -386,14 +376,6 @@ void
 StatisticalCorrector::init()
 {
     scHistory = makeThreadHistory();
-    initBias();
-}
-
-size_t
-StatisticalCorrector::getSizeInBits() const
-{
-    // Not implemented
-    return 0;
 }
 
 void
diff --git a/src/cpu/pred/statistical_corrector.hh b/src/cpu/pred/statistical_corrector.hh
index 2e8e502..f966843 100644
--- a/src/cpu/pred/statistical_corrector.hh
+++ b/src/cpu/pred/statistical_corrector.hh
@@ -44,27 +44,24 @@
 
 #include "base/statistics.hh"
 #include "base/types.hh"
-#include "cpu/static_inst.hh"
 #include "sim/sim_object.hh"
 
 struct StatisticalCorrectorParams;
 
 class StatisticalCorrector : public SimObject
 {
-  protected:
     template<typename T>
     inline void ctrUpdate(T & ctr, bool taken, int nbits) {
         assert(nbits <= sizeof(T) << 3);
-        if (nbits > 0) {
-            if (taken) {
-                if (ctr < ((1 << (nbits - 1)) - 1))
-                    ctr++;
-            } else {
-                if (ctr > -(1 << (nbits - 1)))
-                    ctr--;
-            }
+        if (taken) {
+            if (ctr < ((1 << (nbits - 1)) - 1))
+                ctr++;
+        } else {
+            if (ctr > -(1 << (nbits - 1)))
+                ctr--;
         }
     }
+  protected:
     // histories used for the statistical corrector
     struct SCThreadHistory {
         SCThreadHistory() {
@@ -212,22 +209,20 @@ class StatisticalCorrector : public SimObject
     virtual BranchInfo *makeBranchInfo();
     virtual SCThreadHistory *makeThreadHistory();
 
-    virtual void initBias();
-
-    virtual bool scPredict(
+    bool scPredict(
         ThreadID tid, Addr branch_pc, bool cond_branch, BranchInfo* bi,
         bool prev_pred_taken, bool bias_bit, bool use_conf_ctr,
         int8_t conf_ctr, unsigned conf_bits, int hitBank, int altBank,
-        int64_t phist, int init_lsum = 0);
+        int64_t phist);
 
-    virtual unsigned getIndBias(Addr branch_pc, BranchInfo* bi, bool b) const;
+    unsigned getIndBias(Addr branch_pc, BranchInfo* bi, bool b) const;
 
-    virtual unsigned getIndBiasSK(Addr branch_pc, BranchInfo* bi) const;
+    unsigned getIndBiasSK(Addr branch_pc, BranchInfo* bi) const;
 
     virtual unsigned getIndBiasBank( Addr branch_pc, BranchInfo* bi,
         int hitBank, int altBank) const = 0;
 
-    virtual unsigned getIndUpd(Addr branch_pc) const;
+    unsigned getIndUpd(Addr branch_pc) const;
     unsigned getIndUpds(Addr branch_pc) const;
 
     virtual int gPredictions(ThreadID tid, Addr branch_pc, BranchInfo* bi,
@@ -242,7 +237,7 @@ class StatisticalCorrector : public SimObject
         std::vector<int8_t> * tab, int nbr, int logs,
         std::vector<int8_t> & w);
 
-    virtual void gUpdate(
+    void gUpdate(
         Addr branch_pc, bool taken, int64_t hist, std::vector<int> & length,
         std::vector<int8_t> * tab, int nbr, int logs,
         std::vector<int8_t> & w, BranchInfo* bi);
@@ -253,8 +248,8 @@ class StatisticalCorrector : public SimObject
         std::vector<int8_t> & w, int8_t wInitValue);
 
     virtual void scHistoryUpdate(
-        Addr branch_pc, const StaticInstPtr &inst , bool taken,
-        BranchInfo * tage_bi, Addr corrTarget);
+        Addr branch_pc, int brtype, bool taken, BranchInfo * tage_bi,
+        Addr corrTarget);
 
     virtual void gUpdates( ThreadID tid, Addr pc, bool taken, BranchInfo* bi,
         int64_t phist) = 0;
@@ -263,10 +258,8 @@ class StatisticalCorrector : public SimObject
     void regStats() override;
     void updateStats(bool taken, BranchInfo *bi);
 
-    virtual void condBranchUpdate(ThreadID tid, Addr branch_pc, bool taken,
+    void condBranchUpdate(ThreadID tid, Addr branch_pc, bool taken,
                           BranchInfo *bi, Addr corrTarget, bool bias_bit,
                           int hitBank, int altBank, int64_t phist);
-
-    virtual size_t getSizeInBits() const;
 };
 #endif//__CPU_PRED_STATISTICAL_CORRECTOR_HH
diff --git a/src/cpu/pred/tage_base.cc b/src/cpu/pred/tage_base.cc
index 4f6091b..2d149ea 100644
--- a/src/cpu/pred/tage_base.cc
+++ b/src/cpu/pred/tage_base.cc
@@ -59,14 +59,12 @@ TAGEBase::TAGEBase(const TAGEBaseParams *p)
      logTagTableSizes(p->logTagTableSizes),
      threadHistory(p->numThreads),
      logUResetPeriod(p->logUResetPeriod),
-     initialTCounterValue(p->initialTCounterValue),
      numUseAltOnNa(p->numUseAltOnNa),
      useAltOnNaBits(p->useAltOnNaBits),
      maxNumAlloc(p->maxNumAlloc),
      noSkip(p->noSkip),
      speculativeHistUpdate(p->speculativeHistUpdate),
-     instShiftAmt(p->instShiftAmt),
-     initialized(false)
+     instShiftAmt(p->instShiftAmt)
 {
     if (noSkip.empty()) {
         // Set all the table to enabled by default
@@ -82,9 +80,6 @@ TAGEBase::makeBranchInfo() {
 void
 TAGEBase::init()
 {
-    if (initialized) {
-       return;
-    }
     // Current method for periodically resetting the u counter bits only
     // works for 1 or 2 bits
     // Also make sure that it is not 0
@@ -96,7 +91,7 @@ TAGEBase::init()
 
     // initialize the counter to half of the period
     assert(logUResetPeriod != 0);
-    tCounter = initialTCounterValue;
+    tCounter = ULL(1) << (logUResetPeriod - 1);
 
     assert(histBufferSize > maxHist * 2);
 
@@ -139,7 +134,6 @@ TAGEBase::init()
 
     tableIndices = new int [nHistoryTables+1];
     tableTags = new int [nHistoryTables+1];
-    initialized = true;
 }
 
 void
@@ -345,7 +339,7 @@ TAGEBase::calculateIndicesAndTags(ThreadID tid, Addr branch_pc,
 }
 
 unsigned
-TAGEBase::getUseAltIdx(BranchInfo* bi, Addr branch_pc)
+TAGEBase::getUseAltIdx(BranchInfo* bi)
 {
     // There is only 1 counter on the base TAGE implementation
     return 0;
@@ -403,8 +397,8 @@ TAGEBase::tagePredict(ThreadID tid, Addr branch_pc,
             //if the entry is recognized as a newly allocated entry and
             //useAltPredForNewlyAllocated is positive use the alternate
             //prediction
-            if ((useAltPredForNewlyAllocated[getUseAltIdx(bi, branch_pc)] < 0)
-                || ! bi->pseudoNewAlloc) {
+            if ((useAltPredForNewlyAllocated[getUseAltIdx(bi)] < 0) ||
+                ! bi->pseudoNewAlloc) {
                 bi->tagePred = bi->longestMatchPred;
                 bi->provider = TAGE_LONGEST_MATCH;
             } else {
@@ -507,16 +501,11 @@ TAGEBase::resetUctr(uint8_t & u)
 
 void
 TAGEBase::condBranchUpdate(ThreadID tid, Addr branch_pc, bool taken,
-    BranchInfo* bi, int nrand, Addr corrTarget, bool pred, bool preAdjustAlloc)
+                       BranchInfo* bi, int nrand, Addr corrTarget, bool pred)
 {
     // TAGE UPDATE
     // try to allocate a  new entries only if prediction was wrong
     bool alloc = (bi->tagePred != taken) && (bi->hitBank < nHistoryTables);
-
-    if (preAdjustAlloc) {
-        adjustAlloc(alloc, taken, pred);
-    }
-
     if (bi->hitBank > 0) {
         // Manage the selection between longest matching and alternate
         // matching for "pseudo"-newly allocated longest matching entry
@@ -530,16 +519,13 @@ TAGEBase::condBranchUpdate(ThreadID tid, Addr branch_pc, bool taken,
             // if it was delivering the correct prediction, no need to
             // allocate new entry even if the overall prediction was false
             if (bi->longestMatchPred != bi->altTaken) {
-                ctrUpdate(
-                    useAltPredForNewlyAllocated[getUseAltIdx(bi, branch_pc)],
-                    bi->altTaken == taken, useAltOnNaBits);
+                ctrUpdate(useAltPredForNewlyAllocated[getUseAltIdx(bi)],
+                     bi->altTaken == taken, useAltOnNaBits);
             }
         }
     }
 
-    if (!preAdjustAlloc) {
-        adjustAlloc(alloc, taken, pred);
-    }
+    adjustAlloc(alloc, taken, pred);
 
     handleAllocAndUReset(alloc, taken, bi, nrand);
 
@@ -803,23 +789,6 @@ TAGEBase::isSpeculativeUpdateEnabled() const
     return speculativeHistUpdate;
 }
 
-size_t
-TAGEBase::getSizeInBits() const {
-    size_t bits = 0;
-    for (int i = 1; i <= nHistoryTables; i++) {
-        bits += (1 << logTagTableSizes[i]) *
-            (tagTableCounterBits + tagTableUBits + tagTableTagWidths[i]);
-    }
-    uint64_t bimodalTableSize = ULL(1) << logTagTableSizes[0];
-    bits += numUseAltOnNa * useAltOnNaBits;
-    bits += bimodalTableSize;
-    bits += (bimodalTableSize >> logRatioBiModalHystEntries);
-    bits += histLengths[nHistoryTables];
-    bits += pathHistBits;
-    bits += logUResetPeriod;
-    return bits;
-}
-
 TAGEBase*
 TAGEBaseParams::create()
 {
diff --git a/src/cpu/pred/tage_base.hh b/src/cpu/pred/tage_base.hh
index 9d5451e..48daaf9 100644
--- a/src/cpu/pred/tage_base.hh
+++ b/src/cpu/pred/tage_base.hh
@@ -318,12 +318,10 @@ class TAGEBase : public SimObject
      * @nrand Random int number from 0 to 3
      * @param corrTarget The correct branch target
      * @param pred Final prediction for this branch
-     * @param preAdjustAlloc call adjustAlloc before checking
-     * pseudo newly allocated entries
      */
     virtual void condBranchUpdate(
         ThreadID tid, Addr branch_pc, bool taken, BranchInfo* bi,
-        int nrand, Addr corrTarget, bool pred, bool preAdjustAlloc = false);
+        int nrand, Addr corrTarget, bool pred);
 
     /**
      * TAGE prediction called from TAGE::predict
@@ -366,7 +364,7 @@ class TAGEBase : public SimObject
      * Calculation of the index for useAltPredForNewlyAllocated
      * On this base TAGE implementation it is always 0
      */
-    virtual unsigned getUseAltIdx(BranchInfo* bi, Addr branch_pc);
+    virtual unsigned getUseAltIdx(BranchInfo* bi);
 
     /**
      * Extra calculation to tell whether TAGE allocaitons may happen or not
@@ -403,18 +401,12 @@ class TAGEBase : public SimObject
      */
     virtual void extraAltCalc(BranchInfo* bi);
 
-    virtual bool isHighConfidence(BranchInfo* bi) const
-    {
-        return false;
-    }
-
     void btbUpdate(ThreadID tid, Addr branch_addr, BranchInfo* &bi);
     unsigned getGHR(ThreadID tid, BranchInfo *bi) const;
     int8_t getCtr(int hitBank, int hitBankIndex) const;
     unsigned getTageCtrBits() const;
     int getPathHist(ThreadID tid) const;
     bool isSpeculativeUpdateEnabled() const;
-    size_t getSizeInBits() const;
 
   protected:
     const unsigned logRatioBiModalHystEntries;
@@ -470,7 +462,6 @@ class TAGEBase : public SimObject
     std::vector<int8_t> useAltPredForNewlyAllocated;
     int64_t tCounter;
     uint64_t logUResetPeriod;
-    const int64_t initialTCounterValue;
     unsigned numUseAltOnNa;
     unsigned useAltOnNaBits;
     unsigned maxNumAlloc;
@@ -484,8 +475,6 @@ class TAGEBase : public SimObject
 
     const unsigned instShiftAmt;
 
-    bool initialized;
-
     // stats
     Stats::Scalar tageLongestMatchProviderCorrect;
     Stats::Scalar tageAltMatchProviderCorrect;
diff --git a/src/cpu/pred/tage_sc_l.cc b/src/cpu/pred/tage_sc_l.cc
index de7c2f2..5f17b81 100644
--- a/src/cpu/pred/tage_sc_l.cc
+++ b/src/cpu/pred/tage_sc_l.cc
@@ -168,7 +168,7 @@ TAGE_SC_L_TAGE::calculateIndicesAndTags(
 }
 
 unsigned
-TAGE_SC_L_TAGE::getUseAltIdx(TAGEBase::BranchInfo* bi, Addr branch_pc)
+TAGE_SC_L_TAGE::getUseAltIdx(TAGEBase::BranchInfo* bi)
 {
     BranchInfo *tbi = static_cast<BranchInfo *>(bi);
     unsigned idx;
@@ -457,7 +457,12 @@ TAGE_SC_L::update(ThreadID tid, Addr branch_pc, bool taken, void *bp_history,
     }
 
     if (!tage->isSpeculativeUpdateEnabled()) {
-        statisticalCorrector->scHistoryUpdate(branch_pc, inst, taken,
+        int brtype = inst->isDirectCtrl() ? 0 : 2;
+        if (! inst->isUncondCtrl()) {
+            ++brtype;
+        }
+
+        statisticalCorrector->scHistoryUpdate(branch_pc, brtype, taken,
                                               bi->scBranchInfo, corrTarget);
 
         tage->updateHistories(tid, branch_pc, taken, bi->tageBranchInfo, false,
diff --git a/src/cpu/pred/tage_sc_l.hh b/src/cpu/pred/tage_sc_l.hh
index b3629ab..c96cc89 100644
--- a/src/cpu/pred/tage_sc_l.hh
+++ b/src/cpu/pred/tage_sc_l.hh
@@ -94,7 +94,7 @@ class TAGE_SC_L_TAGE : public TAGEBase {
     void calculateIndicesAndTags(
         ThreadID tid, Addr branch_pc, TAGEBase::BranchInfo* bi) override;
 
-    unsigned getUseAltIdx(TAGEBase::BranchInfo* bi, Addr branch_pc) override;
+    unsigned getUseAltIdx(TAGEBase::BranchInfo* bi) override;
 
     void updateHistories(
         ThreadID tid, Addr branch_pc, bool taken, TAGEBase::BranchInfo* b,
diff --git a/src/cpu/pred/tage_sc_l_64KB.cc b/src/cpu/pred/tage_sc_l_64KB.cc
index 72676e7..164d587 100644
--- a/src/cpu/pred/tage_sc_l_64KB.cc
+++ b/src/cpu/pred/tage_sc_l_64KB.cc
@@ -139,13 +139,8 @@ TAGE_SC_L_64KB_StatisticalCorrector::gIndexLogsSubstr(int nbr, int i)
 
 void
 TAGE_SC_L_64KB_StatisticalCorrector::scHistoryUpdate(Addr branch_pc,
-        const StaticInstPtr &inst, bool taken, BranchInfo* tage_bi,
-        Addr corrTarget)
+        int brtype, bool taken, BranchInfo* tage_bi, Addr corrTarget)
 {
-    int brtype = inst->isDirectCtrl() ? 0 : 2;
-    if (! inst->isUncondCtrl()) {
-        ++brtype;
-    }
     // Non speculative SC histories update
     if (brtype & 1) {
         SC_64KB_ThreadHistory *sh =
@@ -157,7 +152,7 @@ TAGE_SC_L_64KB_StatisticalCorrector::scHistoryUpdate(Addr branch_pc,
         sh->updateLocalHistory(3, branch_pc, taken);
     }
 
-    StatisticalCorrector::scHistoryUpdate(branch_pc, inst, taken, tage_bi,
+    StatisticalCorrector::scHistoryUpdate(branch_pc, brtype, taken, tage_bi,
                                           corrTarget);
 }
 
diff --git a/src/cpu/pred/tage_sc_l_64KB.hh b/src/cpu/pred/tage_sc_l_64KB.hh
index 4928ba5..21dd170 100644
--- a/src/cpu/pred/tage_sc_l_64KB.hh
+++ b/src/cpu/pred/tage_sc_l_64KB.hh
@@ -118,7 +118,7 @@ class TAGE_SC_L_64KB_StatisticalCorrector : public StatisticalCorrector
 
     int gIndexLogsSubstr(int nbr, int i) override;
 
-    void scHistoryUpdate(Addr branch_pc, const StaticInstPtr &inst, bool taken,
+    void scHistoryUpdate(Addr branch_pc, int brtype, bool taken,
                          BranchInfo * tage_bi, Addr corrTarget) override;
 
     void gUpdates(ThreadID tid, Addr pc, bool taken, BranchInfo* bi,
diff --git a/src/cpu/pred/tage_sc_l_8KB.cc b/src/cpu/pred/tage_sc_l_8KB.cc
index 2455990..9af21e1 100644
--- a/src/cpu/pred/tage_sc_l_8KB.cc
+++ b/src/cpu/pred/tage_sc_l_8KB.cc
@@ -101,14 +101,9 @@ int TAGE_SC_L_8KB_StatisticalCorrector::gIndexLogsSubstr(int nbr, int i)
 }
 
 void
-TAGE_SC_L_8KB_StatisticalCorrector::scHistoryUpdate(Addr branch_pc,
-    const StaticInstPtr &inst, bool taken, BranchInfo *tage_bi,
-    Addr corrTarget)
+TAGE_SC_L_8KB_StatisticalCorrector::scHistoryUpdate(Addr branch_pc, int brtype,
+    bool taken, BranchInfo * tage_bi, Addr corrTarget)
 {
-    int brtype = inst->isDirectCtrl() ? 0 : 2;
-    if (! inst->isUncondCtrl()) {
-        ++brtype;
-    }
     // Non speculative SC histories update
     if (brtype & 1) {
         SC_8KB_ThreadHistory *sh =
@@ -116,7 +111,7 @@ TAGE_SC_L_8KB_StatisticalCorrector::scHistoryUpdate(Addr branch_pc,
         sh->globalHist = (sh->globalHist << 1) + taken;
     }
 
-    StatisticalCorrector::scHistoryUpdate(branch_pc, inst, taken, tage_bi,
+    StatisticalCorrector::scHistoryUpdate(branch_pc, brtype, taken, tage_bi,
                                           corrTarget);
 }
 
diff --git a/src/cpu/pred/tage_sc_l_8KB.hh b/src/cpu/pred/tage_sc_l_8KB.hh
index 7730463..74193b0 100644
--- a/src/cpu/pred/tage_sc_l_8KB.hh
+++ b/src/cpu/pred/tage_sc_l_8KB.hh
@@ -99,8 +99,8 @@ class TAGE_SC_L_8KB_StatisticalCorrector : public StatisticalCorrector
     int gIndexLogsSubstr(int nbr, int i) override;
 
     void scHistoryUpdate(
-        Addr branch_pc, const StaticInstPtr &inst, bool taken,
-        BranchInfo * tage_bi, Addr corrTarget) override;
+        Addr branch_pc, int brtype, bool taken, BranchInfo * tage_bi,
+        Addr corrTarget) override;
 
     void gUpdates(ThreadID tid, Addr pc, bool taken, BranchInfo* bi,
         int64_t phist) override;
diff --git a/src/cpu/simple/taskGraph.json b/src/cpu/simple/taskGraph.json
new file mode 100644
index 0000000..a76c07c
--- /dev/null
+++ b/src/cpu/simple/taskGraph.json
@@ -0,0 +1 @@
+{"1": {"total_needSend": 3, "out_links": [["2", 2, [], 0, 0, -1], ["3", 1, [[0, "S"]], 1, 2, 1]], "total_needReceive": 0, "exe_time": 1}, "2": {"total_needSend": 7, "out_links": [["4", 3, [[0, "E"]], 4, 7, 2], ["5", 4, [], 0, 0, -1]], "total_needReceive": 2, "exe_time": 3}, "3": {"total_needSend": 2, "out_links": [["6", 2, [], 0, 0, -1]], "total_needReceive": 1, "exe_time": 2}, "4": {"total_needSend": 2, "out_links": [["7", 2, [], 0, 0, -1]], "total_needReceive": 3, "exe_time": 5}, "5": {"total_needSend": 2, "out_links": [["7", 2, [[0, "E"]], 6, 8, 3]], "total_needReceive": 4, "exe_time": 2}, "6": {"total_needSend": 1, "out_links": [["7", 1, [[2, "N"], [0, "E"]], 6, 7, 4]], "total_needReceive": 2, "exe_time": 4}, "7": {"total_needSend": 0, "out_links": [], "total_needReceive": 5, "exe_time": 1}}
\ No newline at end of file
diff --git a/src/cpu/taskGraph.json b/src/cpu/taskGraph.json
new file mode 100644
index 0000000..a76c07c
--- /dev/null
+++ b/src/cpu/taskGraph.json
@@ -0,0 +1 @@
+{"1": {"total_needSend": 3, "out_links": [["2", 2, [], 0, 0, -1], ["3", 1, [[0, "S"]], 1, 2, 1]], "total_needReceive": 0, "exe_time": 1}, "2": {"total_needSend": 7, "out_links": [["4", 3, [[0, "E"]], 4, 7, 2], ["5", 4, [], 0, 0, -1]], "total_needReceive": 2, "exe_time": 3}, "3": {"total_needSend": 2, "out_links": [["6", 2, [], 0, 0, -1]], "total_needReceive": 1, "exe_time": 2}, "4": {"total_needSend": 2, "out_links": [["7", 2, [], 0, 0, -1]], "total_needReceive": 3, "exe_time": 5}, "5": {"total_needSend": 2, "out_links": [["7", 2, [[0, "E"]], 6, 8, 3]], "total_needReceive": 4, "exe_time": 2}, "6": {"total_needSend": 1, "out_links": [["7", 1, [[2, "N"], [0, "E"]], 6, 7, 4]], "total_needReceive": 2, "exe_time": 4}, "7": {"total_needSend": 0, "out_links": [], "total_needReceive": 5, "exe_time": 1}}
\ No newline at end of file
diff --git a/src/cpu/testers/garnet_synthetic_traffic/GarnetSyntheticTraffic.cc b/src/cpu/testers/garnet_synthetic_traffic/GarnetSyntheticTraffic.cc
index 5b542bc..f301614 100644
--- a/src/cpu/testers/garnet_synthetic_traffic/GarnetSyntheticTraffic.cc
+++ b/src/cpu/testers/garnet_synthetic_traffic/GarnetSyntheticTraffic.cc
@@ -26,15 +26,22 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  * Authors: Tushar Krishna
+ * Multified By: Hui Chen 
  */
 
 #include "cpu/testers/garnet_synthetic_traffic/GarnetSyntheticTraffic.hh"
 
 #include <cmath>
+#include <fstream>
 #include <iomanip>
+#include <iostream>
+#include <queue>
 #include <set>
 #include <string>
 #include <vector>
+#include <unistd.h>
+
+
 
 #include "base/logging.hh"
 #include "base/random.hh"
@@ -46,10 +53,81 @@
 #include "sim/sim_events.hh"
 #include "sim/stats.hh"
 #include "sim/system.hh"
+#define EXBAR 0.108
+#define EBF 0.078
+#define EGLOB 0.031
+#define ELoC 0.008
+#define Lpk 128
+#define ECU 0.917
+
 
-using namespace std;
 
+int numTask=0;
 int TESTER_NETWORK=0;
+int numPseve = 0;
+int numPreve = 0;
+queue<string> graphQ;
+Json::Reader reader;
+Json::Value root;
+int endSendTime = 0;
+int receiveMatrix[MaxRow];
+bool isSDNoC;
+int configureTime;
+int execMatrix[MaxRow];
+int needSend[MaxRow];
+int flag = 0;
+int blockTime = 0;
+int transTime = 0;
+int totalFlits = 0;
+double totalEnergy = 0;
+int checkTimes = 0;
+int controlOverhead = 0;
+pathInfo networkPath[NHOPS];
+map<string,int> allLinks;
+map<string,Json::Value> candidates;
+std::map<std::string,routeInfo> nowTransmit;
+std::map<int,Json::Value> multiOutput;
+map<string,int> numHop;
+map<string,int> numTurn;
+map<string,routeInfo> outLinks[MaxRow];
+int maptoMatrix[MaxRow];
+set<string> totalStart;
+set<string> totalEnd;
+int totalDirect = 0;
+int totalinDirect = 0;
+std::vector<mapTask> mapTasks[MaxRow];
+std::vector<mapTask> dstMapTasks[MaxRow];
+double totalBufferEnergy = 0;
+double totalArbEnergy = 0;
+double totalTransEnergy = 0;
+double totalSmartBufferEnergy = 0;
+double totalSmartArbEnergy = 0;
+double totalExe = 0;
+int totalSize = 0;
+int totalRouter = 0;
+
+int totalIter = 1;
+
+
+int syntheticPattern;
+//int sendAllowMax[NHOPS];
+int isMulticast=0;
+
+void SplitString(const std::string& s, std::vector<std::string>& v, const std::string& c)
+{
+  std::string::size_type pos1, pos2;
+  pos2 = s.find(c);
+  pos1 = 0;
+  while(std::string::npos != pos2)
+  {
+    v.push_back(s.substr(pos1, pos2-pos1));
+ 
+    pos1 = pos2 + c.size();
+    pos2 = s.find(c, pos1);
+  }
+  if(pos1 != s.length())
+    v.push_back(s.substr(pos1));
+}
 
 bool
 GarnetSyntheticTraffic::CpuPort::recvTimingResp(PacketPtr pkt)
@@ -70,7 +148,7 @@ GarnetSyntheticTraffic::sendPkt(PacketPtr pkt)
     if (!cachePort.sendTimingReq(pkt)) {
         retryPkt = pkt; // RubyPort will retry sending
     }
-    numPacketsSent++;
+
 }
 
 GarnetSyntheticTraffic::GarnetSyntheticTraffic(const Params *p)
@@ -85,6 +163,7 @@ GarnetSyntheticTraffic::GarnetSyntheticTraffic(const Params *p)
       simCycles(p->sim_cycles),
       numPacketsMax(p->num_packets_max),
       numPacketsSent(0),
+      numPacketsReceive(0),
       singleSender(p->single_sender),
       singleDest(p->single_dest),
       trafficType(p->traffic_type),
@@ -103,10 +182,14 @@ GarnetSyntheticTraffic::GarnetSyntheticTraffic(const Params *p)
         fatal("Unknown Traffic Type: %s!\n", traffic);
     }
     traffic = trafficStringToEnum[trafficType];
+    syntheticPattern = traffic;
+
 
     id = TESTER_NETWORK++;
+    //id = 0;
     DPRINTF(GarnetSyntheticTraffic,"Config Created: Name = %s , and id = %d\n",
             name(), id);
+
 }
 
 Port &
@@ -125,16 +208,19 @@ GarnetSyntheticTraffic::init()
 }
 
 
+//Receive the packets
 void
 GarnetSyntheticTraffic::completeRequest(PacketPtr pkt)
 {
+    int dest = (pkt->req->getPaddr())>>6;
     DPRINTF(GarnetSyntheticTraffic,
-            "Completed injection of %s packet for address %x\n",
-            pkt->isWrite() ? "write" : "read\n",
-            pkt->req->getPaddr());
+            "Completed injection of %s packet for address %d\n",
+            pkt->isWrite() ? "write" : "read",
+            dest);
 
     assert(pkt->isResponse());
     noResponseCycles = 0;
+
     delete pkt;
 }
 
@@ -145,44 +231,774 @@ GarnetSyntheticTraffic::tick()
     if (++noResponseCycles >= responseLimit) {
         fatal("%s deadlocked at cycle %d\n", name(), curTick());
     }
+    ///////////////////////////////////////////////////////
+    //  Print Network State
+    //  At the beginning of each cycle, print the infomation of network
+    ///////////////////////////////////////////////////////
+    if (id==0)
+    {
+        DPRINTF(GarnetSyntheticTraffic,"++++++++++++++++++++Cycle %d++++++++++++++++++++++\n",curTick());
+        if(isSDNoC){
+            DPRINTF(GarnetSyntheticTraffic,"nowTransmit\n");
+            for (auto iter = nowTransmit.begin();
+                        iter != nowTransmit.end();
+                        iter++)
+                {
+                DPRINTF(GarnetSyntheticTraffic,"%s \n",iter->first);
+                }
+        }
+        PrintNetwork();
+        PrintNetworkState();
+        PrintAllLinks();
+
+    }
+
+    if (traffic == TASKGRAPH_ && curTick()==0&&id==0){
+
+
+        ifstream in(graph_file,ios::binary);
+        char buff[1000];
+        getcwd(buff, 1000);
+        std::cout << "is: "<<buff<<"    "<<graph_file<<"\n";
+
+        if (!in.is_open())
+        {
+            fatal("Fail to open file\n");
+            return;
+        }
+        if(isSDNoC && (routing_algorithm==2))
+        {
+            //cout<<"Here is the multicast !!!!!!!!!!!!!!!!!!!!"<<endl;
+            isMulticast=1;
+        }
+
+        if (reader.parse(in,root))
+        {
+            
+            
+            //Initialize receive send 
+            for (int i = 0; i<root.size();i++)
+            {
+                receiveMatrix[i]=0;
+                needSend[i]=0;
+            }
+            totalSize = root.size();
+            if(totalSize>MaxRow)
+            {
+                exitSimLoop("Maximum number of tasks exceeded! ");
+            }
+            totalRouter = rowNum*rowNum;
+            totalIter = root["0"]["start_time"].asInt();
+            if(totalIter==0)
+            {totalIter = 1;}
+            for (int i = 0; i < root.size() ; i++)
+            {
+                string t = to_string(i);
+                maptoMatrix[i] = -1;
+                //Directly read from the file
+                //receiveMatrix[i] = root[t]["total_needReceive"].asInt();
+                //needSend[i] = root[t]["total_needSend"].asInt();
+                totalFlits+=root[t]["total_needReceive"].asInt();
+                execMatrix[i] = root[t]["exe_time"].asInt();
+                totalExe = totalExe +execMatrix[i];
+                int coreId = root[t]["mapto"].asInt();
+                maptoMatrix[i] = coreId;
+                mapTask taskItem;
+                taskItem.taskId = i;
+                taskItem.state = 0;
+                mapTasks[coreId].push_back(taskItem);
+
+
+                int numberSender = root[t]["out_links"].size();
+                for (int ii = 0; ii < numberSender; ii++){
+                    routeInfo info;
+                    info.state = 0;
+                    info.numberofPkt = root[t]["out_links"][ii][0][1].asInt();
+                    //Configuration time 
+                    Json::Value aroute = root[t]["out_links"][i][0][3];
+                    int shouldBlock = int(ceil(float(aroute.size())/float(hpcMax))*configureTime)+info.numberofPkt;
+                    info.numberofPkt = shouldBlock;
+                    info.src = root[t]["out_links"][ii][0][5].asInt();
+                    info.dst = root[t]["out_links"][ii][0][6].asInt();
+                    
+
+
+                    string outLink = root[t]["out_links"][ii][0][0].asString();
+                    string linkName;
+                    if(root[t]["out_links"][ii][0][4]==0)
+                    {
+                        string outport1 = root[t]["out_links"][ii][0][3][0][1].asString();
+                        info.outputPort = outport1;
+                        linkName = t+"+"+outLink+"+"+outport1;
+                    }
+                    else{linkName = t+"+"+outLink;}
+ 
+                    int transId = root[t]["out_links"][ii][0][0].asInt();
+                    
+                    receiveMatrix[transId] += shouldBlock;
+                    needSend[i] += shouldBlock;
+                    mapTask taskItem;
+                    taskItem.taskId = transId;
+                    taskItem.state = 0;
+
+                    
+                    
+
+                    outLinks[i].insert(make_pair(linkName,info));
+
+                    
+                   
+                    
+                    taskItem.linkname = linkName;
+                    dstMapTasks[info.dst].push_back(taskItem);
+
+                    allLinks.insert(make_pair(linkName,info.numberofPkt));
+                    //numHop.insert(make_pair(linkName,hops));
+                    //numTurn.insert(make_pair(linkName,turns));
+                    Json::Value candi = root[t]["out_links"][ii];
+                    candidates.insert(make_pair(linkName,candi));
+                }
+
+
+            }
+
+            for (int i = 0;i<totalRouter; ++i)
+            {
+                networkPath[i].west = "Unknown";
+                networkPath[i].east = "Unknown";
+                networkPath[i].north = "Unknown";
+                networkPath[i].south = "Unknown";
+                networkPath[i].pport = "Unknown";
+            }
+            // PrintNetworkState();
+            // PrintAllLinks();
+            
+        }
+        else
+        {
+            fatal("Fail to load file\n");
+        }
+
+    }
+
+    //At the begining of each cycle, check if it is the "included cycle"
+    //If yes, send packets,
+    if (traffic == TASKGRAPH_ && id == 0)
+    {
+        //for(int ii=0;ii<NHOPS;ii++)
+        //{sendAllowMax[ii] = 0;}
 
+        DPRINTF(GarnetSyntheticTraffic,
+         "\ncurTick is %d: id %d send packets"
+         "%d receive packets %d receiveMatrix %d\n"
+         , curTick(),id,numPseve, numPreve,receiveMatrix[4]);
+
+    }
     // make new request based on injection rate
     // (injection rate's range depends on precision)
     // - generate a random number between 0 and 10^precision
     // - send pkt if this number is < injRate*(10^precision)
-    bool sendAllowedThisCycle;
-    double injRange = pow((double) 10, (double) precision);
-    unsigned trySending = random_mt.random<unsigned>(0, (int) injRange);
-    if (trySending < injRate*injRange)
-        sendAllowedThisCycle = true;
-    else
-        sendAllowedThisCycle = false;
+    // for this core, check if this can send the packet
+    // changed here
+    // for(int zz=0;zz<MaxRow;zz++){
+    //     if(maptoMatrix[zz]==-1||maptoMatrix[zz]!=id)
+    //         continue;
+     
+    for(int m = 0; m<mapTasks[id].size();m++){
+
+        int zz = mapTasks[id][m].taskId;
+        //cout<<maptoMatrix[zz]<<" "<<zz<<" is maped to "<<id<<endl;
+        bool sendAllowedThisCycle = false;
+        bool execAllowedThisCycle = false;
+        double injRange = pow((double) 10, (double) precision);
+        unsigned trySending = random_mt.random<unsigned>(0, (int) injRange);
+        if (traffic == TASKGRAPH_){
+            if(receiveMatrix[zz]<= 0)
+            {
+                if(execMatrix[zz]>0){
+
+                    sendAllowedThisCycle = false;
+                    execAllowedThisCycle = true;
+                }
+                else{
+                    if (needSend[zz] > 0)
+                    {
+                        //cout<<"send allowed this cycle "<<curTick()<<endl;
+                        sendAllowedThisCycle = true;
+                    }
+                    else
+                        sendAllowedThisCycle = false;
+                }
+            }
+        }
+        else{
+            if (trySending < injRate*injRange)
+                sendAllowedThisCycle = true;
+            else
+                sendAllowedThisCycle = false;
+        }
+
+        if (execAllowedThisCycle)
+        {
+            DPRINTF(GarnetSyntheticTraffic,"executing task in %d at cycle %d \n",zz, curTick());
+            execMatrix[zz]--;
+        }
+            
+
+            // always generatePkt unless fixedPkts or singleSender is enabled
+        if (sendAllowedThisCycle) {           
+            bool senderEnable = true;
+
+            if (numPacketsMax >= 0 && numPacketsSent >= numPacketsMax)
+                senderEnable = false;
+
+            if (singleSender >= 0 && zz != singleSender)
+                senderEnable = false;
+
+            if (senderEnable){
+                //int nextCycle = 0;
+                if (traffic == TASKGRAPH_){
+                    string trackid = to_string(zz);
+                    
+
+                    int totalSend = 0;
+                    for (auto iter = outLinks[zz].begin();iter != outLinks[zz].end();++iter)
+                    {
+                        string linkName = iter->first;
+                        vector<string> t;
+                        SplitString(linkName,t,"+");
+                        int destNow = stoi(t[1],nullptr,0);
+
+                        //sendAllowMax[destNow]++;
+                        Json::Value route1;
+
+                        // string linkName;
+                        // linkName = trackid+"+"+to_string(destNow)+"+"+iter->second.outputPort;
+                        // cout<<"send allowed+++++"<<linkName<<endl;
+                        
+                        //if((iter->seccoutond.numberofPkt==0 && iter->second.state ==1 ))
+                        //Changed here
+                        if(allLinks[linkName]<=1 && iter->second.state !=-1)
+                        {
+                            //  for(int tt = 0;tt<dstMapTasks[iter->second.dst].size();tt++)
+                            //     {
+                            //         if(dstMapTasks[iter->second.dst][tt].linkname == linkName)
+                            //         {
+                            //             dstMapTasks[iter->second.dst][tt].state = 2;
+                            //         }
+                            // }
+                            //cout<<linkName<<endl;
+                            if(isSDNoC){
+                                //Release Resources
+                                int arrayNum = iter->second.route.size();
+
+                                for(int i=0;i<arrayNum;++i)
+                                {
+                                    int routerNum = iter->second.route[i][0].asInt();
+
+                                    string routerDirIn = iter->second.route[i][1].asString();
+                                    string routerDirOut = iter->second.route[i][2].asString();
+                                    //cout<<"Release Link+++++++++"<<linkName<<endl;
+                                    ReleaseLink(routerNum,routerDirIn);
+                                    //ReleaseLink(routerNum,routerDirOut);
+
+                                }
+                            }
+                            DPRINTF(GarnetSyntheticTraffic,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!End Transmission!! linkName %d at cycle %d \n",linkName, curTick());
+                            
+                            //totalEnd++;
+                            totalEnd.insert(linkName);
+                            iter->second.state = -1;
+                            //PrintNetworkState();
+                            //PrintAllLinks();
+                            //nowTransmit.erase(linkName);
+
 
-    // always generatePkt unless fixedPkts or singleSender is enabled
-    if (sendAllowedThisCycle) {
-        bool senderEnable = true;
+                        }
+                        //changed here
+                        //if ((iter->second.numberofPkt>0&&totalSend<4))
+                        if(allLinks[linkName]>0)
+                        {
+                            // cout<<"This is outLinks"<<id<<" "
+                            //  <<iter->first<<"this is reminder"
+                            //  <<iter->second.numberofPkt<<" total sent "<<totalSend<<endl;
 
-        if (numPacketsMax >= 0 && numPacketsSent >= numPacketsMax)
-            senderEnable = false;
+                            if(!isSDNoC)
+                            {  
+                                //totalSent numbers
+                                if(totalSend<=1){
+                                DPRINTF(GarnetSyntheticTraffic,"!!!!!!!!!!!!Sending Now!! linkName %d at cycle %d \n",linkName, curTick());
+                                //cout<<"Sending Now+++"<<id<<" dest: "<<iter->second.dst<<" linkname: "<<linkName<<endl;
+                                generatePkt(zz,destNow,iter->second.src,iter->second.dst,linkName);
+
+                                for(int tt = 0;tt<dstMapTasks[iter->second.dst].size();tt++)
+                                {
+                                    if(dstMapTasks[iter->second.dst][tt].linkname == linkName)
+                                    {
+                                        dstMapTasks[iter->second.dst][tt].state = 1;
+                                    }
+                                }
+                                totalSend+= 1;
+                                break;
+                                
+                                }
+                                else
+                                {
+                                    break;
+                                }
+                            }
+                            else
+                            {
+
+                                //If the state is 0; check the state and begin to transfer
+                                if(iter->second.state == 0 )
+                                {
+                                    route1 = iter->second.route;
+
+                                    int checkSuccess = generateSDNPkt(zz,destNow,iter->second,linkName);
+                                    if(checkSuccess==1)
+                                    {
+                                        //cout<<"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Start Transmission!!"<<trackid<<" "<<destNow<<" "<<curTick()<<endl;
+                                        DPRINTF(GarnetSyntheticTraffic,"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Start Transmission!! from %d to %d at cycle %d \n",trackid, destNow, curTick());
+                                        //totalStart++;
+                                        totalStart.insert(linkName);
+                                        totalSend+= 1;
+                                        
+                                        receiveMatrix[destNow]--;
+                                        needSend[zz]--;
+                                        allLinks[linkName]--;
+                                        
+                                        int hops = iter->second.route.size();
+                                        int turns = iter->second.turns;
+                                        int srccluster = belongCluster(iter->second.src);
+                                        int dstcluster = belongCluster(iter->second.dst);
+                                        int clusterDiff = 0;
+                                        if((srccluster==1&&dstcluster==2)||(srccluster==2&&dstcluster==1)) 
+                                            clusterDiff =3;
+                                        else if((srccluster==0&&dstcluster==2)||(srccluster==2&&dstcluster==0))
+                                            clusterDiff =2;
+                                        else
+                                            clusterDiff = abs(srccluster - dstcluster)+1;
+                                        
+                                        controlOverhead += clusterDiff*2 + configureTime; 
+                                        iter->second.state = clusterDiff*2;
+                                        if(turns==0)
+                                            totalDirect++;
+                                        else if(turns==1)
+                                            totalinDirect++;
+                                        else
+                                        {
+                                            //cout<<"error"<<turns<<endl;
+                                            turns = 0;
+                                            totalDirect++;
+                                        }
+                                        transTime+=turns*1;
+                                        transTime++;
+                                        //cout<<"hops: "<<hops<<endl;
+                                        //totalEnergy+= (EXBAR*(hops+1) + EBF*turns + EGLOB*hops + 2* ELoC) * Lpk + ECU*(hops+1);
+                                        totalEnergy+= (EXBAR*(hops+1) + EBF*(hops-2) + EGLOB*hops + 2* ELoC) * Lpk + ECU*(hops+1);
+                                        totalSmartBufferEnergy+= (EBF*(hops-2) + EGLOB*hops + 2* ELoC)* Lpk;
+                                        totalSmartArbEnergy+=ECU*(hops+1);
+                                        totalTransEnergy+=EXBAR*(hops+1)* Lpk;
+                                        totalArbEnergy+=EGLOB*hops;
+                                    }
+                                    // else
+                                    // {
+                                    //     blockTime++;
+                                    // }
+                                     
+                                }
+                                if(iter->second.state>1)
+                                {
+                                    iter->second.state--;
+                                }
+                                if(iter->second.state==1 || iter->second.state==-1)
+                                //else
+                                {
+                                    // if(iter->second.state!=1)
+                                    //     cout<<"state=="<<iter->second.state<<endl;
+                                    int hops = iter->second.route.size();
+                                    int turns = iter->second.turns;
+                                    
+                                    if(turns==0)
+                                        totalDirect++;
+                                    else if(turns==1)
+                                        totalinDirect++;
+                                    else
+                                    {
+                                        //cout<<"error"<<turns<<endl;
+                                        turns = 0;
+                                        totalDirect++;
+                                    }
+                                    
+                                    generatePkt(zz,destNow,iter->second.src,iter->second.dst,linkName);
+                                    totalSend+= 1;
+                                    receiveMatrix[destNow]--;   
+                                    transTime++;
+                                    transTime+=turns*1;
+                                    needSend[zz]--;  
+                                    allLinks[linkName]--;   
+                                    //cout<<"Sending Now+++"<<id<<" dest: "<<iter->second.dst<<" linkname: "<<linkName<<endl;
+                                    //totalEnergy+= (EXBAR*(hops+1) + EBF*turns + EGLOB*hops + 2* ELoC) * Lpk + ECU*(hops+1); 
+                                    totalEnergy+= (EXBAR*(hops+1) + EBF*(hops-2) + EGLOB*hops + 2* ELoC) * Lpk + ECU*(hops+1);   
+                                    totalSmartBufferEnergy+= (EBF*(hops-2) + EGLOB*hops + 2* ELoC)* Lpk;
+                                    totalSmartArbEnergy+=ECU*(hops+1);
+                                    totalTransEnergy+=EXBAR*(hops+1)* Lpk;
+                                    
+                                }
+
+                            }
+                            
+                        }
+                       
+                    }
+                }
+                else
+                {
+                    generatePkt(0,0,0,0," ");
+                }
+            }
+
+        }
+    }
+    
+    if (traffic == TASKGRAPH_ && id == 0 && curTick()>1)
+    {
+        //cout<<"checking+++++++++"<<allLinks.size()<<endl;
+
+        flag = 1;
+        for (auto iter = allLinks.begin();iter != allLinks.end();iter++)
+        {
+            //cout<<iter->first<<iter->second<<endl;
+            if(int(iter->second)>0)
+            {
+                flag = 0;
+                break;
+            }
+        }
+       
+        
+    }
+    
+    if (flag == 1 && curTick()>0 && id==0)
+    {
+        //PrintNetworkState();
+        //PrintAllLinks();
+        // cout<<"Total blocking time: "<<blockTime<<endl;
+        cout<<"Ending+++++++++"<<endl;
+        // vector<string> v;
+        // cout<<graph_file<<endl;
+        // SplitString(graph_file,v,"/");
+
+        // cout<<v[1]<<endl;
+        // vector<string> t;
+        // SplitString(v[1],t,"_");
+        // vector<string> z;
+        // SplitString(t[2],z,"R");
+        //cout<<z[1]<<endl;
+        //int appSize = stoi(z[1]);
+
+        int tranTotal = transTime+blockTime;
+        //double latency = tranTotal/appSize;
+        //double throughput = totalFlits/curTick();
+        double checkEnergy = checkTimes*ECU;
+        cout<<"Total Iteration: "<<totalIter<<endl;
+        cout<<"Schedule Length: " <<curTick()*totalIter<<endl;
+        cout<<"Total Trasmission Time: "<<tranTotal<<endl;
+        cout<<"Total Execution Time: "<<totalExe<<endl;
+        if(isSDNoC){
+            
+            //cout<<"Communication latency: "<<latency<<endl;
+            //cout<<"Network throughput: "<< throughput<<endl;
+            // cout<<"Total direct: "<< totalDirect<<endl;
+            // cout<<"Total indirect: "<< totalinDirect<<endl;
+            cout<<"Contention Time: "<<blockTime<<endl;
+            cout<<"Control Time: "<<controlOverhead<<endl;
+            cout<<"Total Energy: "<<totalEnergy<<endl;
+            cout<<"Total Transmission Energy: "<<totalTransEnergy<<endl;
+            cout<<"Total Arbitration Energy: "<<totalArbEnergy<<endl;
+            cout<<"Checking Energy: "<<checkEnergy<<endl;
+        }
+        
+        
+
+        //cout<<t[2]<<endl;
+        ofstream out("results.txt",ios::app);
+        if(!out)
+        {
+            cout<< "results.txt can't open"<< endl;
+        }
+        else
+        {   
+            out<<"Filename: "<<graph_file<<endl;
+            out<<"Total Iteration: "<<totalIter<<endl;
+            out<<"Schedule Length: " <<curTick()*totalIter<<endl;
+            out<<"Total Transmission Time: "<<transTime+blockTime<<endl;
+            out<<"Total Execution: "<<totalExe<<endl;
+            if(isSDNoC){
+                out<<"Contention Time: "<<blockTime<<endl;
+                out<<"Control Time: "<<controlOverhead<<endl;
+                out<<"Total Energy: "<<totalEnergy<<endl;
+                out<<"Total Transmission Energy: "<<totalTransEnergy<<endl;
+                out<<"Total Arbitration Energy: "<<totalArbEnergy<<endl;
+                out<<"Checking Energy: "<<checkEnergy<<endl;
+            }
+            
+            out.close();
+        }
+        //PrintdstMaptaks();
+        exitSimLoop("Network Tester completed. There is no task to execute.\n");
 
-        if (singleSender >= 0 && id != singleSender)
-            senderEnable = false;
 
-        if (senderEnable)
-            generatePkt();
     }
 
-    // Schedule wakeup
-    if (curTick() >= simCycles)
+    if (curTick() >= simCycles){
+        if(id==0){
+        
+        set<string> result;
+        
+        set_difference(  totalEnd.begin(), totalEnd.end() ,totalStart.begin(), totalStart.end(), inserter(result,result.begin()));
+        
+        PrintNetworkState();
+        PrintNetwork();
+        PrintAllLinks();
+        cout<<"Difference: "<<totalStart.size()<<" "<<totalEnd.size()<<" "<<result.size()<<endl;
+        for (auto iter = result.begin();iter != result.end();iter++)
+        {
+            cout<<*iter<<endl;
+        }
+        cout<<"\n";
+        PrintdstMaptaks();
+
+    }
         exitSimLoop("Network Tester completed simCycles");
+    }
     else {
         if (!tickEvent.scheduled())
             schedule(tickEvent, clockEdge(Cycles(1)));
     }
 }
 
+void GarnetSyntheticTraffic::PrintNetworkState()
+{
+    DPRINTF(GarnetSyntheticTraffic,
+        "\n receiveMatrix: task remaining needs to receive: ");
+
+    for(int i2=0;i2<totalSize;++i2)
+    {
+        DPRINTF(GarnetSyntheticTraffic," %d %d |",i2,receiveMatrix[i2]);
+        if(i2%rowNum==0)
+        {
+            DPRINTF(GarnetSyntheticTraffic,"\n");
+        }
+    }
+    DPRINTF(GarnetSyntheticTraffic,"\n");
+    DPRINTF(GarnetSyntheticTraffic,
+        "\n needSend: task needs to send: ");
+    for(int i2=0;i2<totalSize;++i2)
+    {
+        DPRINTF(GarnetSyntheticTraffic," %d %d |",i2,needSend[i2]);
+        if(i2%rowNum==0)
+        {
+            DPRINTF(GarnetSyntheticTraffic,"\n");
+        }
+    }
+    DPRINTF(GarnetSyntheticTraffic,"\n");
+    DPRINTF(GarnetSyntheticTraffic,
+        "\n execMatrix: processor needs to exe: ");
+
+    for(int i2=0;i2<totalSize;++i2)
+    {
+        DPRINTF(GarnetSyntheticTraffic," %d %d |",i2,execMatrix[i2]);
+        if(i2%rowNum==0)
+        {
+            DPRINTF(GarnetSyntheticTraffic,"\n");
+        }
+    }
+    DPRINTF(GarnetSyntheticTraffic,"\n");
+    //cout<<totalStart<<" "<<totalEnd<<endl;
+}
+void GarnetSyntheticTraffic::PrintdstMaptaks()
+{
+    cout<<"\n dstMatrix: router remaining needs to receive";
+    for(int i2=0;i2<50;++i2)
+    {
+        cout<<i2<<endl;
+        for (int tt=0;tt<dstMapTasks[i2].size();tt++)
+            cout<<i2<<" "<<dstMapTasks[i2][tt].linkname<<" "<<dstMapTasks[i2][tt].state<<" | ";
+        cout<<endl;
+        
+    }
+    for(int i2=0;i2<50;++i2)
+    {
+        cout<<i2<<endl;
+        for (int tt=0;tt<mapTasks[i2].size();tt++)
+            cout<<mapTasks[i2][tt].taskId<<" | ";
+        cout<<endl;
+        
+    }
+}
+
+void GarnetSyntheticTraffic::PrintAllLinks()
+{
+    DPRINTF(GarnetSyntheticTraffic,"Print ALL Links!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
+    DPRINTF(GarnetSyntheticTraffic,"All Links: from+to+port remaining\n");
+    for (auto iter = allLinks.begin();iter != allLinks.end();iter++)
+    {
+        
+        DPRINTF(GarnetSyntheticTraffic," %d %d |",iter->first,iter->second);
+    }
+    DPRINTF(GarnetSyntheticTraffic,"\n");
+}
+
+
+void GarnetSyntheticTraffic::printAllCandidate()
+{
+    DPRINTF(GarnetSyntheticTraffic,"Print ALL Candidates!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
+
+    for (auto iter = candidates.begin();iter != candidates.end();iter++)
+    {
+        DPRINTF(GarnetSyntheticTraffic,"%s \n",iter->first);
+        int i = 0;
+        for (i=0;i<iter->second.size();i++)
+            DPRINTF(GarnetSyntheticTraffic," %s ",iter->second[i][0].asString());
+    }
+    DPRINTF(GarnetSyntheticTraffic,"\n");
+}
+
+void GarnetSyntheticTraffic::PrintNetwork()
+{
+    
+    DPRINTF(GarnetSyntheticTraffic,"\n networkPath: networkPath info\n");
+    for(int i2=0;i2<totalRouter;i2++)
+    {
+        if(i2%rowNum==0)
+        {
+            DPRINTF(GarnetSyntheticTraffic,"\n");
+        }
+        DPRINTF(GarnetSyntheticTraffic," %d %d |",i2,networkPath[i2].north[0]);
+
+    }
+    DPRINTF(GarnetSyntheticTraffic,"\n");
+}
+
+
+
+
+bool GarnetSyntheticTraffic::CheckLink(int routerNum, string routerDir)
+{
+    //cout<<"checklink"<<routerNum<<routerDir<<endl;
+    int z=routerDir.size();
+    for(int i=0;i<z;i++){
+        //cout<<"network port: "<<routerDir[i]<<" W "<<networkPath[routerNum].west<<" E "<<networkPath[routerNum].east<<" S "<<networkPath[routerNum].south<<" N "<<networkPath[routerNum].north<<endl;
+        if((networkPath[routerNum].west!="Unknown"&&routerDir[i]=='W')||
+                (networkPath[routerNum].east!="Unknown"&&routerDir[i]=='E')||
+                (networkPath[routerNum].north!="Unknown"&&routerDir[i]=='N')||
+                (networkPath[routerNum].south!="Unknown"&&routerDir[i]=='S')||
+                (networkPath[routerNum].pport!="Unknown"&&routerDir[i]=='P'))
+            {
+                return false;
+            }
+    }
+    return true;
+}
+string GarnetSyntheticTraffic::outPortCompute(string outPort)
+{
+    if(outPort=="N")
+        return "South";
+    else if(outPort=="P")
+        return "Local";
+    else if(outPort=="W")
+        return "West";
+    else if(outPort=="E")    
+        return "East";
+    else if(outPort=="S")
+        return "North";
+    else
+        return "Unknown";
+
+}
+
+void GarnetSyntheticTraffic::ReserveLink(int routerNum, string routerDir,string outPort)
+{
+    if(routerDir=="W")
+    {
+        //networkPath[routerNum].west=outPortCompute(outPort);
+        networkPath[routerNum].west="W";
+    }
+    else if(routerDir=="E")
+    {
+        //networkPath[routerNum].east=outPortCompute(outPort);
+        networkPath[routerNum].east="E";
+    }
+    else if(routerDir=="N")
+    {
+        //changed here
+        //networkPath[routerNum].south=outPortCompute(outPort);
+        networkPath[routerNum].north="N";
+    }
+    else if(routerDir=="S")
+    {
+        //changed here
+        //networkPath[routerNum].north=outPortCompute(outPort);
+        networkPath[routerNum].south="S";
+    }
+    else if(routerDir=="P")
+    {
+        networkPath[routerNum].pport="P";
+    }
+    else
+    {
+        //cout<<"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++Unknown port"<<endl;
+    }
+
+}
+
+
+void GarnetSyntheticTraffic::ReleaseLink(int routerNum, string routerDir)
+{
+    if(routerDir=="W")
+    {
+        networkPath[routerNum].west="Unknown";
+    }
+    else if(routerDir=="E")
+    {
+        networkPath[routerNum].east="Unknown";
+    }
+    else if(routerDir=="N")
+    {
+        networkPath[routerNum].north="Unknown";
+    }
+    else if(routerDir=="S")
+    {
+        networkPath[routerNum].south="Unknown";
+    }
+    else if(routerDir=="P")
+    {
+        networkPath[routerNum].pport="Unknown";
+    }
+    else
+    {
+       // cout<<"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++Unknown port"<<endl;
+    }
+}
+
+int
+GarnetSyntheticTraffic::belongCluster(int routernumber)
+{
+    int t = 0;
+    if (routernumber%16>8)
+    {
+        t++;
+    }
+    if(routernumber/16>8)
+    {
+        t++;
+    }
+    return t;
+}
 void
-GarnetSyntheticTraffic::generatePkt()
+GarnetSyntheticTraffic::generatePkt(int src, unsigned dest, int realsrc, int realdst,string linkName)
 {
     int num_destinations = numDestinations;
     int radix = (int) sqrt(num_destinations);
@@ -192,6 +1008,7 @@ GarnetSyntheticTraffic::generatePkt()
     int source = id;
     int src_x = id%radix;
     int src_y = id/radix;
+    unsigned realdst1 = realdst;
 
     if (singleDest >= 0)
     {
@@ -238,6 +1055,10 @@ GarnetSyntheticTraffic::generatePkt()
         dest_y = src_y;
         destination = dest_y*radix + dest_x;
     }
+      else if (traffic == TASKGRAPH_){
+        destination = realdst1;
+        }
+
     else {
         fatal("Unknown Traffic Type: %s!\n", traffic);
     }
@@ -298,7 +1119,7 @@ GarnetSyntheticTraffic::generatePkt()
         requestType = MemCmd::ReadReq;
         flags.set(Request::INST_FETCH);
         req = std::make_shared<Request>(
-            0, 0x0, access_size, flags, masterId, 0x0, 0);
+            1, 0x1, access_size, flags, masterId, 0x1, 1);
         req->setPaddr(paddr);
     } else {  // if (injReqType == 2)
         // generate packet for virtual network 2
@@ -306,20 +1127,289 @@ GarnetSyntheticTraffic::generatePkt()
         req = std::make_shared<Request>(paddr, access_size, flags, masterId);
     }
 
-    req->setContext(id);
+    req->setContext(source);
 
     //No need to do functional simulation
     //We just do timing simulation of the network
 
     DPRINTF(GarnetSyntheticTraffic,
-            "Generated packet with destination %d, embedded in address %x\n",
-            destination, req->getPaddr());
+            "Generated packet with source %d, destination %d"
+            ", embedded in address %x, packet size is %d\n",
+            source, destination, req->getPaddr(), req->getSize());
 
     PacketPtr pkt = new Packet(req, requestType);
-    pkt->dataDynamic(new uint8_t[req->getSize()]);
+    if (traffic == TASKGRAPH_)
+    {  
+        //pkt->dataDynamic(var);
+        uint8_t *var = new uint8_t[req->getSize()];
+        var[0] = 0x10;
+        var[1] = 0x12;
+        pkt->dataDynamic(var);
+        //pkt->realSrc=src;
+        //pkt->realDst=dest;
+
+       
+       //int t = pkt->getBE();
+        //cout<<"Sending package"<<var[0]<<endl;
+
+
+    }
+    else
+        pkt->dataDynamic(new uint8_t[req->getSize()]);
     pkt->senderState = NULL;
+    numPseve++;
+    numPacketsSent++;
+    //cout<<"Sending package"<<pkt->getBE()<<endl;
+    if (traffic == TASKGRAPH_)
+    {
+        numPreve++;
+        numPacketsReceive++;
+        outLinks[src][linkName].numberofPkt--;
+        //needSend[id]--;
+    }
+    if(!isSDNoC)
+        sendPkt(pkt);
 
-    sendPkt(pkt);
+}
+
+
+//check path information
+int checkPath(int src, int dst, Json::Value route)
+{
+    //int temp;
+    //cin>>temp;
+    int arrayNum = route.size();
+    if(src==dst)
+        return 0;
+    if(arrayNum==0)
+    {
+        cout<<"route info missing! "<<endl;
+        return 1;
+    }
+    for(int i=0;i<(arrayNum-1);++i)
+    {
+        int routerNum = route[i][0].asInt();
+        string routerDirIn = route[i][1].asString();
+        if(i==0 &&(src!=routerNum))
+        {
+            cout<<"source router error! "<<endl;
+            return 2;
+        }
+        int nextNum=0;
+
+        if(routerDirIn[0]=='W')
+            nextNum = -1;
+        else if (routerDirIn[0]=='E')
+            nextNum = 1;
+        else if (routerDirIn[0]=='N')
+            nextNum = -rowNum;
+        else if (routerDirIn[0]=='S')
+            nextNum = rowNum;
+        else{
+            cout<<"Unknown Port "<<endl;
+            return 3;
+        }
+        int nextRouter = route[i+1][0].asInt();
+        if(nextRouter!=(routerNum+nextNum))
+        {
+            cout<<"router error! "<<routerNum <<" to "<<nextRouter<<endl;
+            return 4;
+        }
+            
+    }
+    int routerNum = route[arrayNum-1][0].asInt();
+    string routerDirIn = route[arrayNum-1][1].asString();
+    int nextNum=0;
+
+    if(routerDirIn[0]=='W')
+        nextNum = -1;
+    else if (routerDirIn[0]=='E')
+        nextNum = 1;
+    else if (routerDirIn[0]=='N')
+        nextNum = -rowNum;
+    else if (routerDirIn[0]=='S')
+        nextNum = rowNum;
+    else{
+        cout<<"Unknown Port "<<endl;
+        return 3;
+    }
+    if(dst!=(routerNum+nextNum))
+    {
+        
+        cout<<"destination router error! "<<"From "<<src<<" through "<<routerNum<<nextNum<<"to"<<dst<<endl;
+        return 5;
+    }
+
+    return 0;
+}
+// Changed here, adding candidates selection 
+// check can send or not
+// source, destination, path information, link name
+int
+GarnetSyntheticTraffic::generateSDNPkt(int src,unsigned dest,routeInfo onePath,string linkName)
+{
+
+    checkTimes++;
+    //string linkName = to_string(src)+"+"+to_string(dest);
+    Json::Value candi = candidates[linkName];
+    int z = candi.size();
+    Json::Value route;
+    int checkSuccess = 1;
+    unsigned realdst1 = onePath.dst;
+    
+    //Candidate selection
+    for(int j = 0;j<z;j++){
+        checkSuccess = 1;
+        route = candi[j][3];
+        
+        int arrayNum = route.size();
+        //cout<<candi[j][4]<<endl;
+        if(candi[j][4]!=1)
+        {
+            int pathCheckResult= checkPath(onePath.src, onePath.dst,route);
+            if(pathCheckResult!=0)
+            {
+            
+                exitSimLoop("Router error, exist.\n");
+            }
+        }
+
+        for(int i=0;i<arrayNum;++i)
+        {
+            int routerNum = route[i][0].asInt();
+            string routerDirIn = route[i][1].asString();
+            //real source onePath.src
+            //real destination onePath.dst
+            
+
+            checkSuccess = CheckLink(routerNum,routerDirIn);
+            //cout<<"check result "<<routerNum<<" "<<routerDirIn<<endl;
+            if(!checkSuccess)
+            {
+                //cout<<"check result "<<routerNum<<" "<<routerDirIn<<endl;
+                break;
+            }
+
+            // string routerDirOut = route[i][2].asString();
+            // checkSuccess = CheckLink(routerNum,routerDirOut);
+            // if(!checkSuccess)
+            //     break;
+
+        }
+        if(checkSuccess)
+        {
+
+            outLinks[src][linkName].route = route;
+            if(candi[j][4]<=2)
+                outLinks[src][linkName].turns = 0;
+            else
+                outLinks[src][linkName].turns = 1;
+            break;
+
+        }
+    }
+    //checkSuccess=1;
+
+    if(checkSuccess==1)
+    {
+        unsigned destination = realdst1;
+
+        int source = id;
+
+
+        Addr paddr =  destination;
+        paddr <<= blockSizeBits;
+        unsigned access_size = 1; 
+
+        MemCmd::Command requestType;
+
+        RequestPtr req = nullptr;
+        Request::Flags flags;
+        // Inject in specific Vnet
+        // Vnet 0 and 1 are for control packets (1-flit)
+        // Vnet 2 is for data packets (5-flit)
+        int injReqType = injVnet;
+
+        if (injReqType < 0 || injReqType > 2)
+        {
+            // randomly inject in any vnet
+            injReqType = random_mt.random(0, 2);
+        }
+
+        if (injReqType == 0) {
+            // generate packet for virtual network 0
+            requestType = MemCmd::ReadReq;
+            req = std::make_shared<Request>(paddr, access_size, flags, masterId);
+        } else if (injReqType == 1) {
+            // generate packet for virtual network 1
+            requestType = MemCmd::ReadReq;
+            flags.set(Request::INST_FETCH);
+            req = std::make_shared<Request>(
+                0, 0x0, access_size, flags, masterId, 0x0, 0);
+            req->setPaddr(paddr);
+        } else {  // if (injReqType == 2)
+            // generate packet for virtual network 2
+            requestType = MemCmd::WriteReq;
+            req = std::make_shared<Request>(paddr, access_size, flags, masterId);
+        }
+
+
+        req->setContext(source);
+
+        //Allocate the resource in the resource table
+
+        int arrayNum = route.size();
+        for(int i=0;i<arrayNum;++i)
+        {
+            int routerNum = route[i][0].asInt();
+            string routerDirIn = route[i][1].asString();
+            string routerDirOut = route[i][2].asString();
+            DPRINTF(GarnetSyntheticTraffic," %d Reserve Links+++++++++++++++++++++++++++++++++ %s \n",routerNum,routerDirOut);
+            ReserveLink(routerNum, routerDirIn,routerDirOut);
+        }
+
+
+
+        DPRINTF(GarnetSyntheticTraffic,
+                "Generated packet with source %d, destination %d"
+                ", embedded in address %x, packet size is %d\n",
+                source, destination, req->getPaddr(), req->getSize());
+
+        PacketPtr pkt = new Packet(req, requestType);
+        if (traffic == TASKGRAPH_)
+            pkt->dataDynamic(new uint8_t[1]);
+        else
+            pkt->dataDynamic(new uint8_t[req->getSize()]);
+        pkt->senderState = NULL;
+        numPseve++;
+        numPacketsSent++;
+        DPRINTF(GarnetSyntheticTraffic,"Sending package +++++++++++++++++++++++++++++++++  from %d to %d \n",src,dest);
+        
+        if (traffic == TASKGRAPH_)
+        {
+            numPreve++;
+            numPacketsReceive++;
+            outLinks[src][linkName].numberofPkt--;
+            //receiveMatrix[dest]--;
+            //needSend[id]--;
+        }
+        if(!isSDNoC)
+            sendPkt(pkt);
+       
+        // string linkName;
+
+        // linkName = to_string(src)+"+"+to_string(dest);
+        //nowTransmit.insert(make_pair(linkName,onePath));
+
+    }
+    else
+    {
+        blockTime++;
+        DPRINTF(GarnetSyntheticTraffic,"contention!!!!!!!!!!!!!!!!!!!!!  from %d to %d \n",src,dest);
+      
+    }
+    
+    return checkSuccess;
 }
 
 void
@@ -333,6 +1423,8 @@ GarnetSyntheticTraffic::initTrafficType()
     trafficStringToEnum["tornado"] = TORNADO_;
     trafficStringToEnum["transpose"] = TRANSPOSE_;
     trafficStringToEnum["uniform_random"] = UNIFORM_RANDOM_;
+    trafficStringToEnum["taskgraph"] = TASKGRAPH_;
+
 }
 
 void
@@ -353,5 +1445,6 @@ GarnetSyntheticTraffic::printAddr(Addr a)
 GarnetSyntheticTraffic *
 GarnetSyntheticTrafficParams::create()
 {
-    return new GarnetSyntheticTraffic(this);
+
+   return new GarnetSyntheticTraffic(this);
 }
diff --git a/src/cpu/testers/garnet_synthetic_traffic/GarnetSyntheticTraffic.hh b/src/cpu/testers/garnet_synthetic_traffic/GarnetSyntheticTraffic.hh
index 3e77e9e..52b3d65 100644
--- a/src/cpu/testers/garnet_synthetic_traffic/GarnetSyntheticTraffic.hh
+++ b/src/cpu/testers/garnet_synthetic_traffic/GarnetSyntheticTraffic.hh
@@ -31,7 +31,13 @@
 #ifndef __CPU_GARNET_SYNTHETIC_TRAFFIC_HH__
 #define __CPU_GARNET_SYNTHETIC_TRAFFIC_HH__
 
+#include <jsoncpp/json/json.h>
+
+
+#include <map>
 #include <set>
+#include <string>
+#include <vector>
 
 #include "base/statistics.hh"
 #include "mem/port.hh"
@@ -41,6 +47,30 @@
 #include "sim/sim_exit.hh"
 #include "sim/sim_object.hh"
 #include "sim/stats.hh"
+#include "mem/ruby/network/garnet2.0/GarnetNetwork.hh"
+
+#define NHOPS 256
+#define ROW 8
+#define MaxRow 1000
+#define MaxCol 500
+
+extern int receiveMatrix[MaxRow];
+extern int execMatrix[MaxRow];
+extern bool isSDNoC;
+extern int configureTime;
+extern std::string graph_file;
+extern int syntheticPattern;
+extern int isMulticast;
+extern int hpcMax;
+
+extern std::map<std::string,int> allLinks;
+extern std::map<int,Json::Value> multiOutput;
+extern double totalEnergy;
+extern int transTime;
+
+
+using namespace std;
+
 
 enum TrafficType {BIT_COMPLEMENT_ = 0,
                   BIT_REVERSE_ = 1,
@@ -50,9 +80,57 @@ enum TrafficType {BIT_COMPLEMENT_ = 0,
                   TORNADO_ = 5,
                   TRANSPOSE_ = 6,
                   UNIFORM_RANDOM_ = 7,
+                  TASKGRAPH_ = 8,
                   NUM_TRAFFIC_PATTERNS_};
 
+
 class Packet;
+
+struct routeInfo{
+    int numberofPkt;
+    Json::Value route;
+    int state;
+    int prior; 
+    int turns;
+    int src;
+    int dst;
+    string outputPort;
+};
+
+struct pathInfo
+{
+    string north;
+    string south;
+    string west;
+    string east;
+    string pport;
+
+};
+
+struct routerConf
+{
+    int pPort[4];
+    int wPort;
+    int ePort;
+    int nPort;
+    int sPort;
+    int state;
+};
+
+struct mapTask
+{
+    int taskId;
+    // state 0; Not start; 
+    // State 1: start;
+    // State 2: finish;
+    int state;
+    string linkname;
+};
+
+extern std::map<std::string,routeInfo> nowTransmit;
+extern pathInfo networkPath[NHOPS]; 
+extern std::vector<mapTask> dstMapTasks[MaxRow];
+
 class GarnetSyntheticTraffic : public ClockedObject
 {
   public:
@@ -121,8 +199,10 @@ class GarnetSyntheticTraffic : public ClockedObject
     Tick simCycles;
     int numPacketsMax;
     int numPacketsSent;
+    int numPacketsReceive;
     int singleSender;
     int singleDest;
+    int sendTime;
 
     std::string trafficType; // string
     TrafficType traffic; // enum from string
@@ -130,19 +210,38 @@ class GarnetSyntheticTraffic : public ClockedObject
     int injVnet;
     int precision;
 
+    //map<int,routeInfo> outLinks;
+
     const Cycles responseLimit;
 
     MasterID masterId;
 
     void completeRequest(PacketPtr pkt);
 
-    void generatePkt();
+    void generatePkt(int src, unsigned dest, int realsrc, int realdst,string linkName);
+
+    int generateSDNPkt(int src, unsigned dest, routeInfo onePath,string linkName);
+
     void sendPkt(PacketPtr pkt);
     void initTrafficType();
 
     void doRetry();
+    int belongCluster(int routernumber);
+
+    //SDN updated
+    void PrintNetworkState();
+    void PrintAllLinks();
+    void printAllCandidate();
+
+    bool CheckLink(int routerNum, string routerDir);
+    void ReserveLink(int routerNum, string routerDir, string outPort);
+    void ReleaseLink(int routerNum, string routerDir);
+    string outPortCompute(string outPort);
+    void PrintNetwork();
+    void PrintdstMaptaks();
+
 
     friend class MemCompleteEvent;
 };
 
-#endif // __CPU_GARNET_SYNTHETIC_TRAFFIC_HH__
+#endif // __CPU_GARNET_SYNTHETIC_TRAFFIC_HH__
\ No newline at end of file
diff --git a/src/cpu/testers/garnet_synthetic_traffic/GarnetSyntheticTraffic.py b/src/cpu/testers/garnet_synthetic_traffic/GarnetSyntheticTraffic.py
index ba99db4..b9e5ff7 100644
--- a/src/cpu/testers/garnet_synthetic_traffic/GarnetSyntheticTraffic.py
+++ b/src/cpu/testers/garnet_synthetic_traffic/GarnetSyntheticTraffic.py
@@ -30,6 +30,7 @@ from m5.objects.ClockedObject import ClockedObject
 from m5.params import *
 from m5.proxy import *
 
+
 class GarnetSyntheticTraffic(ClockedObject):
     type = 'GarnetSyntheticTraffic'
     cxx_header = \
@@ -55,3 +56,4 @@ class GarnetSyntheticTraffic(ClockedObject):
                                             due to lack of progress")
     test = MasterPort("Port to the memory system to test")
     system = Param.System(Parent.any, "System we belong to")
+    filename = Param.String("h264dl.g","filename for task graph")
diff --git a/src/mem/packet.hh b/src/mem/packet.hh
index 130cc41..e840200 100644
--- a/src/mem/packet.hh
+++ b/src/mem/packet.hh
@@ -259,6 +259,8 @@ class Packet : public Printable
   public:
     typedef uint32_t FlagsType;
     typedef ::Flags<FlagsType> Flags;
+    int realSrc;
+    int realDst;
 
   private:
 
diff --git a/src/mem/packet_queue.cc b/src/mem/packet_queue.cc
index dd1ba3d..6095f3b 100644
--- a/src/mem/packet_queue.cc
+++ b/src/mem/packet_queue.cc
@@ -118,10 +118,11 @@ PacketQueue::schedSendTiming(PacketPtr pkt, Tick when)
 
     // add a very basic sanity check on the port to ensure the
     // invisible buffer is not growing beyond reasonable limits
-    if (!_disableSanityCheck && transmitList.size() > 100) {
-        panic("Packet queue %s has grown beyond 100 packets\n",
-              name());
-    }
+    //Changed here remove buffer check
+    // if (!_disableSanityCheck && transmitList.size() > 1000000) {
+    //     panic("Packet queue %s has grown beyond 1000000 packets\n",
+    //           name());
+    // }
 
     // we should either have an outstanding retry, or a send event
     // scheduled, but there is an unfortunate corner case where the
diff --git a/src/mem/protocol/RubySlicc_Types.sm b/src/mem/protocol/RubySlicc_Types.sm
index 28fb6ef..27a045d 100644
--- a/src/mem/protocol/RubySlicc_Types.sm
+++ b/src/mem/protocol/RubySlicc_Types.sm
@@ -235,6 +235,8 @@ structure (TimerTable, inport="yes", external = "yes") {
 
 structure (AbstractBloomFilter, external = "yes") {
   void clear(int);
+  void increment(Addr, int);
+  void decrement(Addr, int);
   void set(Addr, int);
   void unset(Addr, int);
 
diff --git a/src/mem/ruby/filters/AbstractBloomFilter.hh b/src/mem/ruby/filters/AbstractBloomFilter.hh
index 6a62d0a..097e0e2 100644
--- a/src/mem/ruby/filters/AbstractBloomFilter.hh
+++ b/src/mem/ruby/filters/AbstractBloomFilter.hh
@@ -1,5 +1,4 @@
 /*
- * Copyright (c) 2019 Inria
  * Copyright (c) 1999-2008 Mark D. Hill and David A. Wood
  * All rights reserved.
  *
@@ -25,111 +24,35 @@
  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * Authors: Daniel Carvalho
  */
 
 #ifndef __MEM_RUBY_FILTERS_ABSTRACTBLOOMFILTER_HH__
 #define __MEM_RUBY_FILTERS_ABSTRACTBLOOMFILTER_HH__
 
-#include <vector>
+#include <iostream>
 
-#include "base/intmath.hh"
-#include "base/types.hh"
-#include "params/AbstractBloomFilter.hh"
-#include "sim/sim_object.hh"
+#include "mem/ruby/common/Address.hh"
 
-class AbstractBloomFilter : public SimObject
+class AbstractBloomFilter
 {
-  protected:
-    /** Number of LSB bits to ignore from the the addresses. */
-    const unsigned offsetBits;
-
-    /** The filter itself. */
-    std::vector<int> filter;
-
-    /** Number of bits needed to represent the size of the filter. */
-    const int sizeBits;
-
-    /** Threshold at which a filter entry starts being considered as set. */
-    const int setThreshold;
-
   public:
-    /**
-     * Create and clear the filter.
-     */
-    AbstractBloomFilter(const AbstractBloomFilterParams* p)
-        : SimObject(p), offsetBits(p->offset_bits), filter(p->size),
-          sizeBits(floorLog2(p->size)), setThreshold(p->threshold)
-    {
-        clear();
-    }
     virtual ~AbstractBloomFilter() {};
-
-    /**
-     * Clear the filter by resetting all values.
-     */
-    virtual void clear()
-    {
-        for (auto& entry : filter) {
-            entry = 0;
-        }
-    }
-
-    /** Merges the contents of both filters into this'. */
-    virtual void merge(const AbstractBloomFilter* other) {}
-
-    /**
-     * Perform the filter specific function to set the corresponding
-     * entries (can be multiple) of an address.
-     *
-     * @param addr The address being parsed.
-     */
+    virtual void clear() = 0;
+    virtual void increment(Addr addr) = 0;
+    virtual void decrement(Addr addr) = 0;
+    virtual void merge(AbstractBloomFilter * other_filter) = 0;
     virtual void set(Addr addr) = 0;
+    virtual void unset(Addr addr) = 0;
 
-    /**
-     * Perform the filter specific function to clear the corresponding
-     * entries (can be multiple) of an address. By default a bloom
-     * filter does not support element deletion.
-     *
-     * @param addr The address being parsed.
-     */
-    virtual void unset(Addr addr) {};
-
-    /**
-     * Check if the corresponding filter entries of an address should be
-     * considered as set.
-     *
-     * @param addr The address being parsed.
-     * @return Whether the respective filter entry is set.
-     */
-    virtual bool
-    isSet(Addr addr) const
-    {
-        return getCount(addr) >= setThreshold;
-    }
+    virtual bool isSet(Addr addr) = 0;
+    virtual int getCount(Addr addr) = 0;
+    virtual int getTotalCount() = 0;
 
-    /**
-     * Get the value stored in the corresponding filter entry of an address.
-     *
-     * @param addr The address being parsed.
-     * @param Get the value stored in the respective filter entry.
-     */
-    virtual int getCount(Addr addr) const { return 0; }
+    virtual void print(std::ostream& out) const = 0;
 
-    /**
-     * Get the total value stored in the filter entries.
-     *
-     * @return The sum of all filter entries.
-     */
-    virtual int getTotalCount() const
-    {
-        int count = 0;
-        for (const auto& entry : filter) {
-            count += entry;
-        }
-        return count;
-    }
+    virtual int getIndex(Addr addr) = 0;
+    virtual int readBit(const int index) = 0;
+    virtual void writeBit(const int index, const int value) = 0;
 };
 
 #endif // __MEM_RUBY_FILTERS_ABSTRACTBLOOMFILTER_HH__
diff --git a/src/mem/ruby/filters/BlockBloomFilter.cc b/src/mem/ruby/filters/BlockBloomFilter.cc
index 0718c96..9587fa9 100644
--- a/src/mem/ruby/filters/BlockBloomFilter.cc
+++ b/src/mem/ruby/filters/BlockBloomFilter.cc
@@ -28,12 +28,20 @@
 
 #include "mem/ruby/filters/BlockBloomFilter.hh"
 
-#include "base/bitfield.hh"
-#include "params/BlockBloomFilter.hh"
+#include "base/intmath.hh"
+#include "base/str.hh"
+#include "mem/ruby/system/RubySystem.hh"
 
-BlockBloomFilter::BlockBloomFilter(const BlockBloomFilterParams* p)
-    : AbstractBloomFilter(p)
+using namespace std;
+
+BlockBloomFilter::BlockBloomFilter(int size)
 {
+    m_filter_size = size;
+    m_filter_size_bits = floorLog2(m_filter_size);
+
+    m_filter.resize(m_filter_size);
+
+    clear();
 }
 
 BlockBloomFilter::~BlockBloomFilter()
@@ -41,40 +49,110 @@ BlockBloomFilter::~BlockBloomFilter()
 }
 
 void
+BlockBloomFilter::clear()
+{
+    for (int i = 0; i < m_filter_size; i++) {
+        m_filter[i] = 0;
+    }
+}
+
+void
+BlockBloomFilter::increment(Addr addr)
+{
+    // Not used
+}
+
+void
+BlockBloomFilter::decrement(Addr addr)
+{
+    // Not used
+}
+
+void
+BlockBloomFilter::merge(AbstractBloomFilter * other_filter)
+{
+    // TODO
+}
+
+void
 BlockBloomFilter::set(Addr addr)
 {
-    filter[hash(addr)] = 1;
+    int i = get_index(addr);
+    m_filter[i] = 1;
 }
 
 void
 BlockBloomFilter::unset(Addr addr)
 {
-    filter[hash(addr)] = 0;
+    int i = get_index(addr);
+    m_filter[i] = 0;
+}
+
+bool
+BlockBloomFilter::isSet(Addr addr)
+{
+    int i = get_index(addr);
+    return (m_filter[i]);
+}
+
+int
+BlockBloomFilter::getCount(Addr addr)
+{
+    return m_filter[get_index(addr)];
+}
+
+int
+BlockBloomFilter::getTotalCount()
+{
+    int count = 0;
+
+    for (int i = 0; i < m_filter_size; i++) {
+        if (m_filter[i]) {
+            count++;
+        }
+    }
+    return count;
 }
 
 int
-BlockBloomFilter::getCount(Addr addr) const
+BlockBloomFilter::getIndex(Addr addr)
+{
+    return get_index(addr);
+}
+
+void
+BlockBloomFilter::print(ostream& out) const
 {
-    return filter[hash(addr)];
 }
 
 int
-BlockBloomFilter::hash(Addr addr) const
+BlockBloomFilter::readBit(const int index)
+{
+    return m_filter[index];
+}
+
+void
+BlockBloomFilter::writeBit(const int index, const int value)
+{
+    m_filter[index] = value;
+}
+
+int
+BlockBloomFilter::get_index(Addr addr)
 {
     // Pull out some bit field ==> B1
     // Pull out additional bits, not the same as B1 ==> B2
     //  XOR B1 and B2 to get hash index
-    Addr block_bits = bits(addr, 2 * offsetBits - 1, offsetBits);
+    Addr block_bits = bitSelect(addr, RubySystem::getBlockSizeBits(),
+                       2 * RubySystem::getBlockSizeBits() - 1);
     int offset = 5;
-    Addr other_bits = bits(addr, 2 * offsetBits + offset + sizeBits - 1,
-        2 * offsetBits + offset);
+    Addr other_bits = bitSelect(addr,
+                       2 * RubySystem::getBlockSizeBits() + offset,
+                       2 * RubySystem::getBlockSizeBits() + offset +
+                       m_filter_size_bits - 1);
     int index = block_bits ^ other_bits;
-    assert(index < filter.size());
+    assert(index < m_filter_size);
     return index;
 }
 
-BlockBloomFilter*
-BlockBloomFilterParams::create()
-{
-    return new BlockBloomFilter(this);
-}
+
diff --git a/src/mem/ruby/filters/BlockBloomFilter.hh b/src/mem/ruby/filters/BlockBloomFilter.hh
index c386624..8e6a94f 100644
--- a/src/mem/ruby/filters/BlockBloomFilter.hh
+++ b/src/mem/ruby/filters/BlockBloomFilter.hh
@@ -29,22 +29,40 @@
 #ifndef __MEM_RUBY_FILTERS_BLOCKBLOOMFILTER_HH__
 #define __MEM_RUBY_FILTERS_BLOCKBLOOMFILTER_HH__
 
-#include "mem/ruby/filters/AbstractBloomFilter.hh"
+#include <iostream>
+#include <vector>
 
-struct BlockBloomFilterParams;
+#include "mem/ruby/common/Address.hh"
+#include "mem/ruby/filters/AbstractBloomFilter.hh"
 
 class BlockBloomFilter : public AbstractBloomFilter
 {
   public:
-    BlockBloomFilter(const BlockBloomFilterParams* p);
+    BlockBloomFilter(int size);
     ~BlockBloomFilter();
 
-    void set(Addr addr) override;
-    void unset(Addr addr) override;
-    int getCount(Addr addr) const override;
+    void clear();
+    void increment(Addr addr);
+    void decrement(Addr addr);
+    void merge(AbstractBloomFilter * other_filter);
+    void set(Addr addr);
+    void unset(Addr addr);
+
+    bool isSet(Addr addr);
+    int getCount(Addr addr);
+    int getTotalCount();
+    int getIndex(Addr addr);
+    int readBit(const int index);
+    void writeBit(const int index, const int value);
+
+    void print(std::ostream& out) const;
 
   private:
-    int hash(Addr addr) const;
+    int get_index(Addr addr);
+
+    std::vector<int> m_filter;
+    int m_filter_size;
+    int m_filter_size_bits;
 };
 
 #endif // __MEM_RUBY_FILTERS_BLOCKBLOOMFILTER_HH__
diff --git a/src/mem/ruby/filters/BulkBloomFilter.cc b/src/mem/ruby/filters/BulkBloomFilter.cc
index f2b76aa..3bd2b4d 100644
--- a/src/mem/ruby/filters/BulkBloomFilter.cc
+++ b/src/mem/ruby/filters/BulkBloomFilter.cc
@@ -28,14 +28,29 @@
 
 #include "mem/ruby/filters/BulkBloomFilter.hh"
 
-#include <limits>
+#include <cassert>
 
-#include "base/bitfield.hh"
-#include "params/BulkBloomFilter.hh"
+#include "base/intmath.hh"
+#include "base/str.hh"
+#include "mem/ruby/system/RubySystem.hh"
 
-BulkBloomFilter::BulkBloomFilter(const BulkBloomFilterParams* p)
-    : AbstractBloomFilter(p), sectorBits(sizeBits - 1)
+using namespace std;
+
+BulkBloomFilter::BulkBloomFilter(int size)
 {
+    m_filter_size = size;
+    m_filter_size_bits = floorLog2(m_filter_size);
+    // split the filter bits in half, c0 and c1
+    m_sector_bits = m_filter_size_bits - 1;
+
+    m_temp_filter.resize(m_filter_size);
+    m_filter.resize(m_filter_size);
+    clear();
+
+    // clear temp filter
+    for (int i = 0; i < m_filter_size; ++i) {
+        m_temp_filter[i] = 0;
+    }
 }
 
 BulkBloomFilter::~BulkBloomFilter()
@@ -43,117 +58,191 @@ BulkBloomFilter::~BulkBloomFilter()
 }
 
 void
+BulkBloomFilter::clear()
+{
+    for (int i = 0; i < m_filter_size; i++) {
+        m_filter[i] = 0;
+    }
+}
+
+void
+BulkBloomFilter::increment(Addr addr)
+{
+    // Not used
+}
+
+void
+BulkBloomFilter::decrement(Addr addr)
+{
+    // Not used
+}
+
+void
+BulkBloomFilter::merge(AbstractBloomFilter * other_filter)
+{
+    // TODO
+}
+
+void
 BulkBloomFilter::set(Addr addr)
 {
     // c0 contains the cache index bits
-    int c0 = bits(addr, offsetBits + sectorBits - 1, offsetBits);
-    // c1 contains the lower sectorBits permuted bits
+    int set_bits = m_sector_bits;
+    int block_bits = RubySystem::getBlockSizeBits();
+    int c0 = bitSelect(addr, block_bits, block_bits + set_bits - 1);
+    // c1 contains the lower m_sector_bits permuted bits
     //Address permuted_bits = permute(addr);
-    int c1 = bits(addr, (offsetBits + 2 * sectorBits) - 1,
-        offsetBits + sectorBits);
-    //assert(c0 < (filter_size/2));
-    //assert(c0 + (filter_size/2) < filter_size);
-    //assert(c1 < (filter_size/2));
+    //int c1 = permuted_bits.bitSelect(0, set_bits-1);
+    int c1 = bitSelect(addr, block_bits+set_bits, (block_bits+2*set_bits) - 1);
+    //assert(c0 < (m_filter_size/2));
+    //assert(c0 + (m_filter_size/2) < m_filter_size);
+    //assert(c1 < (m_filter_size/2));
     // set v0 bit
-    filter[c0 + (filter.size()/2)] = 1;
+    m_filter[c0 + (m_filter_size/2)] = 1;
     // set v1 bit
-    filter[c1] = 1;
+    m_filter[c1] = 1;
+}
+
+void
+BulkBloomFilter::unset(Addr addr)
+{
+    // not used
 }
 
 bool
-BulkBloomFilter::isSet(Addr addr) const
+BulkBloomFilter::isSet(Addr addr)
 {
     // c0 contains the cache index bits
-    const int filter_size = filter.size();
-    int c0 = bits(addr, offsetBits + sectorBits - 1, offsetBits);
+    int set_bits = m_sector_bits;
+    int block_bits = RubySystem::getBlockSizeBits();
+    int c0 = bitSelect(addr, block_bits, block_bits + set_bits - 1);
     // c1 contains the lower 10 permuted bits
     //Address permuted_bits = permute(addr);
-    int c1 = bits(addr, (offsetBits + 2 * sectorBits) - 1,
-        offsetBits + sectorBits);
-    //assert(c0 < (filter_size/2));
-    //assert(c0 + (filter_size/2) < filter_size);
-    //assert(c1 < (filter_size/2));
+    //int c1 = permuted_bits.bitSelect(0, set_bits-1);
+    int c1 = bitSelect(addr, block_bits+set_bits, (block_bits+2*set_bits) - 1);
+    //assert(c0 < (m_filter_size/2));
+    //assert(c0 + (m_filter_size/2) < m_filter_size);
+    //assert(c1 < (m_filter_size/2));
     // set v0 bit
-    std::vector<int> temp_filter(filter.size(), 0);
-    temp_filter[c0 + (filter_size/2)] = 1;
+    m_temp_filter[c0 + (m_filter_size/2)] = 1;
     // set v1 bit
-    temp_filter[c1] = 1;
+    m_temp_filter[c1] = 1;
 
     // perform filter intersection. If any c part is 0, no possibility
     // of address being in signature.  get first c intersection part
     bool zero = false;
-    for (int i = 0; i < filter_size/2; ++i){
+    for (int i = 0; i < m_filter_size/2; ++i){
         // get intersection of signatures
-        temp_filter[i] = temp_filter[i] && filter[i];
-        zero = zero || temp_filter[i];
+        m_temp_filter[i] = m_temp_filter[i] && m_filter[i];
+        zero = zero || m_temp_filter[i];
     }
     zero = !zero;
     if (zero) {
         // one section is zero, no possiblility of address in signature
         // reset bits we just set
-        temp_filter[c0 + (filter_size / 2)] = 0;
-        temp_filter[c1] = 0;
+        m_temp_filter[c0 + (m_filter_size / 2)] = 0;
+        m_temp_filter[c1] = 0;
         return false;
     }
 
     // check second section
     zero = false;
-    for (int i = filter_size / 2; i < filter_size; ++i) {
+    for (int i = m_filter_size / 2; i < m_filter_size; ++i) {
         // get intersection of signatures
-        temp_filter[i] =  temp_filter[i] && filter[i];
-        zero = zero || temp_filter[i];
+        m_temp_filter[i] =  m_temp_filter[i] && m_filter[i];
+        zero = zero || m_temp_filter[i];
     }
     zero = !zero;
     if (zero) {
         // one section is zero, no possiblility of address in signature
-        temp_filter[c0 + (filter_size / 2)] = 0;
-        temp_filter[c1] = 0;
+        m_temp_filter[c0 + (m_filter_size / 2)] = 0;
+        m_temp_filter[c1] = 0;
         return false;
     }
     // one section has at least one bit set
-    temp_filter[c0 + (filter_size / 2)] = 0;
-    temp_filter[c1] = 0;
+    m_temp_filter[c0 + (m_filter_size / 2)] = 0;
+    m_temp_filter[c1] = 0;
     return true;
 }
 
 int
-BulkBloomFilter::getCount(Addr addr) const
+BulkBloomFilter::getCount(Addr addr)
+{
+    // not used
+    return 0;
+}
+
+int
+BulkBloomFilter::getTotalCount()
+{
+    int count = 0;
+    for (int i = 0; i < m_filter_size; i++) {
+        if (m_filter[i]) {
+            count++;
+        }
+    }
+    return count;
+}
+
+int
+BulkBloomFilter::getIndex(Addr addr)
+{
+    return get_index(addr);
+}
+
+int
+BulkBloomFilter::readBit(const int index)
 {
-    // TODO as in the multi-hashed filters
     return 0;
+    // TODO
+}
+
+void
+BulkBloomFilter::writeBit(const int index, const int value)
+{
+    // TODO
+}
+
+void
+BulkBloomFilter::print(ostream& out) const
+{
+}
+
+int
+BulkBloomFilter::get_index(Addr addr)
+{
+    return bitSelect(addr, RubySystem::getBlockSizeBits(),
+                     RubySystem::getBlockSizeBits() +
+                     m_filter_size_bits - 1);
 }
 
 Addr
-BulkBloomFilter::hash(Addr addr) const
+BulkBloomFilter::permute(Addr addr)
 {
     // permutes the original address bits according to Table 5
-    Addr part1  = bits(addr, offsetBits + 6, offsetBits),
-         part2  = bits(addr, offsetBits + 9),
-         part3  = bits(addr, offsetBits + 11),
-         part4  = bits(addr, offsetBits + 17),
-         part5  = bits(addr, offsetBits + 8, offsetBits + 7),
-         part6  = bits(addr, offsetBits + 10),
-         part7  = bits(addr, offsetBits + 12),
-         part8  = bits(addr, offsetBits + 13),
-         part9  = bits(addr, offsetBits + 16, offsetBits + 15),
-         part10 = bits(addr, offsetBits + 20, offsetBits + 18),
-         part11 = bits(addr, offsetBits + 14);
+    int block_offset = RubySystem::getBlockSizeBits();
+    Addr part1 = bitSelect(addr, block_offset, block_offset + 6),
+        part2 = bitSelect(addr, block_offset + 9, block_offset + 9),
+        part3 = bitSelect(addr, block_offset + 11, block_offset + 11),
+        part4 = bitSelect(addr, block_offset + 17, block_offset + 17),
+        part5 = bitSelect(addr, block_offset + 7, block_offset + 8),
+        part6 = bitSelect(addr, block_offset + 10, block_offset + 10),
+        part7 = bitSelect(addr, block_offset + 12, block_offset + 12),
+        part8 = bitSelect(addr, block_offset + 13, block_offset + 13),
+        part9 = bitSelect(addr, block_offset + 15, block_offset + 16),
+        part10 = bitSelect(addr, block_offset + 18, block_offset + 20),
+        part11 = bitSelect(addr, block_offset + 14, block_offset + 14);
 
     Addr result =
         (part1 << 14) | (part2 << 13) | (part3 << 12) | (part4 << 11) |
         (part5 << 9)  | (part6 << 8)  | (part7 << 7)  | (part8 << 6)  |
         (part9 << 4)  | (part10 << 1) | (part11);
 
-    // Select the remaining high-order bits
-    Addr remaining_bits = bits(addr, std::numeric_limits<Addr>::digits - 1,
-        offsetBits + 21) << 21;
+    // assume 32 bit addresses (both virtual and physical)
+    // select the remaining high-order 11 bits
+    Addr remaining_bits =
+        bitSelect(addr, block_offset + 21, 31) << 21;
     result = result | remaining_bits;
 
     return result;
 }
-
-BulkBloomFilter*
-BulkBloomFilterParams::create()
-{
-    return new BulkBloomFilter(this);
-}
diff --git a/src/mem/ruby/filters/BulkBloomFilter.hh b/src/mem/ruby/filters/BulkBloomFilter.hh
index 54c976a..059f8b1 100644
--- a/src/mem/ruby/filters/BulkBloomFilter.hh
+++ b/src/mem/ruby/filters/BulkBloomFilter.hh
@@ -29,33 +29,46 @@
 #ifndef __MEM_RUBY_FILTERS_BULKBLOOMFILTER_HH__
 #define __MEM_RUBY_FILTERS_BULKBLOOMFILTER_HH__
 
+#include <iostream>
 #include <vector>
 
+#include "mem/ruby/common/Address.hh"
 #include "mem/ruby/filters/AbstractBloomFilter.hh"
 
-struct BulkBloomFilterParams;
-
-/**
- * Implementation of the bloom filter, as described in "Bulk Disambiguation of
- * Speculative Threads in Multiprocessors", by Ceze, Luis, et al.
- */
 class BulkBloomFilter : public AbstractBloomFilter
 {
   public:
-    BulkBloomFilter(const BulkBloomFilterParams* p);
+    BulkBloomFilter(int size);
     ~BulkBloomFilter();
 
-    void set(Addr addr) override;
+    void clear();
+    void increment(Addr addr);
+    void decrement(Addr addr);
+    void merge(AbstractBloomFilter * other_filter);
+    void set(Addr addr);
+    void unset(Addr addr);
+
+    bool isSet(Addr addr);
+    int getCount(Addr addr);
+    int getTotalCount();
+    int getIndex(Addr addr);
+    int readBit(const int index);
+    void writeBit(const int index, const int value);
 
-    bool isSet(Addr addr) const override;
-    int getCount(Addr addr) const override;
+    void print(std::ostream& out) const;
 
   private:
-    /** Permutes the address to generate its signature. */
-    Addr hash(Addr addr) const;
+    int get_index(Addr addr);
+    Addr permute(Addr addr);
+
+    std::vector<int> m_filter;
+    std::vector<int> m_temp_filter;
+
+    int m_filter_size;
+    int m_filter_size_bits;
+
+    int m_sector_bits;
 
-    // split the filter bits in half, c0 and c1
-    const int sectorBits;
 };
 
 #endif // __MEM_RUBY_FILTERS_BULKBLOOMFILTER_HH__
diff --git a/src/mem/ruby/filters/H3BloomFilter.cc b/src/mem/ruby/filters/H3BloomFilter.cc
index 4e4f95d..71d4c88 100644
--- a/src/mem/ruby/filters/H3BloomFilter.cc
+++ b/src/mem/ruby/filters/H3BloomFilter.cc
@@ -28,11 +28,10 @@
 
 #include "mem/ruby/filters/H3BloomFilter.hh"
 
-#include <limits>
-
+#include "base/intmath.hh"
 #include "base/logging.hh"
-#include "base/bitfield.hh"
-#include "params/H3BloomFilter.hh"
+
+using namespace std;
 
 static int H3[64][16] = {
     { 33268410,   395488709,  311024285,  456111753,
@@ -356,11 +355,41 @@ static int H3[64][16] = {
       394261773,  848616745,  15446017,   517723271,  },
 };
 
-H3BloomFilter::H3BloomFilter(const H3BloomFilterParams* p)
-    : AbstractBloomFilter(p), numHashes(p->num_hashes),
-      isParallel(p->is_parallel), parFilterSize(p->size / numHashes)
+H3BloomFilter::H3BloomFilter(int size, int hashes, bool parallel)
 {
-    fatal_if(numHashes > 16, "There are only 16 hash functions implemented.");
+    //TODO: change this ugly init code...
+    primes_list[0] = 9323;
+    primes_list[1] = 11279;
+    primes_list[2] = 10247;
+    primes_list[3] = 30637;
+    primes_list[4] = 25717;
+    primes_list[5] = 43711;
+
+    mults_list[0] = 255;
+    mults_list[1] = 29;
+    mults_list[2] = 51;
+    mults_list[3] = 3;
+    mults_list[4] = 77;
+    mults_list[5] = 43;
+
+    adds_list[0] = 841;
+    adds_list[1] = 627;
+    adds_list[2] = 1555;
+    adds_list[3] = 241;
+    adds_list[4] = 7777;
+    adds_list[5] = 65931;
+
+    m_filter_size = size;
+    m_num_hashes = hashes;
+    isParallel = parallel;
+
+    m_filter_size_bits = floorLog2(m_filter_size);
+
+    m_par_filter_size = m_filter_size / m_num_hashes;
+    m_par_filter_size_bits = floorLog2(m_par_filter_size);
+
+    m_filter.resize(m_filter_size);
+    clear();
 }
 
 H3BloomFilter::~H3BloomFilter()
@@ -368,48 +397,117 @@ H3BloomFilter::~H3BloomFilter()
 }
 
 void
-H3BloomFilter::merge(const AbstractBloomFilter *other)
+H3BloomFilter::clear()
+{
+    for (int i = 0; i < m_filter_size; i++) {
+        m_filter[i] = 0;
+    }
+}
+
+void
+H3BloomFilter::increment(Addr addr)
+{
+    // Not used
+}
+
+void
+H3BloomFilter::decrement(Addr addr)
+{
+    // Not used
+}
+
+void
+H3BloomFilter::merge(AbstractBloomFilter *other_filter)
 {
-    auto* cast_other = static_cast<const H3BloomFilter*>(other);
-    assert(filter.size() == cast_other->filter.size());
-    for (int i = 0; i < filter.size(); ++i){
-        filter[i] |= cast_other->filter[i];
+    // assumes both filters are the same size!
+    H3BloomFilter * temp = (H3BloomFilter*) other_filter;
+    for (int i = 0; i < m_filter_size; ++i){
+        m_filter[i] |= (*temp)[i];
     }
 }
 
 void
 H3BloomFilter::set(Addr addr)
 {
-    for (int i = 0; i < numHashes; i++) {
-        filter[hash(addr, i)] = 1;
+    for (int i = 0; i < m_num_hashes; i++) {
+        int idx = get_index(addr, i);
+        m_filter[idx] = 1;
+    }
+}
+
+void
+H3BloomFilter::unset(Addr addr)
+{
+    panic("ERROR: Unset should never be called in a Bloom filter");
+}
+
+bool
+H3BloomFilter::isSet(Addr addr)
+{
+    bool res = true;
+
+    for (int i = 0; i < m_num_hashes; i++) {
+        int idx = get_index(addr, i);
+        res = res && m_filter[idx];
     }
+    return res;
 }
 
 int
-H3BloomFilter::getCount(Addr addr) const
+H3BloomFilter::getCount(Addr addr)
+{
+    return isSet(addr)? 1: 0;
+}
+
+int
+H3BloomFilter::getIndex(Addr addr)
+{
+    return 0;
+}
+
+int
+H3BloomFilter::readBit(const int index)
+{
+    return 0;
+}
+
+void
+H3BloomFilter::writeBit(const int index, const int value)
+{
+}
+
+int
+H3BloomFilter::getTotalCount()
 {
     int count = 0;
-    for (int i=0; i < numHashes; i++) {
-        count += filter[hash(addr, i)];
+
+    for (int i = 0; i < m_filter_size; i++) {
+        count += m_filter[i];
     }
     return count;
 }
 
+void
+H3BloomFilter::print(ostream& out) const
+{
+}
+
 int
-H3BloomFilter::hash(Addr addr, int hash_number) const
+H3BloomFilter::get_index(Addr addr, int i)
 {
-    uint64_t x = bits(addr, std::numeric_limits<Addr>::digits - 1, offsetBits);
-    int y = hashH3(x, hash_number);
+    uint64_t x = makeLineAddress(addr);
+    // uint64_t y = (x*mults_list[i] + adds_list[i]) % primes_list[i];
+    int y = hash_H3(x,i);
 
     if (isParallel) {
-        return (y % parFilterSize) + hash_number * parFilterSize;
+        return (y % m_par_filter_size) + i*m_par_filter_size;
     } else {
-        return y % filter.size();
+        return y % m_filter_size;
     }
 }
 
 int
-H3BloomFilter::hashH3(uint64_t value, int index) const
+H3BloomFilter::hash_H3(uint64_t value, int index)
 {
     uint64_t mask = 1;
     uint64_t val = value;
@@ -422,8 +520,3 @@ H3BloomFilter::hashH3(uint64_t value, int index) const
     return result;
 }
 
-H3BloomFilter*
-H3BloomFilterParams::create()
-{
-    return new H3BloomFilter(this);
-}
diff --git a/src/mem/ruby/filters/H3BloomFilter.hh b/src/mem/ruby/filters/H3BloomFilter.hh
index 62a8ec1..443487f 100644
--- a/src/mem/ruby/filters/H3BloomFilter.hh
+++ b/src/mem/ruby/filters/H3BloomFilter.hh
@@ -29,49 +29,58 @@
 #ifndef __MEM_RUBY_FILTERS_H3BLOOMFILTER_HH__
 #define __MEM_RUBY_FILTERS_H3BLOOMFILTER_HH__
 
-#include "mem/ruby/filters/AbstractBloomFilter.hh"
+#include <iostream>
+#include <vector>
 
-struct H3BloomFilterParams;
+#include "mem/ruby/common/Address.hh"
+#include "mem/ruby/filters/AbstractBloomFilter.hh"
 
-/**
- * Implementation of the bloom filter as described in "Implementing Signatures
- * for Transactional Memory", by Sanchez, Daniel, et al.
- */
 class H3BloomFilter : public AbstractBloomFilter
 {
   public:
-    H3BloomFilter(const H3BloomFilterParams* p);
+    H3BloomFilter(int size, int hashes, bool parallel);
     ~H3BloomFilter();
 
-    void merge(const AbstractBloomFilter* other) override;
-    void set(Addr addr) override;
-    int getCount(Addr addr) const override;
+    void clear();
+    void increment(Addr addr);
+    void decrement(Addr addr);
+    void merge(AbstractBloomFilter * other_filter);
+    void set(Addr addr);
+    void unset(Addr addr);
+
+    bool isSet(Addr addr);
+    int getCount(Addr addr);
+    int getTotalCount();
+    void print(std::ostream& out) const;
+
+    int getIndex(Addr addr);
+    int readBit(const int index);
+    void writeBit(const int index, const int value);
+
+    int
+    operator[](const int index) const
+    {
+        return this->m_filter[index];
+    }
 
   private:
-    /**
-     * Apply a hash functions to an address.
-     *
-     * @param addr The address to hash.
-     * @param hash_number Index of the H3 hash function to be used.
-     */
-    int hash(Addr addr, int hash_number) const;
+    int get_index(Addr addr, int hashNumber);
 
-    /**
-     * Apply one of the H3 hash functions to a value.
-     *
-     * @param value The value to hash.
-     * @param hash_number Index of the hash function to be used.
-     */
-    int hashH3(uint64_t value, int hash_number) const;
+    int hash_H3(uint64_t value, int index);
 
-    /** The number of hashes used in this filter. Can be at most 16. */
-    const int numHashes;
+    std::vector<int> m_filter;
+    int m_filter_size;
+    int m_num_hashes;
+    int m_filter_size_bits;
 
-    /** Whether hashing should be performed in parallel. */
-    bool isParallel;
+    int m_par_filter_size;
+    int m_par_filter_size_bits;
 
-    /** Size of the filter when doing parallel hashing. */
-    int parFilterSize;
+    int primes_list[6];// = {9323,11279,10247,30637,25717,43711};
+    int mults_list[6]; //= {255,29,51,3,77,43};
+    int adds_list[6]; //= {841,627,1555,241,7777,65391};
+
+    bool isParallel;
 };
 
 #endif // __MEM_RUBY_FILTERS_H3BLOOMFILTER_HH__
diff --git a/src/mem/ruby/filters/LSB_CountingBloomFilter.cc b/src/mem/ruby/filters/LSB_CountingBloomFilter.cc
index b999a2c..e8050b1 100644
--- a/src/mem/ruby/filters/LSB_CountingBloomFilter.cc
+++ b/src/mem/ruby/filters/LSB_CountingBloomFilter.cc
@@ -28,13 +28,21 @@
 
 #include "mem/ruby/filters/LSB_CountingBloomFilter.hh"
 
-#include "base/bitfield.hh"
-#include "params/LSB_CountingBloomFilter.hh"
+#include "base/intmath.hh"
+#include "mem/ruby/system/RubySystem.hh"
 
-LSB_CountingBloomFilter::LSB_CountingBloomFilter(
-    const LSB_CountingBloomFilterParams* p)
-    : AbstractBloomFilter(p), maxValue(p->max_value)
+using namespace std;
+
+LSB_CountingBloomFilter::LSB_CountingBloomFilter(int head, int tail)
 {
+    m_filter_size = head;
+    m_filter_size_bits = floorLog2(m_filter_size);
+
+    m_count = tail;
+    m_count_bits = floorLog2(m_count);
+
+    m_filter.resize(m_filter_size);
+    clear();
 }
 
 LSB_CountingBloomFilter::~LSB_CountingBloomFilter()
@@ -42,35 +50,102 @@ LSB_CountingBloomFilter::~LSB_CountingBloomFilter()
 }
 
 void
+LSB_CountingBloomFilter::clear()
+{
+    for (int i = 0; i < m_filter_size; i++) {
+        m_filter[i] = 0;
+    }
+}
+
+void
+LSB_CountingBloomFilter::increment(Addr addr)
+{
+    int i = get_index(addr);
+    if (m_filter[i] < m_count)
+        m_filter[i] += 1;
+}
+
+
+void
+LSB_CountingBloomFilter::decrement(Addr addr)
+{
+    int i = get_index(addr);
+    if (m_filter[i] > 0)
+        m_filter[i] -= 1;
+}
+
+void
+LSB_CountingBloomFilter::merge(AbstractBloomFilter * other_filter)
+{
+    // TODO
+}
+
+void
 LSB_CountingBloomFilter::set(Addr addr)
 {
-    const int i = hash(addr);
-    if (filter[i] < maxValue)
-        filter[i] += 1;
+    // TODO
 }
 
 void
 LSB_CountingBloomFilter::unset(Addr addr)
 {
-    const int i = hash(addr);
-    if (filter[i] > 0)
-        filter[i] -= 1;
+    // TODO
+}
+
+bool
+LSB_CountingBloomFilter::isSet(Addr addr)
+{
+    // TODO
+    return false;
+}
+
+int
+LSB_CountingBloomFilter::getCount(Addr addr)
+{
+    return m_filter[get_index(addr)];
 }
 
 int
-LSB_CountingBloomFilter::getCount(Addr addr) const
+LSB_CountingBloomFilter::getTotalCount()
 {
-    return filter[hash(addr)];
+    int count = 0;
+
+    for (int i = 0; i < m_filter_size; i++) {
+        count += m_filter[i];
+    }
+    return count;
 }
 
 int
-LSB_CountingBloomFilter::hash(Addr addr) const
+LSB_CountingBloomFilter::getIndex(Addr addr)
 {
-    return bits(addr, offsetBits + sizeBits - 1, offsetBits);
+    return get_index(addr);
 }
 
-LSB_CountingBloomFilter*
-LSB_CountingBloomFilterParams::create()
+void
+LSB_CountingBloomFilter::print(ostream& out) const
+{
+}
+
+int
+LSB_CountingBloomFilter::readBit(const int index)
 {
-    return new LSB_CountingBloomFilter(this);
+    return 0;
+    // TODO
 }
+
+void
+LSB_CountingBloomFilter::writeBit(const int index, const int value)
+{
+    // TODO
+}
+
+int
+LSB_CountingBloomFilter::get_index(Addr addr)
+{
+    return bitSelect(addr, RubySystem::getBlockSizeBits(),
+                     RubySystem::getBlockSizeBits() +
+                     m_filter_size_bits - 1);
+}
+
+
diff --git a/src/mem/ruby/filters/LSB_CountingBloomFilter.hh b/src/mem/ruby/filters/LSB_CountingBloomFilter.hh
index 4bc0441..05749be 100644
--- a/src/mem/ruby/filters/LSB_CountingBloomFilter.hh
+++ b/src/mem/ruby/filters/LSB_CountingBloomFilter.hh
@@ -29,26 +29,43 @@
 #ifndef __MEM_RUBY_FILTERS_LSB_COUNTINGBLOOMFILTER_HH__
 #define __MEM_RUBY_FILTERS_LSB_COUNTINGBLOOMFILTER_HH__
 
-#include "mem/ruby/filters/AbstractBloomFilter.hh"
+#include <iostream>
+#include <vector>
 
-struct LSB_CountingBloomFilterParams;
+#include "mem/ruby/common/Address.hh"
+#include "mem/ruby/filters/AbstractBloomFilter.hh"
 
 class LSB_CountingBloomFilter : public AbstractBloomFilter
 {
   public:
-    LSB_CountingBloomFilter(const LSB_CountingBloomFilterParams* p);
+    LSB_CountingBloomFilter(int head, int tail);
     ~LSB_CountingBloomFilter();
 
-    void set(Addr addr) override;
-    void unset(Addr addr) override;
+    void clear();
+    void increment(Addr addr);
+    void decrement(Addr addr);
+    void merge(AbstractBloomFilter * other_filter);
+    void set(Addr addr);
+    void unset(Addr addr);
 
-    int getCount(Addr addr) const override;
+    bool isSet(Addr addr);
+    int getCount(Addr addr);
+    int getTotalCount();
+    int getIndex(Addr addr);
+    int readBit(const int index);
+    void writeBit(const int index, const int value);
+
+    void print(std::ostream& out) const;
 
   private:
-    int hash(Addr addr) const;
+    int get_index(Addr addr);
+
+    std::vector<int> m_filter;
+    int m_filter_size;
+    int m_filter_size_bits;
 
-    /** Maximum value of the filter entries. */
-    const int maxValue;
+    int m_count_bits;
+    int m_count;
 };
 
 #endif //__MEM_RUBY_FILTERS_LSB_COUNTINGBLOOMFILTER_HH__
diff --git a/src/mem/ruby/filters/MultiBitSelBloomFilter.cc b/src/mem/ruby/filters/MultiBitSelBloomFilter.cc
index 007de8e..cee28db 100644
--- a/src/mem/ruby/filters/MultiBitSelBloomFilter.cc
+++ b/src/mem/ruby/filters/MultiBitSelBloomFilter.cc
@@ -28,18 +28,23 @@
 
 #include "mem/ruby/filters/MultiBitSelBloomFilter.hh"
 
-#include <limits>
+#include <vector>
 
-#include "base/bitfield.hh"
-#include "params/MultiBitSelBloomFilter.hh"
+#include "base/intmath.hh"
+#include "base/logging.hh"
 
-MultiBitSelBloomFilter::MultiBitSelBloomFilter(
-    const MultiBitSelBloomFilterParams* p)
-    : AbstractBloomFilter(p), numHashes(p->num_hashes),
-      skipBits(p->skip_bits),
-      parFilterSize(p->size / numHashes),
-      isParallel(p->is_parallel)
+using namespace std;
+
+MultiBitSelBloomFilter::MultiBitSelBloomFilter(std::size_t filter_size,
+    int num_hashes, int skip_bits, bool is_parallel)
+    : m_filter_size(filter_size), m_num_hashes(num_hashes),
+      m_filter_size_bits(floorLog2(m_filter_size)), m_skip_bits(skip_bits),
+      m_par_filter_size(m_filter_size / m_num_hashes),
+      m_par_filter_size_bits(floorLog2(m_par_filter_size)),
+      isParallel(is_parallel)
 {
+    m_filter.resize(m_filter_size);
+    clear();
 }
 
 MultiBitSelBloomFilter::~MultiBitSelBloomFilter()
@@ -47,52 +52,122 @@ MultiBitSelBloomFilter::~MultiBitSelBloomFilter()
 }
 
 void
-MultiBitSelBloomFilter::merge(const AbstractBloomFilter *other)
+MultiBitSelBloomFilter::clear()
+{
+    for (int i = 0; i < m_filter_size; i++) {
+        m_filter[i] = 0;
+    }
+}
+
+void
+MultiBitSelBloomFilter::increment(Addr addr)
+{
+    // Not used
+}
+
+
+void
+MultiBitSelBloomFilter::decrement(Addr addr)
+{
+    // Not used
+}
+
+void
+MultiBitSelBloomFilter::merge(AbstractBloomFilter *other_filter)
 {
-    auto cast_other = static_cast<const MultiBitSelBloomFilter*>(other);
-    assert(filter.size() == cast_other->filter.size());
-    for (int i = 0; i < filter.size(); ++i){
-        filter[i] |= cast_other->filter[i];
+    // assumes both filters are the same size!
+    MultiBitSelBloomFilter * temp = (MultiBitSelBloomFilter*) other_filter;
+    for (int i = 0; i < m_filter_size; ++i){
+        m_filter[i] |= (*temp)[i];
     }
 }
 
 void
 MultiBitSelBloomFilter::set(Addr addr)
 {
-    for (int i = 0; i < numHashes; i++) {
-        int idx = hash(addr, i);
-        filter[idx] = 1;
+    for (int i = 0; i < m_num_hashes; i++) {
+        int idx = get_index(addr, i);
+        m_filter[idx] = 1;
+    }
+}
+
+void
+MultiBitSelBloomFilter::unset(Addr addr)
+{
+    panic("ERROR: Unset should never be called in a Bloom filter");
+}
+
+bool
+MultiBitSelBloomFilter::isSet(Addr addr)
+{
+    bool res = true;
+
+    for (int i=0; i < m_num_hashes; i++) {
+        int idx = get_index(addr, i);
+        res = res && m_filter[idx];
     }
+    return res;
 }
 
 int
-MultiBitSelBloomFilter::getCount(Addr addr) const
+MultiBitSelBloomFilter::getCount(Addr addr)
+{
+    return isSet(addr)? 1: 0;
+}
+
+int
+MultiBitSelBloomFilter::getIndex(Addr addr)
+{
+    return 0;
+}
+
+int
+MultiBitSelBloomFilter::readBit(const int index)
+{
+    return 0;
+}
+
+void
+MultiBitSelBloomFilter::writeBit(const int index, const int value)
+{
+}
+
+int
+MultiBitSelBloomFilter::getTotalCount()
 {
     int count = 0;
-    for (int i=0; i < numHashes; i++) {
-        count += filter[hash(addr, i)];
+
+    for (int i = 0; i < m_filter_size; i++) {
+        count += m_filter[i];
     }
     return count;
 }
 
+void
+MultiBitSelBloomFilter::print(ostream& out) const
+{
+}
+
 int
-MultiBitSelBloomFilter::hash(Addr addr, int hash_number) const
+MultiBitSelBloomFilter::get_index(Addr addr, int i)
 {
-    uint64_t x = bits(addr, std::numeric_limits<Addr>::digits - 1,
-        offsetBits) >> skipBits;
-    int y = hashBitsel(x, hash_number, numHashes, 30, sizeBits);
+    // m_skip_bits is used to perform BitSelect after skipping some
+    // bits. Used to simulate BitSel hashing on larger than cache-line
+    // granularities
+    uint64_t x = (makeLineAddress(addr) >> m_skip_bits);
+    int y = hash_bitsel(x, i, m_num_hashes, 30, m_filter_size_bits);
     //36-bit addresses, 6-bit cache lines
 
     if (isParallel) {
-        return (y % parFilterSize) + hash_number * parFilterSize;
+        return (y % m_par_filter_size) + i*m_par_filter_size;
     } else {
-        return y % filter.size();
+        return y % m_filter_size;
     }
 }
 
 int
-MultiBitSelBloomFilter::hashBitsel(uint64_t value, int index, int jump,
-                                    int maxBits, int numBits) const
+MultiBitSelBloomFilter::hash_bitsel(uint64_t value, int index, int jump,
+                                    int maxBits, int numBits)
 {
     uint64_t mask = 1;
     int result = 0;
@@ -104,9 +179,3 @@ MultiBitSelBloomFilter::hashBitsel(uint64_t value, int index, int jump,
     }
     return result;
 }
-
-MultiBitSelBloomFilter*
-MultiBitSelBloomFilterParams::create()
-{
-    return new MultiBitSelBloomFilter(this);
-}
diff --git a/src/mem/ruby/filters/MultiBitSelBloomFilter.hh b/src/mem/ruby/filters/MultiBitSelBloomFilter.hh
index 501483d..23d970a 100644
--- a/src/mem/ruby/filters/MultiBitSelBloomFilter.hh
+++ b/src/mem/ruby/filters/MultiBitSelBloomFilter.hh
@@ -29,40 +29,59 @@
 #ifndef __MEM_RUBY_FILTERS_MULTIBITSELBLOOMFILTER_HH__
 #define __MEM_RUBY_FILTERS_MULTIBITSELBLOOMFILTER_HH__
 
-#include "mem/ruby/filters/AbstractBloomFilter.hh"
+#include <iostream>
+#include <vector>
 
-struct MultiBitSelBloomFilterParams;
+#include "mem/ruby/common/Address.hh"
+#include "mem/ruby/common/TypeDefines.hh"
+#include "mem/ruby/filters/AbstractBloomFilter.hh"
 
 class MultiBitSelBloomFilter : public AbstractBloomFilter
 {
   public:
-    MultiBitSelBloomFilter(const MultiBitSelBloomFilterParams* p);
+    MultiBitSelBloomFilter(std::size_t filter_size, int num_hashes,
+                           int skip_bits, bool is_parallel);
     ~MultiBitSelBloomFilter();
 
-    void merge(const AbstractBloomFilter* other) override;
-    void set(Addr addr) override;
-    int getCount(Addr addr) const override;
+    void clear();
+    void increment(Addr addr);
+    void decrement(Addr addr);
+    void merge(AbstractBloomFilter * other_filter);
+    void set(Addr addr);
+    void unset(Addr addr);
 
-  private:
-    int hash(Addr addr, int hash_number) const;
+    bool isSet(Addr addr);
+    int getCount(Addr addr);
+    int getTotalCount();
+    void print(std::ostream& out) const;
 
-    int hashBitsel(uint64_t value, int index, int jump, int maxBits,
-                    int numBits) const;
+    int getIndex(Addr addr);
+    int readBit(const int index);
+    void writeBit(const int index, const int value);
+
+    int
+    operator[](const int index) const
+    {
+        return this->m_filter[index];
+    }
+
+  private:
+    int get_index(Addr addr, int hashNumber);
 
-    /** Number of hashes. */
-    const int numHashes;
+    int hash_bitsel(uint64_t value, int index, int jump, int maxBits,
+                    int numBits);
 
-    /**
-     * Bit offset from block number. Used to simulate bit selection hashing
-     * on larger than cache-line granularities, by skipping some bits.
-     */
-    const int skipBits;
+    std::vector<int> m_filter;
+    int m_filter_size;
+    int m_num_hashes;
+    int m_filter_size_bits;
+    // Bit offset from block number
+    int m_skip_bits;
 
-    /** Size of the filter when doing parallel hashing. */
-    const int parFilterSize;
+    int m_par_filter_size;
+    int m_par_filter_size_bits;
 
-    /** Whether hashing should be performed in parallel. */
-    const bool isParallel;
+    bool isParallel;
 };
 
 #endif // __MEM_RUBY_FILTERS_MULTIBITSELBLOOMFILTER_HH__
diff --git a/src/mem/ruby/filters/MultiGrainBloomFilter.cc b/src/mem/ruby/filters/MultiGrainBloomFilter.cc
index 150e0a5..c1d558c 100644
--- a/src/mem/ruby/filters/MultiGrainBloomFilter.cc
+++ b/src/mem/ruby/filters/MultiGrainBloomFilter.cc
@@ -28,14 +28,25 @@
 
 #include "mem/ruby/filters/MultiGrainBloomFilter.hh"
 
-#include "base/bitfield.hh"
-#include "params/MultiGrainBloomFilter.hh"
+#include "base/intmath.hh"
+#include "base/str.hh"
+#include "mem/ruby/system/RubySystem.hh"
 
-MultiGrainBloomFilter::MultiGrainBloomFilter(
-    const MultiGrainBloomFilterParams* p)
-    : AbstractBloomFilter(p), pageFilter(p->page_filter_size),
-      pageFilterSizeBits(floorLog2(p->page_filter_size))
+using namespace std;
+
+MultiGrainBloomFilter::MultiGrainBloomFilter(int head, int tail)
 {
+    // head contains size of 1st bloom filter, tail contains size of
+    // 2nd bloom filter
+    m_filter_size = head;
+    m_filter_size_bits = floorLog2(m_filter_size);
+
+    m_page_filter_size = tail;
+    m_page_filter_size_bits = floorLog2(m_page_filter_size);
+
+    m_filter.resize(m_filter_size);
+    m_page_filter.resize(m_page_filter_size);
+    clear();
 }
 
 MultiGrainBloomFilter::~MultiGrainBloomFilter()
@@ -45,64 +56,126 @@ MultiGrainBloomFilter::~MultiGrainBloomFilter()
 void
 MultiGrainBloomFilter::clear()
 {
-    AbstractBloomFilter::clear();
-    for (auto& entry : pageFilter){
-        entry = 0;
+    for (int i = 0; i < m_filter_size; i++) {
+        m_filter[i] = 0;
     }
+    for (int i=0; i < m_page_filter_size; ++i){
+        m_page_filter[i] = 0;
+    }
+}
+
+void
+MultiGrainBloomFilter::increment(Addr addr)
+{
+    // Not used
+}
+
+
+void
+MultiGrainBloomFilter::decrement(Addr addr)
+{
+    // Not used
+}
+
+void
+MultiGrainBloomFilter::merge(AbstractBloomFilter *other_filter)
+{
+    // TODO
 }
 
 void
 MultiGrainBloomFilter::set(Addr addr)
 {
-    const int index = hash(addr);
-    assert(index < filter.size());
-    filter[index] = 1;
+    int i = get_block_index(addr);
+    assert(i < m_filter_size);
+    assert(get_page_index(addr) < m_page_filter_size);
+    m_filter[i] = 1;
+    m_page_filter[i] = 1;
+
+}
+
+void
+MultiGrainBloomFilter::unset(Addr addr)
+{
+    // not used
+}
 
-    const int page_index = pageHash(addr);
-    assert(page_index < pageFilter.size());
-    pageFilter[page_index] = 1;
+bool
+MultiGrainBloomFilter::isSet(Addr addr)
+{
+    int i = get_block_index(addr);
+    assert(i < m_filter_size);
+    assert(get_page_index(addr) < m_page_filter_size);
+    // we have to have both indices set
+    return (m_filter[i] && m_page_filter[i]);
 }
 
 int
-MultiGrainBloomFilter::getCount(Addr addr) const
+MultiGrainBloomFilter::getCount(Addr addr)
 {
-    const int index = hash(addr);
-    const int page_index = pageHash(addr);
-    assert(index < filter.size());
-    assert(page_index < pageFilter.size());
-    return filter[index] + pageFilter[page_index];
+    // not used
+    return 0;
 }
 
 int
-MultiGrainBloomFilter::getTotalCount() const
+MultiGrainBloomFilter::getTotalCount()
 {
-    int count = AbstractBloomFilter::getTotalCount();
+    int count = 0;
 
-    for (const auto& entry : pageFilter) {
-        count += entry;
+    for (int i = 0; i < m_filter_size; i++) {
+        count += m_filter[i];
+    }
+
+    for (int i=0; i < m_page_filter_size; ++i) {
+        count += m_page_filter[i] = 0;
     }
 
     return count;
 }
 
 int
-MultiGrainBloomFilter::hash(Addr addr) const
+MultiGrainBloomFilter::getIndex(Addr addr)
 {
-    // grap a chunk of bits after byte offset
-    return bits(addr, offsetBits + sizeBits - 1, offsetBits);
+    return 0;
+    // TODO
 }
 
 int
-MultiGrainBloomFilter::pageHash(Addr addr) const
+MultiGrainBloomFilter::readBit(const int index)
 {
-    int num_bits = offsetBits + sizeBits - 1;
+    return 0;
+    // TODO
+}
 
-    // grap a chunk of bits after first chunk
-    return bits(addr, num_bits + pageFilterSizeBits - 1, num_bits);
+void
+MultiGrainBloomFilter::writeBit(const int index, const int value)
+{
+    // TODO
 }
 
-MultiGrainBloomFilter*
-MultiGrainBloomFilterParams::create()
+void
+MultiGrainBloomFilter::print(ostream& out) const
 {
-    return new MultiGrainBloomFilter(this);
 }
+
+int
+MultiGrainBloomFilter::get_block_index(Addr addr)
+{
+    // grap a chunk of bits after byte offset
+    return bitSelect(addr, RubySystem::getBlockSizeBits(),
+                     RubySystem::getBlockSizeBits() +
+                     m_filter_size_bits - 1);
+}
+
+int
+MultiGrainBloomFilter::get_page_index(Addr addr)
+{
+    int bits = RubySystem::getBlockSizeBits() + m_filter_size_bits - 1;
+
+    // grap a chunk of bits after first chunk
+    return bitSelect(addr, bits, bits + m_page_filter_size_bits - 1);
+}
+
+
+
+
diff --git a/src/mem/ruby/filters/MultiGrainBloomFilter.hh b/src/mem/ruby/filters/MultiGrainBloomFilter.hh
index e895788..e4c8395 100644
--- a/src/mem/ruby/filters/MultiGrainBloomFilter.hh
+++ b/src/mem/ruby/filters/MultiGrainBloomFilter.hh
@@ -29,32 +29,46 @@
 #ifndef __MEM_RUBY_FILTERS_MULTIGRAINBLOOMFILTER_HH__
 #define __MEM_RUBY_FILTERS_MULTIGRAINBLOOMFILTER_HH__
 
+#include <iostream>
 #include <vector>
 
+#include "mem/ruby/common/Address.hh"
 #include "mem/ruby/filters/AbstractBloomFilter.hh"
 
-struct MultiGrainBloomFilterParams;
-
 class MultiGrainBloomFilter : public AbstractBloomFilter
 {
   public:
-    MultiGrainBloomFilter(const MultiGrainBloomFilterParams* p);
+    MultiGrainBloomFilter(int head, int tail);
     ~MultiGrainBloomFilter();
 
-    void clear() override;
-    void set(Addr addr) override;
+    void clear();
+    void increment(Addr addr);
+    void decrement(Addr addr);
+    void merge(AbstractBloomFilter * other_filter);
+    void set(Addr addr);
+    void unset(Addr addr);
+
+    bool isSet(Addr addr);
+    int getCount(Addr addr);
+    int getTotalCount();
+    int getIndex(Addr addr);
+    int readBit(const int index);
+    void writeBit(const int index, const int value);
 
-    int getCount(Addr addr) const override;
-    int getTotalCount() const override;
+    void print(std::ostream& out) const;
 
   private:
-    int hash(Addr addr) const;
-    int pageHash(Addr addr) const;
+    int get_block_index(Addr addr);
+    int get_page_index(Addr addr);
 
-    // The block filter uses the filter vector declared in the base class
-    /** The page number filter. */
-    std::vector<int> pageFilter;
-    int pageFilterSizeBits;
+    // The block filter
+    std::vector<int> m_filter;
+    int m_filter_size;
+    int m_filter_size_bits;
+    // The page number filter
+    std::vector<int> m_page_filter;
+    int m_page_filter_size;
+    int m_page_filter_size_bits;
 };
 
 #endif // __MEM_RUBY_FILTERS_MULTIGRAINBLOOMFILTER_HH__
diff --git a/src/mem/ruby/filters/NonCountingBloomFilter.cc b/src/mem/ruby/filters/NonCountingBloomFilter.cc
index 6fd39a0..15b1697 100644
--- a/src/mem/ruby/filters/NonCountingBloomFilter.cc
+++ b/src/mem/ruby/filters/NonCountingBloomFilter.cc
@@ -28,13 +28,21 @@
 
 #include "mem/ruby/filters/NonCountingBloomFilter.hh"
 
-#include "base/bitfield.hh"
-#include "params/NonCountingBloomFilter.hh"
+#include "base/intmath.hh"
+#include "base/str.hh"
+#include "mem/ruby/system/RubySystem.hh"
 
-NonCountingBloomFilter::NonCountingBloomFilter(
-    const NonCountingBloomFilterParams* p)
-    : AbstractBloomFilter(p), skipBits(p->skip_bits)
+using namespace std;
+
+NonCountingBloomFilter::NonCountingBloomFilter(int head, int tail)
 {
+    // head contains filter size, tail contains bit offset from block number
+    m_filter_size = head;
+    m_offset = tail;
+    m_filter_size_bits = floorLog2(m_filter_size);
+
+    m_filter.resize(m_filter_size);
+    clear();
 }
 
 NonCountingBloomFilter::~NonCountingBloomFilter()
@@ -42,41 +50,103 @@ NonCountingBloomFilter::~NonCountingBloomFilter()
 }
 
 void
-NonCountingBloomFilter::merge(const AbstractBloomFilter *other)
+NonCountingBloomFilter::clear()
+{
+    for (int i = 0; i < m_filter_size; i++) {
+        m_filter[i] = 0;
+    }
+}
+
+void
+NonCountingBloomFilter::increment(Addr addr)
+{
+    // Not used
+}
+
+void
+NonCountingBloomFilter::decrement(Addr addr)
+{
+    // Not used
+}
+
+void
+NonCountingBloomFilter::merge(AbstractBloomFilter *other_filter)
 {
-    auto* cast_other = static_cast<const NonCountingBloomFilter*>(other);
-    assert(filter.size() == cast_other->filter.size());
-    for (int i = 0; i < filter.size(); ++i){
-        filter[i] |= cast_other->filter[i];
+    // assumes both filters are the same size!
+    NonCountingBloomFilter * temp = (NonCountingBloomFilter*) other_filter;
+    for (int i = 0; i < m_filter_size; ++i){
+        m_filter[i] |= (*temp)[i];
     }
 }
 
 void
 NonCountingBloomFilter::set(Addr addr)
 {
-    filter[hash(addr)] = 1;
+    int i = get_index(addr);
+    m_filter[i] = 1;
 }
 
 void
 NonCountingBloomFilter::unset(Addr addr)
 {
-    filter[hash(addr)] = 0;
+    int i = get_index(addr);
+    m_filter[i] = 0;
+}
+
+bool
+NonCountingBloomFilter::isSet(Addr addr)
+{
+    int i = get_index(addr);
+    return (m_filter[i]);
+}
+
+
+int
+NonCountingBloomFilter::getCount(Addr addr)
+{
+    return m_filter[get_index(addr)];
+}
+
+int
+NonCountingBloomFilter::getTotalCount()
+{
+    int count = 0;
+
+    for (int i = 0; i < m_filter_size; i++) {
+        count += m_filter[i];
+    }
+    return count;
+}
+
+void
+NonCountingBloomFilter::print(ostream& out) const
+{
 }
 
 int
-NonCountingBloomFilter::getCount(Addr addr) const
+NonCountingBloomFilter::getIndex(Addr addr)
 {
-    return filter[hash(addr)];
+    return get_index(addr);
 }
 
 int
-NonCountingBloomFilter::hash(Addr addr) const
+NonCountingBloomFilter::readBit(const int index)
+{
+    return m_filter[index];
+}
+
+void
+NonCountingBloomFilter::writeBit(const int index, const int value)
 {
-    return bits(addr, offsetBits + skipBits + sizeBits - 1, offsetBits + skipBits);
+    m_filter[index] = value;
 }
 
-NonCountingBloomFilter*
-NonCountingBloomFilterParams::create()
+int
+NonCountingBloomFilter::get_index(Addr addr)
 {
-    return new NonCountingBloomFilter(this);
+    return bitSelect(addr, RubySystem::getBlockSizeBits() + m_offset,
+                     RubySystem::getBlockSizeBits() + m_offset +
+                     m_filter_size_bits - 1);
 }
+
+
diff --git a/src/mem/ruby/filters/NonCountingBloomFilter.hh b/src/mem/ruby/filters/NonCountingBloomFilter.hh
index 614fee0..b0599e7 100644
--- a/src/mem/ruby/filters/NonCountingBloomFilter.hh
+++ b/src/mem/ruby/filters/NonCountingBloomFilter.hh
@@ -29,30 +29,48 @@
 #ifndef __MEM_RUBY_FILTERS_NONCOUNTINGBLOOMFILTER_HH__
 #define __MEM_RUBY_FILTERS_NONCOUNTINGBLOOMFILTER_HH__
 
-#include "mem/ruby/filters/AbstractBloomFilter.hh"
+#include <iostream>
+#include <vector>
 
-struct NonCountingBloomFilterParams;
+#include "mem/ruby/common/Address.hh"
+#include "mem/ruby/filters/AbstractBloomFilter.hh"
 
 class NonCountingBloomFilter : public AbstractBloomFilter
 {
   public:
-    NonCountingBloomFilter(const NonCountingBloomFilterParams* p);
+    NonCountingBloomFilter(int head, int tail);
     ~NonCountingBloomFilter();
 
-    void merge(const AbstractBloomFilter* other) override;
-    void set(Addr addr) override;
-    void unset(Addr addr) override;
+    void clear();
+    void increment(Addr addr);
+    void decrement(Addr addr);
+    void merge(AbstractBloomFilter * other_filter);
+    void set(Addr addr);
+    void unset(Addr addr);
+
+    bool isSet(Addr addr);
+    int getCount(Addr addr);
+    int getTotalCount();
+
+    int getIndex(Addr addr);
+    int readBit(const int index);
+    void writeBit(const int index, const int value);
+
+    void print(std::ostream& out) const;
 
-    int getCount(Addr addr) const override;
+    int
+    operator[](const int index) const
+    {
+        return this->m_filter[index];
+    }
 
   private:
-    int hash(Addr addr) const;
+    int get_index(Addr addr);
 
-    /**
-     * Bit offset from block number. Used to simulate bit selection hashing
-     * on larger than cache-line granularities, by skipping some bits.
-     */
-    int skipBits;
+    std::vector<int> m_filter;
+    int m_filter_size;
+    int m_offset;
+    int m_filter_size_bits;
 };
 
 #endif // __MEM_RUBY_FILTERS_NONCOUNTINGBLOOMFILTER_HH__
diff --git a/src/mem/ruby/filters/SConscript b/src/mem/ruby/filters/SConscript
index 13ecc5e..5b7e583 100644
--- a/src/mem/ruby/filters/SConscript
+++ b/src/mem/ruby/filters/SConscript
@@ -33,8 +33,6 @@ Import('*')
 if env['PROTOCOL'] == 'None':
     Return()
 
-SimObject('BloomFilters.py')
-
 Source('BlockBloomFilter.cc')
 Source('BulkBloomFilter.cc')
 Source('H3BloomFilter.cc')
diff --git a/src/mem/ruby/network/MessageBuffer.cc b/src/mem/ruby/network/MessageBuffer.cc
index 03d1bb0..86be5fa 100644
--- a/src/mem/ruby/network/MessageBuffer.cc
+++ b/src/mem/ruby/network/MessageBuffer.cc
@@ -147,7 +147,7 @@ MessageBuffer::enqueue(MsgPtr message, Tick current_time, Tick delta)
         m_msgs_this_cycle = 0;  // first msg this cycle
         m_time_last_time_enqueue = current_time;
     }
-
+   
     m_msg_counter++;
     m_msgs_this_cycle++;
 
diff --git a/src/mem/ruby/network/MessageBuffer.hh b/src/mem/ruby/network/MessageBuffer.hh
index 05821d5..8e161e5 100644
--- a/src/mem/ruby/network/MessageBuffer.hh
+++ b/src/mem/ruby/network/MessageBuffer.hh
@@ -72,6 +72,7 @@ class MessageBuffer : public SimObject
         std::pop_heap(m_prio_heap.begin(), m_prio_heap.end(),
                       std::greater<MsgPtr>());
         m_prio_heap.pop_back();
+        std::cout<<"message buffer"<<std::endl;
         enqueue(m, current_time, delta);
     }
 
diff --git a/src/mem/ruby/network/Network.py b/src/mem/ruby/network/Network.py
index 861fd79..18dcd55 100644
--- a/src/mem/ruby/network/Network.py
+++ b/src/mem/ruby/network/Network.py
@@ -39,7 +39,7 @@ class RubyNetwork(ClockedObject):
     topology = Param.String("Not Specified",
                             "the name of the imported topology module")
 
-    number_of_virtual_networks = Param.Unsigned("Number of virtual networks "
+    number_of_virtual_networks = Param.Unsigned(1,"Number of virtual networks "
            "used by the coherence protocol in use.  The on-chip network "
            "assumes the protocol numbers vnets starting from 0.  Therefore, "
            "the number of virtual networks should be one more than the "
diff --git a/src/mem/ruby/network/garnet2.0/CommonTypes.hh b/src/mem/ruby/network/garnet2.0/CommonTypes.hh
index 3a8c84a..1dfd0c1 100644
--- a/src/mem/ruby/network/garnet2.0/CommonTypes.hh
+++ b/src/mem/ruby/network/garnet2.0/CommonTypes.hh
@@ -35,6 +35,7 @@
 #define __MEM_RUBY_NETWORK_GARNET2_0_COMMONTYPES_HH__
 
 #include "mem/ruby/common/NetDest.hh"
+#include "mem/ruby/network/Network.hh"
 
 // All common enums and typedefs go here
 
@@ -58,8 +59,13 @@ struct RouteInfo
     int dest_ni;
     int dest_router;
     int hops_traversed;
+    int x_hops_remaining;
+    int y_hops_remaining;
+    PortDirection outport_dirn;
+    int smart_hops_traversed;
 };
 
+
 #define INFINITE_ 10000
 
 #endif //__MEM_RUBY_NETWORK_GARNET2_0_COMMONTYPES_HH__
diff --git a/src/mem/ruby/network/garnet2.0/CreditLink.cc b/src/mem/ruby/network/garnet2.0/CreditLink.cc
new file mode 100644
index 0000000..0a84630
--- /dev/null
+++ b/src/mem/ruby/network/garnet2.0/CreditLink.cc
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2008 Princeton University
+ * Copyright (c) 2016 Georgia Institute of Technology
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Authors: Niket Agarwal
+ *          Tushar Krishna
+ */
+
+
+#include "mem/ruby/network/garnet2.0/CreditLink.hh"
+
+#include "mem/ruby/network/garnet2.0/NetworkLink.hh"
+
+/*
+CreditLink::CreditLink(const Params *p)
+    : ClockedObject(p), Consumer(this), m_id(p->link_id),
+      m_type(NUM_LINK_TYPES_),
+      m_latency(p->link_latency),
+      linkBuffer(new flitBuffer()), link_consumer(nullptr),
+      link_srcQueue(nullptr), m_link_utilized(0),
+      m_vc_load(p->vcs_per_vnet * p->virt_nets)
+{
+}
+
+*/
+CreditLink::~CreditLink()
+{
+    delete linkBuffer;
+}
+
+
+void
+CreditLink::wakeup()
+{
+    // SMART can send 2 credits in the same cycle
+    // One from SA-L.
+    // One during bypass.
+    // Hence while loop
+    //std::cout<<"creditLink.cc wake up +++++++++++++++++"<<std::endl;
+    while (link_srcQueue->isReady(curCycle())) {
+        flit *t_flit = link_srcQueue->getTopFlit();
+        t_flit->set_time(curCycle() + m_latency);
+        linkBuffer->insert(t_flit);
+        link_consumer->scheduleEventAbsolute(clockEdge(m_latency));
+        m_link_utilized++;
+        m_vc_load[t_flit->get_vc()]++;
+    }
+}
diff --git a/src/mem/ruby/network/garnet2.0/CreditLink.hh b/src/mem/ruby/network/garnet2.0/CreditLink.hh
index 8d6da67..4daff5a 100644
--- a/src/mem/ruby/network/garnet2.0/CreditLink.hh
+++ b/src/mem/ruby/network/garnet2.0/CreditLink.hh
@@ -42,6 +42,8 @@ class CreditLink : public NetworkLink
   public:
     typedef CreditLinkParams Params;
     CreditLink(const Params *p) : NetworkLink(p) {}
+    ~CreditLink();
+    void wakeup();
 };
 
 #endif // __MEM_RUBY_NETWORK_GARNET2_0_CREDITLINK_HH__
diff --git a/src/mem/ruby/network/garnet2.0/CrossbarSwitch.cc b/src/mem/ruby/network/garnet2.0/CrossbarSwitch.cc
index fbaf25b..02d0f3c 100644
--- a/src/mem/ruby/network/garnet2.0/CrossbarSwitch.cc
+++ b/src/mem/ruby/network/garnet2.0/CrossbarSwitch.cc
@@ -82,9 +82,16 @@ CrossbarSwitch::wakeup()
         if (!m_switch_buffer[inport]->isReady(m_router->curCycle()))
             continue;
 
-        flit *t_flit = m_switch_buffer[inport]->peekTopFlit();
+       flit *t_flit = m_switch_buffer[inport]->peekTopFlit();
         if (t_flit->is_stage(ST_, m_router->curCycle())) {
             int outport = t_flit->get_outport();
+            //std::cout<<"Crossbar Switch at Router "<<m_router->get_id()<<" input port: "<<inport<<" out port:"<<outport<<m_router->getPortDirectionName(m_output_unit[outport]->get_direction())<<" Cycle "<<m_router->curCycle()<<std::endl;
+
+
+            DPRINTF(RubyNetwork, "Crossbar Switch at Router %d sending flit %s from outport %d at time: %lld\n",
+                    m_router->get_id(), *t_flit, m_router->getPortDirectionName(m_output_unit[outport]->get_direction()),
+                    m_router->curCycle());
+
 
             // flit performs LT_ in the next cycle
             t_flit->advance_stage(LT_, m_router->curCycle() + Cycles(1));
@@ -95,6 +102,13 @@ CrossbarSwitch::wakeup()
             m_output_unit[outport]->insert_flit(t_flit);
             m_switch_buffer[inport]->getTopFlit();
             m_crossbar_activity++;
+
+            // Increment hops SMART hops
+            // except when this is destination router
+            if (t_flit->get_route()->dest_router != m_router->get_id()) {
+                t_flit->increment_hops();
+                t_flit->increment_smart_hops();
+            }
         }
     }
 }
diff --git a/src/mem/ruby/network/garnet2.0/GarnetNetwork.cc b/src/mem/ruby/network/garnet2.0/GarnetNetwork.cc
index 5fa7644..68f8a23 100644
--- a/src/mem/ruby/network/garnet2.0/GarnetNetwork.cc
+++ b/src/mem/ruby/network/garnet2.0/GarnetNetwork.cc
@@ -30,11 +30,8 @@
  *          Tushar Krishna
  */
 
-
 #include "mem/ruby/network/garnet2.0/GarnetNetwork.hh"
 
-#include <cassert>
-
 #include "base/cast.hh"
 #include "base/stl_helpers.hh"
 #include "mem/ruby/common/NetDest.hh"
@@ -45,31 +42,52 @@
 #include "mem/ruby/network/garnet2.0/NetworkInterface.hh"
 #include "mem/ruby/network/garnet2.0/NetworkLink.hh"
 #include "mem/ruby/network/garnet2.0/Router.hh"
+#include "mem/ruby/network/garnet2.0/SSR.hh"
 #include "mem/ruby/system/RubySystem.hh"
 
 using namespace std;
 using m5::stl_helpers::deletePointers;
 
+int routing_algorithm;
+
 /*
  * GarnetNetwork sets up the routers and links and collects stats.
  * Default parameters (GarnetNetwork.py) can be overwritten from command line
  * (see configs/network/Network.py)
  */
-
+std::string graph_file;
+int hpcMax;
+int rowNum;
 GarnetNetwork::GarnetNetwork(const Params *p)
     : Network(p)
 {
     m_num_rows = p->num_rows;
+    rowNum = m_num_rows;
+    
     m_ni_flit_size = p->ni_flit_size;
     m_vcs_per_vnet = p->vcs_per_vnet;
     m_buffers_per_data_vc = p->buffers_per_data_vc;
     m_buffers_per_ctrl_vc = p->buffers_per_ctrl_vc;
     m_routing_algorithm = p->routing_algorithm;
 
+    m_enable_smart = p->enable_smart;
+    m_enable_smart2D = p->enable_smart2D;
+    m_enable_central = p->enable_central;
+
+    isSDNoC = p->enable_central;
+    configureTime = p->configure_time;
+    
+    m_single_flit = p->enable_single_flit;
+    m_smart_hpcmax = p->smart_hpcmax;
+    m_smart_dest_bypass = p->smart_dest_bypass;
+    graph_file = p->filename;
+    hpcMax = m_smart_hpcmax;
+    //std::cout<<graph_file<<endl;
+
     m_enable_fault_model = p->enable_fault_model;
     if (m_enable_fault_model)
         fault_model = p->fault_model;
-
+    routing_algorithm = m_routing_algorithm;
     m_vnet_type.resize(m_virtual_networks);
 
     for (int i = 0 ; i < m_virtual_networks ; i++) {
@@ -141,6 +159,8 @@ GarnetNetwork::init()
             router->printFaultVector(cout);
         }
     }
+    // schedule wakeup for the 0 router
+    m_routers[0]->schedule_wakeup(Cycles(0));
 }
 
 GarnetNetwork::~GarnetNetwork()
@@ -235,6 +255,7 @@ GarnetNetwork::makeInternalLink(SwitchID src, SwitchID dest, BasicLink* link,
     m_routers[src]->addOutPort(src_outport_dirn, net_link,
                                routing_table_entry,
                                link->m_weight, credit_link);
+    
 }
 
 // Total routers in the network
@@ -250,7 +271,11 @@ GarnetNetwork::get_router_id(int ni)
 {
     return m_nis[ni]->get_router_id();
 }
-
+void
+GarnetNetwork::wakeupRouter(int m_id)
+{
+        m_routers[m_id]->schedule_wakeup(Cycles(0));
+    };
 void
 GarnetNetwork::regStats()
 {
@@ -294,6 +319,8 @@ GarnetNetwork::regStats()
     m_avg_packet_vnet_latency =
         m_packet_network_latency / m_packets_received;
 
+    //DPRINTF(GarnetSyntheticTraffic,"+++++++++++++%d\n",m_packets_received);
+
     m_avg_packet_vqueue_latency
         .name(name() + ".average_packet_vqueue_latency")
         .flags(Stats::oneline);
@@ -378,6 +405,13 @@ GarnetNetwork::regStats()
     m_avg_hops.name(name() + ".average_hops");
     m_avg_hops = m_total_hops / sum(m_flits_received);
 
+    m_avg_smart_hops.name(name() + ".average_smart_hops");
+    m_avg_smart_hops = m_total_smart_hops / sum(m_flits_received);
+
+    m_avg_hpc.name(name() + ".average_hpc");
+    m_avg_hpc = m_total_hops / m_total_smart_hops;
+
+    //std::cout<<sum(m_flits_received)<<endl;
     // Links
     m_total_ext_in_link_utilization
         .name(name() + ".ext_in_link_utilization");
@@ -411,10 +445,21 @@ GarnetNetwork::collateStats()
             m_total_ext_out_link_utilization += activity;
         else if (type == INT_)
             m_total_int_link_utilization += activity;
-
-        m_average_link_utilization +=
+        if(isCentralControlled())
+        {
+            if(getRoutingAlgorithm()==2)
+            m_average_link_utilization +=
+            (double(activity) / time_delta)*1.52;
+       
+            if(getRoutingAlgorithm()==0)
+            m_average_link_utilization +=
+            (double(activity) / time_delta)*1.41;
+        }
+        else
+        {
+            m_average_link_utilization +=
             (double(activity) / time_delta);
-
+        }
         vector<unsigned int> vc_load = m_networklinks[i]->getVcLoad();
         for (int j = 0; j < vc_load.size(); j++) {
             m_average_vc_load[j] += ((double)vc_load[j] / time_delta);
@@ -458,3 +503,213 @@ GarnetNetwork::functionalWrite(Packet *pkt)
 
     return num_functional_writes;
 }
+
+
+// SMART NoC
+void
+GarnetNetwork::sendSSR(int src, PortDirection outport_dirn, int req_hops,
+                       SSR* t_ssr)
+{
+    //int src_x = src % m_num_cols;
+    int src_y = src / m_num_cols;
+
+    // Send SSR up to req_hops - 1 with bypass_req = true;
+    for (int hops = 1; hops <= req_hops; hops++) {
+
+        bool bypass_req = true;
+        if (hops == req_hops)
+            bypass_req = false;
+
+        if (outport_dirn == "East") {
+            int dst = src + hops;
+            if (dst / m_num_cols == src_y) {
+                // valid dst on same row
+
+                insertSSR(dst, "West", hops, bypass_req, t_ssr);
+            }
+        } else if (outport_dirn == "West") {
+            int dst = src - hops;
+            if (dst > 0 && dst / m_num_cols == src_y) {
+                // valid dst on same row
+
+                insertSSR(dst, "East", hops, bypass_req, t_ssr);
+            }
+        } else if (outport_dirn == "North") {
+            int dst = src + m_num_cols * hops;
+            if (dst / m_num_cols < m_num_rows) {
+                // valid dst
+
+                insertSSR(dst, "South", hops, bypass_req, t_ssr);
+            }
+        } else if (outport_dirn == "South") {
+            int dst = src - m_num_cols * hops;
+            if (dst / m_num_cols > 0) {
+                // valid dst
+
+                insertSSR(dst, "North", hops, bypass_req, t_ssr);
+            }
+        } else {
+            assert(0);
+        }   
+    }
+
+    // insertSSR makes a copy of the SSR for every dest
+    delete t_ssr;
+}
+
+void        
+GarnetNetwork::insertSSR(int dst, PortDirection inport_dirn, 
+                         int src_hops, bool bypass_req, SSR* orig_ssr)
+{
+    SSR *t_ssr = new SSR(orig_ssr->get_vnet(),
+                         src_hops,
+                         src_hops,
+                         bypass_req,
+                         orig_ssr->get_outport_dirn(),
+                         orig_ssr->get_outport_dirn_2(),
+                         orig_ssr->get_ref_flit(),
+                         orig_ssr->get_time());
+
+    m_routers[dst]->insertSSR(inport_dirn, t_ssr);
+
+
+    //m_routers[dst]->insertSSR(inport_dirn, t_ssr);
+}
+
+void
+GarnetNetwork::sendSSR_2D(int src,int dest, PortDirection outport_dirn,
+    int req_hops,int req_hops_2, SSR* t_ssr)
+{
+    //int src_x = src % m_num_cols;
+    int src_y = src / m_num_cols;
+    PortDirection outport_dirn_2;
+
+    int my_x = src % m_num_cols;
+    int my_y = src / m_num_cols;
+
+    int dest_x = dest % m_num_cols;
+    int dest_y = dest / m_num_cols;
+
+    int turn;//turning router id
+    //int turn_x;
+    int turn_y;
+
+    int x_hops = abs(dest_x - my_x);
+    int y_hops = abs(dest_y - my_y);
+
+    bool x_dirn = (dest_x >= my_x);
+    bool y_dirn = (dest_y >= my_y);
+
+
+
+    // Send SSR up to req_hops - 1 with bypass_req = true;
+    for (int hops = 1; hops <= req_hops; hops++) {
+        //this is the first dimension ssr-traverse
+        bool bypass_req = true;
+        if (hops == req_hops)
+            bypass_req = false;
+
+        if (outport_dirn == "East") {
+            int dst = src + hops;
+            if (dst / m_num_cols == src_y) {
+                // valid dst on same row
+
+                insertSSR(dst, "West", hops, bypass_req, t_ssr);
+            }
+        } else if (outport_dirn == "West") {
+            int dst = src - hops;
+            if (dst > 0 && dst / m_num_cols == src_y) {
+                // valid dst on same row
+
+                insertSSR(dst, "East", hops, bypass_req, t_ssr);
+            }
+        } else if (outport_dirn == "North") {
+            int dst = src + m_num_cols * hops;
+            if (dst / m_num_cols < m_num_rows) {
+                // valid dst
+
+                insertSSR(dst, "South", hops, bypass_req, t_ssr);
+            }
+        } else if (outport_dirn == "South") {
+            int dst = src - m_num_cols * hops;
+            if (dst / m_num_cols > 0) {
+                // valid dst
+
+                insertSSR(dst, "North", hops, bypass_req, t_ssr);
+            }
+        } else {
+            assert(0);
+        }
+    }
+    //if req_hop_2 > 0 then need a second traverse
+    if (req_hops_2 > 0){
+        //decide the outport2 direction
+        if (outport_dirn == "East"||outport_dirn == "West"){
+            //the second should along Y axis
+            outport_dirn_2 = (y_dirn)?"North":"South";
+            //calculate the turning router
+            if (x_dirn){
+                //going from east
+                turn = src + x_hops;
+            }else{
+                //going from west
+                turn = src - x_hops;
+            }
+        }else if (outport_dirn == "North"||outport_dirn == "South")
+        {
+            //the second should along X axis
+            outport_dirn_2 = (x_dirn)?"East":"West";
+            //calculate the turning router
+            if (y_dirn){
+                //going from north
+                turn = src + y_hops * m_num_cols;
+            }else{
+                //going from south
+                turn = src - y_hops * m_num_cols;
+            }
+        }
+            //turn_x = turn % m_num_cols;
+            turn_y = turn / m_num_cols;
+            //this is the second dimension ssr-traverse
+        for (int hops = 1; hops <= req_hops_2; hops++) {
+            //this is the first demension ssr-traverse
+            bool bypass_req = true;
+            if (hops == req_hops)
+                bypass_req = false;
+
+            if (outport_dirn_2 == "East") {
+                int dst = turn + hops;
+                if (dst / m_num_cols == turn_y) {
+                    // valid dst on same row
+
+                    insertSSR(dst, "West", hops, bypass_req, t_ssr);
+                }
+            } else if (outport_dirn_2 == "West") {
+                int dst = turn - hops;
+                if (dst > 0 && dst / m_num_cols == turn_y) {
+                    // valid dst on same row
+
+                    insertSSR(dst, "East", hops, bypass_req, t_ssr);
+                }
+            } else if (outport_dirn_2 == "North") {
+                int dst = turn + m_num_cols * hops;
+                if (dst / m_num_cols < m_num_rows) {
+                    // valid dst
+
+                    insertSSR(dst, "South", hops, bypass_req, t_ssr);
+                }
+            } else if (outport_dirn_2 == "South") {
+                int dst = turn - m_num_cols * hops;
+                if (dst / m_num_cols > 0) {
+                    // valid dst
+
+                    insertSSR(dst, "North", hops, bypass_req, t_ssr);
+                }
+            } else {
+                assert(0);
+            }
+        }
+    }
+    // insertSSR makes a copy of the SSR for every dest
+    delete t_ssr;
+}
diff --git a/src/mem/ruby/network/garnet2.0/GarnetNetwork.hh b/src/mem/ruby/network/garnet2.0/GarnetNetwork.hh
index d8cbb08..0e6b017 100644
--- a/src/mem/ruby/network/garnet2.0/GarnetNetwork.hh
+++ b/src/mem/ruby/network/garnet2.0/GarnetNetwork.hh
@@ -34,20 +34,26 @@
 #ifndef __MEM_RUBY_NETWORK_GARNET2_0_GARNETNETWORK_HH__
 #define __MEM_RUBY_NETWORK_GARNET2_0_GARNETNETWORK_HH__
 
+#include <cassert>
 #include <iostream>
+#include <string>
 #include <vector>
 
 #include "mem/ruby/network/Network.hh"
 #include "mem/ruby/network/fault_model/FaultModel.hh"
 #include "mem/ruby/network/garnet2.0/CommonTypes.hh"
 #include "params/GarnetNetwork.hh"
-
+extern std::string graph_file;
+extern int routing_algorithm;
+extern int hpcMax;
+extern int rowNum;
 class FaultModel;
 class NetworkInterface;
 class Router;
 class NetDest;
 class NetworkLink;
 class CreditLink;
+class SSR;
 
 class GarnetNetwork : public Network
 {
@@ -57,6 +63,7 @@ class GarnetNetwork : public Network
 
     ~GarnetNetwork();
     void init();
+    
 
     // Configuration (set externally)
 
@@ -71,6 +78,13 @@ class GarnetNetwork : public Network
     uint32_t getBuffersPerCtrlVC() { return m_buffers_per_ctrl_vc; }
     int getRoutingAlgorithm() const { return m_routing_algorithm; }
 
+    bool isSMART() const { return m_enable_smart; }
+    bool isSMART2D() const { return m_enable_smart2D; }
+    bool isSingleFlit() const { return m_single_flit; }
+    bool isCentralControlled() const {return m_enable_central;}
+    int getHPCmax() const { return m_smart_hpcmax; }
+    bool isSMARTdestBypass() const { return m_smart_dest_bypass; }
+
     bool isFaultModelEnabled() const { return m_enable_fault_model; }
     FaultModel* fault_model;
 
@@ -143,6 +157,25 @@ class GarnetNetwork : public Network
         m_total_hops += hops;
     }
 
+    void
+    increment_total_smart_hops(int smart_hops)
+    {
+        m_total_smart_hops += smart_hops;
+    }
+
+    // SMART NoC
+    void sendSSR(int src, PortDirection outport_dirn,
+                 int req_hops, SSR* t_ssr);
+
+    void sendSSR_2D(int src, int dest,PortDirection outport_dirn,
+                 int req_hops,int req_hops_2, SSR* t_ssr);
+
+    void insertSSR(int dst, PortDirection inport_dirn, int src_hops,
+                    bool bypass_req, SSR* orig_ssr);
+
+    //method for scheduling wakeups for all the routers
+    void wakeupRouter(int m_id);
+
   protected:
     // Configuration
     int m_num_rows;
@@ -152,6 +185,14 @@ class GarnetNetwork : public Network
     uint32_t m_buffers_per_ctrl_vc;
     uint32_t m_buffers_per_data_vc;
     int m_routing_algorithm;
+    bool m_enable_smart;
+    bool m_enable_smart2D;
+    
+    bool m_single_flit;
+    bool m_enable_central;
+    int m_smart_hpcmax;
+    std::string m_filename;
+    bool m_smart_dest_bypass;
     bool m_enable_fault_model;
 
     // Statistical variables
@@ -186,6 +227,10 @@ class GarnetNetwork : public Network
     Stats::Scalar  m_total_hops;
     Stats::Formula m_avg_hops;
 
+    Stats::Scalar  m_total_smart_hops;
+    Stats::Formula m_avg_smart_hops;
+    Stats::Formula m_avg_hpc;
+
   private:
     GarnetNetwork(const GarnetNetwork& obj);
     GarnetNetwork& operator=(const GarnetNetwork& obj);
diff --git a/src/mem/ruby/network/garnet2.0/GarnetNetwork.py b/src/mem/ruby/network/garnet2.0/GarnetNetwork.py
index 04c0ef4..adb1e95 100644
--- a/src/mem/ruby/network/garnet2.0/GarnetNetwork.py
+++ b/src/mem/ruby/network/garnet2.0/GarnetNetwork.py
@@ -44,10 +44,20 @@ class GarnetNetwork(RubyNetwork):
     buffers_per_ctrl_vc = Param.UInt32(1, "buffers per ctrl virtual channel");
     routing_algorithm = Param.Int(0,
         "0: Weight-based Table, 1: XY, 2: Custom");
+    enable_smart = Param.Bool(False, "enable SMART (only 1D supported currently)");
+    enable_smart2D = Param.Bool(False, "enable SMART 2D (alpha)");
+    configure_time = Param.Int(0, "configuration time of ArSMART (for single message)")
+
+    enable_single_flit = Param.Bool(False,"Enable Single Flit traffic");
+    enable_central = Param.Bool(False,"Enable Central Controlled");
+
+    smart_hpcmax = Param.Int(4, "HPC_max for SMART");
+    smart_dest_bypass = Param.Bool(False, "enable SMART destination bypass");
     enable_fault_model = Param.Bool(False, "enable network fault model");
     fault_model = Param.FaultModel(NULL, "network fault model");
     garnet_deadlock_threshold = Param.UInt32(50000,
                               "network-level deadlock threshold")
+    filename = Param.String("h264dl.g", "filename for task graph");
 
 class GarnetNetworkInterface(ClockedObject):
     type = 'GarnetNetworkInterface'
@@ -62,6 +72,8 @@ class GarnetNetworkInterface(ClockedObject):
     garnet_deadlock_threshold = Param.UInt32(Parent.garnet_deadlock_threshold,
                                       "network-level deadlock threshold")
 
+
+
 class GarnetRouter(BasicRouter):
     type = 'GarnetRouter'
     cxx_class = 'Router'
diff --git a/src/mem/ruby/network/garnet2.0/InputUnit.cc b/src/mem/ruby/network/garnet2.0/InputUnit.cc
index c03bf2a..ea77e1d 100644
--- a/src/mem/ruby/network/garnet2.0/InputUnit.cc
+++ b/src/mem/ruby/network/garnet2.0/InputUnit.cc
@@ -49,7 +49,8 @@ InputUnit::InputUnit(int id, PortDirection direction, Router *router)
     m_router = router;
     m_num_vcs = m_router->get_num_vcs();
     m_vc_per_vnet = m_router->get_vc_per_vnet();
-
+    m_inject_vc_table.resize(m_num_vcs);
+    m_invc_smart_table.resize(m_num_vcs);
     m_num_buffer_reads.resize(m_num_vcs/m_vc_per_vnet);
     m_num_buffer_writes.resize(m_num_vcs/m_vc_per_vnet);
     for (int i = 0; i < m_num_buffer_reads.size(); i++) {
@@ -62,6 +63,8 @@ InputUnit::InputUnit(int id, PortDirection direction, Router *router)
     m_vcs.resize(m_num_vcs);
     for (int i=0; i < m_num_vcs; i++) {
         m_vcs[i] = new VirtualChannel(i);
+        m_inject_vc_table[i] = -1;
+        m_invc_smart_table[i] = false;
     }
 }
 
@@ -86,47 +89,110 @@ InputUnit::wakeup()
 {
     flit *t_flit;
     if (m_in_link->isReady(m_router->curCycle())) {
-
+        int vc = -1;
         t_flit = m_in_link->consumeLink();
-        int vc = t_flit->get_vc();
-        t_flit->increment_hops(); // for stats
+        //int vc = t_flit->get_vc();
+        //new vc selection in SMART situation
+
+        if (m_router->get_net_ptr()->isSMART()){
+            switch(t_flit->get_type()){
+                case HEAD_:
+                    vc = t_flit->get_vc();
+                    set_inject_vc_table(vc,
+                    t_flit->get_route()->src_router);
+                break;
+                case BODY_:
+                case TAIL_:
+                //only Local flits needs to be send with VC
+                    if (m_direction!="Local"){
+                        vc = find_inject_vc_table(
+                        t_flit->get_vnet(),
+                        t_flit->get_route()->src_router);}
+                    else{
+                        vc = t_flit->get_vc();
+                    }
+                break;
+                //case TAIL_:
+                    //vc = find_inject_vc_table(
+                    //    t_flit->get_vnet(),
+                    //   t_flit->get_route()->src_router);
+                    //set_inject_vc_table(vc,-1);
+                    //move to router and free vc
+                break;
+                default:
+                    vc = t_flit->get_vc();
+                break;
+            }
+        }else{
+            vc = t_flit->get_vc();
+
+        }
+        // Moved to crossbar
+        // Counting hops as network hops
+        // Not counting hops from/to NI
+        //t_flit->increment_hops(); // for stats
+
+    DPRINTF(RubyNetwork, "Router %d Inport %s received flit %s\n",
+        m_router->get_id(), m_direction, *t_flit);
+
+
 
         if ((t_flit->get_type() == HEAD_) ||
-            (t_flit->get_type() == HEAD_TAIL_)) {
+            (t_flit->get_type() == HEAD_TAIL_)||
+            ((m_router->get_net_ptr()->isSMART()) &&
+            (m_vcs[vc]->get_state() == IDLE_) &&
+            (vc != -1))){
 
             assert(m_vcs[vc]->get_state() == IDLE_);
             set_vc_active(vc, m_router->curCycle());
 
             // Route computation for this vc
-            int outport = m_router->route_compute(t_flit->get_route(),
-                m_id, m_direction);
-
+            int outport;
+            if(t_flit->get_route()->dest_router==t_flit->get_route()->src_router)
+                outport=1;
+            else
+                outport = m_router->route_compute(t_flit->get_route(),
+                    m_id, m_direction);
+            set_outputPort(outport);
             // Update output port in VC
             // All flits in this packet will use this output port
             // The output port field in the flit is updated after it wins SA
             grant_outport(vc, outport);
 
         } else {
-            assert(m_vcs[vc]->get_state() == ACTIVE_);
+            //assert(m_vcs[vc]->get_state() == ACTIVE_);
+            int outport = m_router->route_compute(t_flit->get_route(),
+                m_id, m_direction);
+            outport = outport + 1;
+
         }
 
 
-        // Buffer the flit
+        //Buffer the flit
         m_vcs[vc]->insertFlit(t_flit);
 
         int vnet = vc/m_vc_per_vnet;
-        // number of writes same as reads
-        // any flit that is written will be read only once
+        //number of writes same as reads
+        //any flit that is written will be read only once
         m_num_buffer_writes[vnet]++;
         m_num_buffer_reads[vnet]++;
 
         Cycles pipe_stages = m_router->get_pipe_stages();
-        if (pipe_stages == 1) {
+
+
+
+        if (pipe_stages == 1 || m_router->get_net_ptr()->isCentralControlled()) {
             // 1-cycle router
             // Flit goes for SA directly
+            //Cycles a;
+            //a= m_router->curCycle() - m_router->get_pipe_stages();
+
+            //std::cout<<"InputUnit.cc +++++++++++++++"<<m_router->get_id()<<" my direction "<<m_direction<<"; current cycle = "<<a<<std::endl;
+
             t_flit->advance_stage(SA_, m_router->curCycle());
-        } else {
-            assert(pipe_stages > 1);
+        } 
+        else {
+            //assert(pipe_stages > 1);
             // Router delay is modeled by making flit wait in buffer for
             // (pipe_stages cycles - 1) cycles before going for SA
 
@@ -144,7 +210,7 @@ InputUnit::wakeup()
 void
 InputUnit::increment_credit(int in_vc, bool free_signal, Cycles curTime)
 {
-    Credit *t_credit = new Credit(in_vc, free_signal, curTime);
+    Credit *t_credit = new Credit(in_vc, free_signal, curTime + Cycles(1));
     creditQueue->insert(t_credit);
     m_credit_link->scheduleEventAbsolute(m_router->clockEdge(Cycles(1)));
 }
@@ -169,3 +235,218 @@ InputUnit::resetStats()
         m_num_buffer_writes[j] = 0;
     }
 }
+
+// SMART NoC
+bool
+InputUnit::try_smart_bypass(flit *t_flit)
+{
+    // Check if router is setup for SMART bypass this cycle
+    DPRINTF(RubyNetwork, "Router %d Inport %s trying to bypass flit %s\n",
+                 m_router->get_id(), m_direction, *t_flit);
+
+//    PortDirection outport_dirn = t_flit->get_route()->outport_dirn;
+//    return m_router->try_smart_bypass(m_id, outport_dirn, t_flit);            
+
+    // Check SSR Grant for this cycle
+
+    while (!ssr_grant.empty()) {
+        SSR *t_ssr = ssr_grant.top();
+        if (t_ssr->get_time() < m_router->curCycle()) {
+            ssr_grant.pop();
+            delete t_ssr;
+        } else if (t_ssr->get_time() == m_router->curCycle()) {
+            if (t_ssr->get_ref_flit() != t_flit) {
+                // (i) this flit lost arbitration to a local flit, or
+                // (ii) wanted to stop, and hence its SSR was not sent to 
+                //      this router, and some other SSR won.
+                //(iii) this flit is in a multi-flit transmitting which
+                //is interrupted
+                //to avoid being interrupted
+                //during multi-flit sending
+                //router expect :
+                //1.Body/Tail flit
+                //2.route NOT equal with before
+                /*if (t_ssr->get_ref_flit()->get_route()->src_router!=
+                    m_inject_vc_table[t_ssr->get_ref_flit()->get_vc()]
+                    &&
+                    (t_ssr->get_ref_flit()->get_type()!=BODY_||
+                    t_ssr->get_ref_flit()->get_type()!=TAIL_)
+                ){
+                    ssr_grant.pop();
+                    delete t_ssr;
+                    continue;
+                }
+                    return false;*/
+                break;
+            } else {
+
+                DPRINTF(RubyNetwork, "Router %d Inport %s Trying SMART Bypass for Flit %s\n",
+                        m_router->get_id(), m_direction, *t_flit);
+
+                // SSR for this flit won arbitration last cycle
+                // and wants to bypass this router
+                assert(t_ssr->get_bypass_req());
+                //record smart vcs
+                int vc;
+                switch(t_flit->get_type()){
+                    case HEAD_:
+                        vc = t_flit->get_vc();
+                        if (m_inject_vc_table[vc]!=-1)
+                            return false;
+                        set_inject_vc_table(vc,
+                        t_flit->get_route()->src_router);
+                    break;
+                    case TAIL_:
+                        vc = find_inject_vc_table(
+                            t_flit->get_vnet(),
+                            t_flit->get_route()->src_router);
+
+                    break;
+                    default:
+                        vc = t_flit->get_vc();
+                    break;
+                }
+                /*smart bypass try for
+                1- Head flits/Head_Tail
+                2- Body/Tail flits which invc_smart is true
+                */
+               bool smart_bypass;
+               if ((t_flit->get_type()==HEAD_)||
+               (t_flit->get_type()==HEAD_TAIL_)||
+               (m_invc_smart_table[vc])){
+                smart_bypass =
+                    m_router->try_smart_bypass(m_id,
+                                               t_ssr->get_outport_dirn(),
+                                               t_flit);
+
+                }else{
+                    smart_bypass = false;
+                }
+                ssr_grant.pop();
+                delete t_ssr;
+                m_invc_smart_table[vc] = smart_bypass;
+                //reset the smart table
+                if ((t_flit->get_type()==TAIL_)||
+               (t_flit->get_type()==HEAD_TAIL_)){
+                   m_invc_smart_table[vc] = false;
+               }
+                return smart_bypass;
+            }
+        }
+
+         else {
+            break;
+        }
+    }
+
+    m_invc_smart_table[t_flit->get_vc()] = false;
+    return false;
+}
+
+
+//Central Controlled bypass
+bool
+InputUnit::try_central_bypass(flit *t_flit)
+{
+    // bypass this cycle
+//    PortDirection outport_dirn = t_flit->get_route()->outport_dirn;
+//    return m_router->try_smart_bypass(m_id, outport_dirn, t_flit);            
+    // Check SSR Grant for this cycle
+    std::vector<int> outputlist;
+    int output1=m_router->route_compute(t_flit->get_route(), m_id, m_direction);
+
+    if(output1==0)
+        //return false;
+        output1=1;
+
+   // std::cout<<"Router "<<m_router->get_id()<<" bypass flit "<<"from "<<t_flit->get_route()->src_router<<" to "<<t_flit->get_route()->dest_router<<" at cycle "<<m_router->curCycle()<<std::endl;
+
+  
+
+    DPRINTF(RubyNetwork, "Router %d Inport %s Trying SMART Bypass for Flit %s\n",
+            m_router->get_id(), m_direction, *t_flit);
+
+    // SSR for this flit won arbitration last cycle
+    // and wants to bypass this router
+
+    //record smart vcs
+    int vc;
+    switch(t_flit->get_type()){
+        case HEAD_:
+            vc = t_flit->get_vc();
+            if (m_inject_vc_table[vc]!=-1)
+                return false;
+            set_inject_vc_table(vc,
+            t_flit->get_route()->src_router);
+        break;
+        case TAIL_:
+            vc = find_inject_vc_table(
+                t_flit->get_vnet(),
+                t_flit->get_route()->src_router);
+
+        break;
+        default:
+            vc = t_flit->get_vc();
+        break;
+    }
+    /*smart bypass try for
+    1- Head flits/Head_Tail
+    2- Body/Tail flits which invc_smart is true
+    */
+   //std::cout<<get_outputPort()<<"+++++++++++++++"<<std::endl;
+   bool smart_bypass;
+   if ((t_flit->get_type()==HEAD_)||
+   (t_flit->get_type()==HEAD_TAIL_)){
+    smart_bypass =
+        m_router->try_central_bypass(m_id,
+                                   output1,
+                                   t_flit);
+
+    }else{
+        smart_bypass = false;
+    }
+    
+
+    return smart_bypass;
+}
+
+void
+InputUnit::grantSSR(SSR *t_ssr)
+{           
+    DPRINTF(RubyNetwork, "Router %d Inport %s granted SSR for flit %d from src_hops %d for bypass = %d for Outport %s\n",
+            m_router->get_id(), m_direction, *(t_ssr->get_ref_flit()), t_ssr->get_src_hops(), t_ssr->get_bypass_req(), t_ssr->get_outport_dirn());
+
+    // Update valid time to next cycle
+    t_ssr->set_time(m_router->curCycle() + Cycles(1));        
+    ssr_grant.push(t_ssr);
+}
+
+//find vc by injector
+int
+InputUnit::find_inject_vc_table(int vnet,int injector){
+    int iter;
+    int vc_base = vnet * m_vc_per_vnet;
+    for (iter = vc_base; iter < vc_base + m_vc_per_vnet; iter++){
+        if (m_inject_vc_table[iter]==injector){
+                return iter;
+            }
+
+    }
+    /*assert when did not find anything */
+    //assert(iter < m_num_vcs);
+
+    return -1;
+}
+
+int
+InputUnit::select_free_vc(int vnet)
+{
+    int vc_base = vnet*m_vc_per_vnet;
+    for (int vc = vc_base; vc < vc_base + m_vc_per_vnet; vc++) {
+        if (m_inject_vc_table[vc]==-1) {
+            return vc;
+        }
+    }
+
+    return -1;
+}
diff --git a/src/mem/ruby/network/garnet2.0/InputUnit.hh b/src/mem/ruby/network/garnet2.0/InputUnit.hh
index c2cbd58..924a7aa 100644
--- a/src/mem/ruby/network/garnet2.0/InputUnit.hh
+++ b/src/mem/ruby/network/garnet2.0/InputUnit.hh
@@ -36,6 +36,7 @@
 
 #include <iostream>
 #include <vector>
+#include <queue>
 
 #include "mem/ruby/common/Consumer.hh"
 #include "mem/ruby/network/garnet2.0/CommonTypes.hh"
@@ -44,6 +45,8 @@
 #include "mem/ruby/network/garnet2.0/Router.hh"
 #include "mem/ruby/network/garnet2.0/VirtualChannel.hh"
 #include "mem/ruby/network/garnet2.0/flitBuffer.hh"
+#include "mem/ruby/network/garnet2.0/SSR.hh"
+
 
 class InputUnit : public Consumer
 {
@@ -56,9 +59,17 @@ class InputUnit : public Consumer
 
     inline PortDirection get_direction() { return m_direction; }
 
+    inline bool
+    is_vc_idle(int vc)
+    {
+        return (m_vcs[vc]->get_state() == IDLE_);
+    }
+
     inline void
     set_vc_idle(int vc, Cycles curTime)
     {
+        m_inject_vc_table[vc] = -1;
+        m_invc_smart_table[vc] = false;
         m_vcs[vc]->set_idle(curTime);
     }
 
@@ -134,12 +145,17 @@ class InputUnit : public Consumer
 
     inline int get_inlink_id() { return m_in_link->get_id(); }
 
+    inline int get_outputPort() { return outputPort; }
+    inline void set_outputPort(int a) {outputPort = a;}
+
     inline void
     set_credit_link(CreditLink *credit_link)
     {
         m_credit_link = credit_link;
     }
 
+    GarnetNetwork* get_net_ptr() { return m_router->get_net_ptr(); }
+
     double get_buf_read_activity(unsigned int vnet) const
     { return m_num_buffer_reads[vnet]; }
     double get_buf_write_activity(unsigned int vnet) const
@@ -148,11 +164,22 @@ class InputUnit : public Consumer
     uint32_t functionalWrite(Packet *pkt);
     void resetStats();
 
+    // SMART NoC
+    void grantSSR(SSR *t_ssr);
+    bool try_smart_bypass(flit *t_flit);
+    bool try_central_bypass(flit *t_flit);
+    void set_inject_vc_table(int vc, int injector)
+    {
+        m_inject_vc_table[vc]=injector;
+    }
+    int find_inject_vc_table(int vnet,int injector);
+    int select_free_vc(int vnet);
   private:
     int m_id;
     PortDirection m_direction;
     int m_num_vcs;
     int m_vc_per_vnet;
+    int outputPort;
 
     Router *m_router;
     NetworkLink *m_in_link;
@@ -165,6 +192,21 @@ class InputUnit : public Consumer
     // Statistical variables
     std::vector<double> m_num_buffer_writes;
     std::vector<double> m_num_buffer_reads;
+
+    // SMART
+    struct SSR_time
+    {
+        bool operator()(const SSR *lhs, const SSR *rhs) const
+        {
+                return lhs->m_time >= rhs->m_time;
+        }
+    };
+
+    std::vector<int> m_inject_vc_table;
+    std::vector<bool> m_invc_smart_table;
+    // Moved to Output Unit
+//    std::priority_queue<SSR*, std::vector<SSR*>, SSR_prio_local> ssr_reqs;
+    std::priority_queue<SSR*, std::vector<SSR*>, SSR_time> ssr_grant;
 };
 
 #endif // __MEM_RUBY_NETWORK_GARNET2_0_INPUTUNIT_HH__
diff --git a/src/mem/ruby/network/garnet2.0/NetworkInterface.cc b/src/mem/ruby/network/garnet2.0/NetworkInterface.cc
index 4e69270..8cacd4c 100644
--- a/src/mem/ruby/network/garnet2.0/NetworkInterface.cc
+++ b/src/mem/ruby/network/garnet2.0/NetworkInterface.cc
@@ -35,6 +35,7 @@
 
 #include <cassert>
 #include <cmath>
+#include <string>
 
 #include "base/cast.hh"
 #include "base/stl_helpers.hh"
@@ -49,7 +50,8 @@ using m5::stl_helpers::deletePointers;
 
 NetworkInterface::NetworkInterface(const Params *p)
     : ClockedObject(p), Consumer(this), m_id(p->id),
-      m_virtual_networks(p->virt_nets), m_vc_per_vnet(p->vcs_per_vnet),
+      m_virtual_networks(p->virt_nets), 
+      m_vc_per_vnet(p->vcs_per_vnet),
       m_num_vcs(m_vc_per_vnet * m_virtual_networks),
       m_deadlock_threshold(p->garnet_deadlock_threshold),
       vc_busy_counter(m_virtual_networks, 0)
@@ -155,14 +157,58 @@ NetworkInterface::incrementStats(flit *t_flit)
     m_net_ptr->increment_flit_network_latency(network_delay, vnet);
     m_net_ptr->increment_flit_queueing_latency(queueing_delay, vnet);
 
+
     if (t_flit->get_type() == TAIL_ || t_flit->get_type() == HEAD_TAIL_) {
         m_net_ptr->increment_received_packets(vnet);
+        
+
         m_net_ptr->increment_packet_network_latency(network_delay, vnet);
         m_net_ptr->increment_packet_queueing_latency(queueing_delay, vnet);
     }
+    // record the number of received packets
+    if(syntheticPattern==8 &&(!m_net_ptr->isCentralControlled())){
+        if(t_flit->get_type() == TAIL_ || t_flit->get_type() == HEAD_TAIL_)
+        {
+            //std::cout<<"Router "<<m_router_id<<" receives a packet!!!"<<std::endl;
+            //*t_flit->get_msg_ptr()<<" "<<t_flit->get_route()->src_router<<" to "<<t_flit->get_route()->dest_router<<" "<<curCycle()<<std::endl;
+            //changed here receiveMatrix 
+            //if it is the 
+            // if(t_flit->get_route()->src_router==t_flit->get_route()->dest_router)
+            // {
+            //     Json::Value t = multiOutput[m_router_id];
+            //     int a =t.size();
+            //     for(int i=0;i<a;i++)
+            //     {
+            //         receiveMatrix[t[i].asInt()]--;
+            //     }
+
+            // }
+            // else
+            // {
+            string linkName;
+            int receiveTaskId;
+            int destRouter = int(m_router_id);
+            //std::cout<<"here++++++++++++++++++++"<<destRouter<<" "<<dstMapTasks[destRouter].size()<<std::endl;;
+            for (int tt = 0;tt<dstMapTasks[destRouter].size();tt++)
+            {
+                
+                linkName = dstMapTasks[destRouter][tt].linkname;
+                receiveTaskId = dstMapTasks[destRouter][tt].taskId;
+                if(allLinks[linkName]>0)
+                    break;
+                
 
+            }
+            receiveMatrix[receiveTaskId]--;
+            //}
+            transTime = transTime + int(t_flit->get_time());
+
+            allLinks[linkName]--;
+        }
+    }
     // Hops
-    m_net_ptr->increment_total_hops(t_flit->get_route().hops_traversed);
+    m_net_ptr->increment_total_hops(t_flit->get_route()->hops_traversed);
+    m_net_ptr->increment_total_smart_hops(t_flit->get_route()->smart_hops_traversed);
 }
 
 /*
@@ -194,6 +240,7 @@ NetworkInterface::wakeup()
 
         if (b->isReady(curTime)) { // Is there a message waiting
             msg_ptr = b->peekMsgPtr();
+            //std::cout<<"Enqueue"<<msg_ptr->realSrc<<msg_ptr->realDst<<std::endl;
             if (flitisizeMessage(msg_ptr, vnet)) {
                 b->dequeue(curTime);
             }
@@ -327,16 +374,21 @@ bool
 NetworkInterface::flitisizeMessage(MsgPtr msg_ptr, int vnet)
 {
     Message *net_msg_ptr = msg_ptr.get();
+
     NetDest net_msg_dest = net_msg_ptr->getDestination();
 
+
     // gets all the destinations associated with this message.
     vector<NodeID> dest_nodes = net_msg_dest.getAllDest();
 
     // Number of flits is dependent on the link bandwidth available.
     // This is expressed in terms of bytes/cycle or the flit size
-    int num_flits = (int) ceil((double) m_net_ptr->MessageSizeType_to_int(
-        net_msg_ptr->getMessageSize())/m_net_ptr->getNiFlitSize());
-
+    int num_flits;
+    if (!m_net_ptr->isSingleFlit())
+        num_flits = (int) ceil((double) m_net_ptr->MessageSizeType_to_int(
+            net_msg_ptr->getMessageSize())/m_net_ptr->getNiFlitSize());
+    else
+        num_flits = 1;//for generating single flit traffic
     // loop to convert all multicast messages into unicast messages
     for (int ctr = 0; ctr < dest_nodes.size(); ctr++) {
 
@@ -381,11 +433,16 @@ NetworkInterface::flitisizeMessage(MsgPtr msg_ptr, int vnet)
         route.dest_ni = destID;
         route.dest_router = m_net_ptr->get_router_id(destID);
 
-        // initialize hops_traversed to -1
-        // so that the first router increments it to 0
-        route.hops_traversed = -1;
+        // initialize hops_traversed to 0
+        route.hops_traversed = 0;
+
+        // initialize smart_hops_traversed to 0
+        // Incremented by crossbar (i.e., start of a smart hop)
+        route.smart_hops_traversed = 0;
 
         m_net_ptr->increment_injected_packets(vnet);
+
+
         for (int i = 0; i < num_flits; i++) {
             m_net_ptr->increment_injected_flits(vnet);
             flit *fl = new flit(i, vc, vnet, route, num_flits, new_msg_ptr,
diff --git a/src/mem/ruby/network/garnet2.0/NetworkInterface.hh b/src/mem/ruby/network/garnet2.0/NetworkInterface.hh
index 3b77371..a8d4ae3 100644
--- a/src/mem/ruby/network/garnet2.0/NetworkInterface.hh
+++ b/src/mem/ruby/network/garnet2.0/NetworkInterface.hh
@@ -37,6 +37,7 @@
 #include <iostream>
 #include <vector>
 
+#include "cpu/testers/garnet_synthetic_traffic/GarnetSyntheticTraffic.hh"
 #include "mem/ruby/common/Consumer.hh"
 #include "mem/ruby/network/garnet2.0/CommonTypes.hh"
 #include "mem/ruby/network/garnet2.0/CreditLink.hh"
diff --git a/src/mem/ruby/network/garnet2.0/NetworkLink.cc b/src/mem/ruby/network/garnet2.0/NetworkLink.cc
index e718fb8..c21f395 100644
--- a/src/mem/ruby/network/garnet2.0/NetworkLink.cc
+++ b/src/mem/ruby/network/garnet2.0/NetworkLink.cc
@@ -32,8 +32,8 @@
 
 
 #include "mem/ruby/network/garnet2.0/NetworkLink.hh"
-
 #include "mem/ruby/network/garnet2.0/CreditLink.hh"
+#include "mem/ruby/network/garnet2.0/InputUnit.hh"
 
 NetworkLink::NetworkLink(const Params *p)
     : ClockedObject(p), Consumer(this), m_id(p->link_id),
@@ -57,6 +57,13 @@ NetworkLink::setLinkConsumer(Consumer *consumer)
 }
 
 void
+NetworkLink::setLinkConsumerInport(InputUnit *inport)
+{
+    link_consumer_inport = inport;
+}
+
+
+void
 NetworkLink::setSourceQueue(flitBuffer *srcQueue)
 {
     link_srcQueue = srcQueue;
@@ -65,14 +72,88 @@ NetworkLink::setSourceQueue(flitBuffer *srcQueue)
 void
 NetworkLink::wakeup()
 {
+    //std::cout<<"NetworkLink.cc wakeup++++++++++++++++++++++++++"<<curCycle()<<std::endl;
+
     if (link_srcQueue->isReady(curCycle())) {
-        flit *t_flit = link_srcQueue->getTopFlit();
-        t_flit->set_time(curCycle() + m_latency);
-        linkBuffer->insert(t_flit);
-        link_consumer->scheduleEventAbsolute(clockEdge(m_latency));
-        m_link_utilized++;
-        m_vc_load[t_flit->get_vc()]++;
-    }
+        //change here
+        // if(syntheticPattern==8 &&(isSDNoC)){
+        //     int totalFlit = link_srcQueue->getSize();
+        //     for(int i = 0;i< totalFlit;++i)
+        //     {
+        //         flit *t_flit = link_srcQueue->getTopFlit();
+        //         if(t_flit->get_type() == TAIL_ || t_flit->get_type() == HEAD_TAIL_)
+        //         {
+        //             std::cout<<"Router "<<m_id<<" receives a packet!!!"<<t_flit->get_type()<<" "<<t_flit->get_route()->src_router<<" to "<<t_flit->get_route()->dest_router<<" "<<curCycle()<<std::endl;
+        //             //if it is the 
+        //             if(t_flit->get_route()->src_router==t_flit->get_route()->dest_router)
+        //             {
+        //                 Json::Value t = multiOutput[m_id];
+        //                 int a =t.size();
+        //                 for(int i=0;i<a;i++)
+        //                 {
+        //                     receiveMatrix[t[i].asInt()]--;
+        //                 }
+
+        //             }
+        //             else
+        //             {
+        //                 receiveMatrix[int(t_flit->get_route()->dest_router)]--;
+        //             }
+                    
+        //             std::string linkname;
+
+        //             linkname = to_string(t_flit->get_route()->src_router)+"+"+to_string(t_flit->get_route()->dest_router);
+        //             allLinks[linkname]--;
+        //         }
+        //     }
+
+            
+        // }
+        // else{
+            flit *t_flit = link_srcQueue->getTopFlit();
+                
+            t_flit->set_time(curCycle());
+            m_link_utilized++;
+            m_vc_load[t_flit->get_vc()]++;
+
+            bool router_bypass = false;
+            if (m_type == INT_) {
+
+                // SMART NoC:
+                if (link_consumer_inport->get_net_ptr()->isSMART()) {
+                    // See if router is set to bypass mode for this flit
+                    // If it is, then flit will bypass and go to next link
+                    t_flit->set_time(curCycle());
+                    router_bypass = link_consumer_inport->try_smart_bypass(t_flit);
+                }
+                //Central Bypass
+                if (link_consumer_inport->get_net_ptr()->isCentralControlled()){
+
+                    
+                    t_flit->set_time(curCycle());
+                    router_bypass = link_consumer_inport->try_central_bypass(t_flit);
+                    router_bypass = 1;
+
+                    //linkBuffer->insert(t_flit);
+                    //link_consumer->scheduleEventAbsolute(clockEdge(Cycles(0)));
+                }
+            }
+            //std::cout<<"router bypass this cycle "<<curCycle()<<" "<<router_bypass<<std::endl;
+            if (!router_bypass) {
+                // Baseline, or
+                // SMART where flit has to be buffered at next router 
+                // because it is turning/dest router, or SSR lost
+                t_flit->set_time(curCycle() + m_latency);
+                linkBuffer->insert(t_flit);
+                link_consumer->scheduleEventAbsolute(clockEdge(m_latency));
+            }
+        }
+//    }
+
+    // Two flits cannot be ready for LT at the same time
+    // Assertion added to make sure SMART not getting
+    // higher bandwidth unfairly
+    assert(!link_srcQueue->isReady(curCycle()));
 }
 
 void
diff --git a/src/mem/ruby/network/garnet2.0/NetworkLink.hh b/src/mem/ruby/network/garnet2.0/NetworkLink.hh
index 98fb7b9..ad145a4 100644
--- a/src/mem/ruby/network/garnet2.0/NetworkLink.hh
+++ b/src/mem/ruby/network/garnet2.0/NetworkLink.hh
@@ -37,6 +37,7 @@
 #include <iostream>
 #include <vector>
 
+#include "cpu/testers/garnet_synthetic_traffic/GarnetSyntheticTraffic.hh"
 #include "mem/ruby/common/Consumer.hh"
 #include "mem/ruby/network/garnet2.0/CommonTypes.hh"
 #include "mem/ruby/network/garnet2.0/flitBuffer.hh"
@@ -44,6 +45,7 @@
 #include "sim/clocked_object.hh"
 
 class GarnetNetwork;
+class InputUnit;
 
 class NetworkLink : public ClockedObject, public Consumer
 {
@@ -53,6 +55,7 @@ class NetworkLink : public ClockedObject, public Consumer
     ~NetworkLink();
 
     void setLinkConsumer(Consumer *consumer);
+    void setLinkConsumerInport(InputUnit *inport);
     void setSourceQueue(flitBuffer *srcQueue);
     void setType(link_type type) { m_type = type; }
     link_type getType() { return m_type; }
@@ -72,7 +75,7 @@ class NetworkLink : public ClockedObject, public Consumer
     uint32_t functionalWrite(Packet *);
     void resetStats();
 
-  private:
+  protected:
     const int m_id;
     link_type m_type;
     const Cycles m_latency;
@@ -81,6 +84,8 @@ class NetworkLink : public ClockedObject, public Consumer
     Consumer *link_consumer;
     flitBuffer *link_srcQueue;
 
+    InputUnit *link_consumer_inport; // used by SMART for single-cycle bypass
+
     // Statistical variables
     unsigned int m_link_utilized;
     std::vector<unsigned int> m_vc_load;
diff --git a/src/mem/ruby/network/garnet2.0/OutVcState.cc b/src/mem/ruby/network/garnet2.0/OutVcState.cc
index 1ad65ec..98216ca 100644
--- a/src/mem/ruby/network/garnet2.0/OutVcState.cc
+++ b/src/mem/ruby/network/garnet2.0/OutVcState.cc
@@ -47,6 +47,7 @@ OutVcState::OutVcState(int id, GarnetNetwork *network_ptr)
         m_max_credit_count = network_ptr->getBuffersPerCtrlVC();
 
     m_credit_count = m_max_credit_count;
+    network_type = network_ptr->isSMART();
     assert(m_credit_count >= 1);
 }
 
@@ -54,7 +55,8 @@ void
 OutVcState::increment_credit()
 {
     m_credit_count++;
-    assert(m_credit_count <= m_max_credit_count);
+    if(network_type==1)
+        assert(m_credit_count <= m_max_credit_count);
 }
 
 void
diff --git a/src/mem/ruby/network/garnet2.0/OutVcState.hh b/src/mem/ruby/network/garnet2.0/OutVcState.hh
index 673b209..37056a9 100644
--- a/src/mem/ruby/network/garnet2.0/OutVcState.hh
+++ b/src/mem/ruby/network/garnet2.0/OutVcState.hh
@@ -65,6 +65,7 @@ class OutVcState
     VC_state_type m_vc_state;
     int m_credit_count;
     int m_max_credit_count;
+    int network_type;
 };
 
 #endif //__MEM_RUBY_NETWORK_GARNET2_0_OUTVCSTATE_HH__
diff --git a/src/mem/ruby/network/garnet2.0/OutputUnit.cc b/src/mem/ruby/network/garnet2.0/OutputUnit.cc
index 85fef5e..f7c0aea 100644
--- a/src/mem/ruby/network/garnet2.0/OutputUnit.cc
+++ b/src/mem/ruby/network/garnet2.0/OutputUnit.cc
@@ -50,7 +50,8 @@ OutputUnit::OutputUnit(int id, PortDirection direction, Router *router)
     m_num_vcs = m_router->get_num_vcs();
     m_vc_per_vnet = m_router->get_vc_per_vnet();
     m_out_buffer = new flitBuffer();
-
+    m_pkt_route_src=-1;
+    m_pkt_route_dest=-1;
     for (int i = 0; i < m_num_vcs; i++) {
         m_outvc_state.push_back(new OutVcState(i, m_router->get_net_ptr()));
     }
@@ -108,17 +109,18 @@ OutputUnit::has_free_vc(int vnet)
 
 // Assign a free output VC to the winner of Switch Allocation
 int
-OutputUnit::select_free_vc(int vnet)
+OutputUnit::select_free_vc(int vnet,flit* t_flit)
 {
     int vc_base = vnet*m_vc_per_vnet;
-    for (int vc = vc_base; vc < vc_base + m_vc_per_vnet; vc++) {
+    int vc=-1;
+    for (vc = vc_base; vc < vc_base + m_vc_per_vnet; vc++) {
         if (is_vc_idle(vc, m_router->curCycle())) {
             m_outvc_state[vc]->setState(ACTIVE_, m_router->curCycle());
-            return vc;
+            break;
         }
     }
 
-    return -1;
+    return (vc>=vc_base+m_vc_per_vnet?-1:vc);
 }
 
 /*
@@ -132,7 +134,12 @@ OutputUnit::select_free_vc(int vnet)
 void
 OutputUnit::wakeup()
 {
-    if (m_credit_link->isReady(m_router->curCycle())) {
+    // SMART can send 2 credits in the same cycle
+    // One from SA-L.
+    // One during bypass.
+    // Hence while loop
+    int num_credits = 0;
+    while (m_credit_link->isReady(m_router->curCycle())) {
         Credit *t_credit = (Credit*) m_credit_link->consumeLink();
         increment_credit(t_credit->get_vc());
 
@@ -140,6 +147,13 @@ OutputUnit::wakeup()
             set_vc_state(IDLE_, t_credit->get_vc(), m_router->curCycle());
 
         delete t_credit;
+
+        num_credits++;
+    }
+
+    if (num_credits > 1) {
+//        assert(m_router->get_net_ptr()->isSMART());
+        assert(num_credits == 2);
     }
 }
 
@@ -161,6 +175,75 @@ OutputUnit::set_credit_link(CreditLink *credit_link)
     m_credit_link = credit_link;
 }
 
+// SMART NoC
+void
+OutputUnit::insertSSR(SSR *t_ssr)
+{
+    ssr_reqs.push(t_ssr);
+
+    // Wake up Router next cycle for SA-G
+    m_router->schedule_wakeup(Cycles(1));
+}
+
+// Is there a valid SSR for this cycle
+bool
+OutputUnit::isReadySSR()
+{
+    // delete invalid SSRs
+    while (!ssr_reqs.empty()) {
+        SSR *t_ssr = ssr_reqs.top();
+        if (t_ssr->get_time() < m_router->curCycle()) {
+            ssr_reqs.pop();
+            delete t_ssr;
+        } else if (t_ssr->get_time() == m_router->curCycle())
+            return true;
+        else
+            break;
+    }
+
+    return false;
+}
+
+// Get highest priority SSR
+SSR*
+OutputUnit::getTopSSR()
+{
+    SSR *t_ssr = ssr_reqs.top();
+    ssr_reqs.pop();
+
+    return t_ssr;
+}
+
+// SSR has been granted
+// clear SSR request queue for this cycle
+void
+OutputUnit::clearSSRreqs()
+{
+    while (!ssr_reqs.empty()) {
+        SSR *t_ssr = ssr_reqs.top();
+        if (t_ssr->get_time() <= m_router->curCycle()) {
+            ssr_reqs.pop();
+            delete t_ssr;
+        } else {
+            break;
+        }
+    }
+}
+
+// Multi-hop bypass
+void
+OutputUnit::smart_bypass(flit *t_flit)
+{
+    m_out_buffer->insert(t_flit);
+    m_out_link->wakeup(); // wakeup this cycle
+}
+void
+OutputUnit::central_bypass(flit *t_flit)
+{
+    m_out_buffer->insert(t_flit);
+    m_out_link->wakeup(); // wakeup this cycle
+}
+
 uint32_t
 OutputUnit::functionalWrite(Packet *pkt)
 {
diff --git a/src/mem/ruby/network/garnet2.0/OutputUnit.hh b/src/mem/ruby/network/garnet2.0/OutputUnit.hh
index fba8343..4335a90 100644
--- a/src/mem/ruby/network/garnet2.0/OutputUnit.hh
+++ b/src/mem/ruby/network/garnet2.0/OutputUnit.hh
@@ -36,6 +36,7 @@
 
 #include <iostream>
 #include <vector>
+#include <queue>
 
 #include "mem/ruby/common/Consumer.hh"
 #include "mem/ruby/network/garnet2.0/CommonTypes.hh"
@@ -59,7 +60,7 @@ class OutputUnit : public Consumer
     void increment_credit(int out_vc);
     bool has_credit(int out_vc);
     bool has_free_vc(int vnet);
-    int select_free_vc(int vnet);
+    int select_free_vc(int vnet,flit* t_flit);
 
     inline PortDirection get_direction() { return m_direction; }
 
@@ -68,7 +69,29 @@ class OutputUnit : public Consumer
     {
         return m_outvc_state[vc]->get_credit_count();
     }
+    void
+    set_pkt_route(int src,int dest,int invc)
+    {
+        m_pkt_route_src= src;
+        m_pkt_route_dest= dest;
+        m_pkt_invc = invc;
+    }
 
+    int
+    get_curr_pkt_src()
+    {
+        return m_pkt_route_src;
+    }
+    int
+    get_curr_pkt_dest()
+    {
+        return m_pkt_route_dest;
+    }
+    int
+    get_curr_pkt_invc()
+    {
+        return m_pkt_invc;
+    }
     inline int
     get_outlink_id()
     {
@@ -96,9 +119,17 @@ class OutputUnit : public Consumer
 
     uint32_t functionalWrite(Packet *pkt);
 
+    // SMART NoC
+    void insertSSR(SSR *t_ssr);
+    bool isReadySSR();
+    SSR* getTopSSR();
+    void clearSSRreqs();
+    void smart_bypass(flit *t_flit);
+    void central_bypass(flit *t_flit);
   private:
     int m_id;
     PortDirection m_direction;
+    int m_pkt_route_src,m_pkt_route_dest,m_pkt_invc;
     int m_num_vcs;
     int m_vc_per_vnet;
     Router *m_router;
@@ -108,6 +139,21 @@ class OutputUnit : public Consumer
     flitBuffer *m_out_buffer; // This is for the network link to consume
     std::vector<OutVcState *> m_outvc_state; // vc state of downstream router
 
+    // SMART
+    struct SSR_prio_local
+    {
+        bool operator()(const SSR *lhs, const SSR *rhs) const
+        {
+            if (lhs->m_time == rhs->m_time)
+                // reverse the following for prio_bypass
+                return lhs->m_src_hops > rhs->m_src_hops;
+            else
+                return lhs->m_time > rhs->m_time;
+        }
+    };
+
+    std::priority_queue<SSR*, std::vector<SSR*>, SSR_prio_local> ssr_reqs;
+    //std::priority_queue<SSR*, std::vector<SSR*>, SSR_prio_local> ssr_grant;
 };
 
 #endif // __MEM_RUBY_NETWORK_GARNET2_0_OUTPUTUNIT_HH__
diff --git a/src/mem/ruby/network/garnet2.0/Router.cc b/src/mem/ruby/network/garnet2.0/Router.cc
index 7266f99..6afe3d1 100644
--- a/src/mem/ruby/network/garnet2.0/Router.cc
+++ b/src/mem/ruby/network/garnet2.0/Router.cc
@@ -47,14 +47,13 @@
 using namespace std;
 using m5::stl_helpers::deletePointers;
 
-Router::Router(const Params *p)
+/*Router::Router(const Params *p)
     : BasicRouter(p), Consumer(this)
 {
     m_latency = p->latency;
     m_virtual_networks = p->virt_nets;
     m_vc_per_vnet = p->vcs_per_vnet;
     m_num_vcs = m_virtual_networks * m_vc_per_vnet;
-
     m_routing_unit = new RoutingUnit(this);
     m_sw_alloc = new SwitchAllocator(this);
     m_switch = new CrossbarSwitch(this);
@@ -118,6 +117,7 @@ Router::addInPort(PortDirection inport_dirn,
     input_unit->set_in_link(in_link);
     input_unit->set_credit_link(credit_link);
     in_link->setLinkConsumer(this);
+    in_link->setLinkConsumerInport(input_unit);
     credit_link->setSourceQueue(input_unit->getCreditQueue());
 
     m_input_unit.push_back(input_unit);
@@ -159,7 +159,7 @@ Router::getInportDirection(int inport)
 }
 
 int
-Router::route_compute(RouteInfo route, int inport, PortDirection inport_dirn)
+Router::route_compute(RouteInfo *route, int inport, PortDirection inport_dirn)
 {
     return m_routing_unit->outportCompute(route, inport, inport_dirn);
 }
@@ -188,6 +188,160 @@ Router::getPortDirectionName(PortDirection direction)
 }
 
 void
+Router::insertSSR(PortDirection inport_dirn, SSR* t_ssr)
+{
+    DPRINTF(RubyNetwork, "Router %d Inport %s received SSR from src_hops %d for bypass = %d for Outport %s\n",
+            get_id(), inport_dirn, t_ssr->get_src_hops(), t_ssr->get_bypass_req(), t_ssr->get_outport_dirn());
+
+    int inport = m_routing_unit->getInportIdx(inport_dirn);
+    int outport = m_routing_unit->getOutportIdx(t_ssr->get_outport_dirn());
+
+    t_ssr->set_inport(inport);
+
+    // Update SSR if dest bypass enabled
+    if (t_ssr->get_src_hops() > 0 && !t_ssr->get_bypass_req()) {
+        // dest or turning router
+        RouteInfo* route = t_ssr->get_ref_flit()->get_route();
+        bool is_dest = (route->dest_router == m_id);
+
+        if (get_net_ptr()->isSMARTdestBypass() && is_dest) {
+            outport = m_routing_unit->lookupRoutingTable(route->vnet, route->net_dest);
+            PortDirection outport_dirn = m_output_unit[outport]->get_direction();
+
+            t_ssr->set_outport_dirn(outport_dirn);
+            t_ssr->set_bypass_req(true);
+        } else {
+            delete t_ssr;
+            return;
+        }
+    }
+    m_output_unit[outport]->insertSSR(t_ssr);
+}
+
+bool
+Router::smart_vc_select(int inport, int outport, flit *t_flit)
+{
+    // VC Selection
+    int vnet = t_flit->get_vnet();
+    bool has_free_vc = m_output_unit[outport]->has_free_vc(vnet);
+    if (!has_free_vc)
+        return false;
+
+    // Update VC in flit
+    int invc = t_flit->get_vc();
+    int outvc;
+    switch(t_flit->get_type()){
+        case HEAD_:case HEAD_TAIL_:
+            outvc = m_output_unit[outport]->select_free_vc(vnet,t_flit);
+            m_input_unit[inport]->set_inject_vc_table(invc,
+            t_flit->get_route()->src_router);
+            m_output_unit[outport]->set_inject_vc_table(outvc,
+            t_flit->get_route()->src_router);
+            m_input_unit[inport]->grant_outvc(invc, outvc);
+        break;
+        case BODY_:case TAIL_:
+            outvc = m_input_unit[inport]->get_outvc(invc);
+        break;
+        default:
+
+        break;
+    }
+
+    if (outvc == -1 || outvc == -2 )
+        return false;
+    else if (!m_output_unit[outport]->has_credit(outvc))
+    // if don't have credit then return false
+        return false;
+    else
+        t_flit->set_vc(outvc);
+    m_output_unit[outport]->decrement_credit(outvc);
+
+    // Send credit for VCid flit came with
+    // Verify input VC is free and IDLE
+    assert(!(m_input_unit[inport]->isReady(invc, curCycle())));
+    //assert(m_input_unit[inport]->is_vc_idle(invc));
+
+    // Send credit for VCid flit came with
+    switch(t_flit->get_type()){
+        case TAIL_:case HEAD_TAIL_:
+            m_output_unit[outport]->set_inject_vc_table(outvc,-1);
+            m_input_unit[inport]->grant_outvc(invc, -1);
+            m_input_unit[inport]->set_vc_idle(invc,curCycle());
+            m_input_unit[inport]->increment_credit(invc, true, curCycle());
+        break;
+        default:
+            m_input_unit[inport]->increment_credit(invc, false, curCycle());
+        break;
+    }
+
+
+    return true;
+}
+
+void
+Router::smart_route_update(int inport, int outport, flit* t_flit)
+{
+    // Update route in flit
+    // Call route_compute so that x_hops/y_hops decremented
+    int check_outport = route_compute(t_flit->get_route(),
+        inport, m_input_unit[inport]->get_direction());
+    assert(check_outport == outport);
+    t_flit->set_outport(outport);
+}
+
+bool
+Router::try_smart_bypass(int inport, PortDirection outport_dirn, flit *t_flit)
+{
+    int outport = m_routing_unit->getOutportIdx(outport_dirn);
+    //Check outport
+    //if outport is in use then
+    //refuse head or head tail flit
+    if (m_sw_alloc->get_outport_use(outport)&&
+    ((t_flit->get_type()==HEAD_) ||
+    (t_flit->get_type()==HEAD_TAIL_)))
+        return false;
+    // Update VC
+    bool has_vc = smart_vc_select(inport, outport, t_flit);
+    if (!has_vc)
+        return false;
+
+    // Update Route
+    smart_route_update(inport, outport, t_flit);
+
+    DPRINTF(RubyNetwork, "Router %d Inport %s and Outport %d successful SMART Bypass for Flit %s\n",
+            get_id(), getPortDirectionName(m_input_unit[inport]->get_direction()), outport_dirn, *t_flit);
+
+    //set outport status
+    // one outport is free when tail or head_tail_
+
+    //set outport pkt route
+    //1.when head_ set route src,dest
+    //2.when tail_ head_tail_ set 0
+    switch(t_flit->get_type()){
+        case HEAD_:
+            m_output_unit[outport]->set_pkt_route(
+                t_flit->get_route()->src_router,
+                t_flit->get_route()->dest_router
+            );
+        case BODY_:
+            m_sw_alloc->set_outport_in_use(outport,true);
+            break;
+        case TAIL_:
+        case HEAD_TAIL_:
+            m_sw_alloc->set_outport_in_use(outport,false);
+            m_output_unit[outport]->set_pkt_route(-1,-1);
+            break;
+        default:
+            break;
+    }
+    // Add flit to output link
+    m_output_unit[outport]->smart_bypass(t_flit);
+    t_flit->increment_hops(); // for stats
+
+    return true;
+}
+ 
+void
 Router::regStats()
 {
     BasicRouter::regStats();
@@ -296,4 +450,582 @@ Router *
 GarnetRouterParams::create()
 {
     return new Router(this);
+}*/
+
+Router::Router(const Params *p)
+    : BasicRouter(p), Consumer(this)
+{
+    m_latency = p->latency;
+    m_virtual_networks = p->virt_nets;
+    m_vc_per_vnet = p->vcs_per_vnet;
+    m_num_vcs = m_virtual_networks * m_vc_per_vnet;
+    m_routing_unit = new RoutingUnit((Router*)this);
+    m_sw_alloc = new SwitchAllocator((Router*)this);
+    m_switch = new CrossbarSwitch((Router*)this);
+
+    m_input_unit.clear();
+    m_output_unit.clear();
+}
+
+Router::~Router()
+{
+    deletePointers(m_input_unit);
+    deletePointers(m_output_unit);
+    delete m_routing_unit;
+    delete m_sw_alloc;
+    delete m_switch;
+}
+
+void
+Router::init()
+{
+    BasicRouter::init();
+    m_curTask= nullptr;
+    m_sw_alloc->init();
+    m_switch->init();
+}
+
+void
+Router::wakeup()
+{
+    DPRINTF(RubyNetwork, "Router %d woke up\n", m_id);
+    //update task
+    // if (m_network_ptr->isCentralControlled())
+    //     update_task();
+    // check for incoming flits
+    //std::cout<<"->here Router wake up at cycle "<<m_id<<curCycle()<<std::endl;
+    for (int inport = 0; inport < m_input_unit.size(); inport++) {
+        m_input_unit[inport]->wakeup();
+    }
+
+    // check for incoming credits
+    // Note: the credit update is happening before SA
+    // buffer turnaround time =
+    //     credit traversal (1-cycle) + SA (1-cycle) + Link Traversal (1-cycle)
+    // if we want the credit update to take place after SA, this loop should
+    // be moved after the SA request
+    for (int outport = 0; outport < m_output_unit.size(); outport++) {
+        m_output_unit[outport]->wakeup();
+    }
+
+    // Switch Allocation
+    m_sw_alloc->wakeup();
+
+    // Switch Traversal
+    m_switch->wakeup();
+    
+    // if (m_network_ptr->isCentralControlled()){
+    //     schedule_wakeup(Cycles(1));
+    //     if (m_id < m_network_ptr->getNumRouters()-1)
+    //         m_network_ptr->wakeupRouter(m_id+1);
+    // }
+}
+
+void
+Router::addInPort(PortDirection inport_dirn,
+                  NetworkLink *in_link, CreditLink *credit_link)
+{
+    int port_num = m_input_unit.size();
+    InputUnit *input_unit = new InputUnit(port_num, inport_dirn,
+    (Router*)this);
+
+    input_unit->set_in_link(in_link);
+    input_unit->set_credit_link(credit_link);
+    in_link->setLinkConsumer(this);
+    in_link->setLinkConsumerInport(input_unit);
+    credit_link->setSourceQueue(input_unit->getCreditQueue());
+
+    m_input_unit.push_back(input_unit);
+
+    m_routing_unit->addInDirection(inport_dirn, port_num);
+}
+
+void
+Router::addOutPort(PortDirection outport_dirn,
+                   NetworkLink *out_link,
+                   const NetDest& routing_table_entry, int link_weight,
+                   CreditLink *credit_link)
+{
+    int port_num = m_output_unit.size();
+    OutputUnit *output_unit = new OutputUnit(port_num, outport_dirn,
+    (Router*)this);
+
+    output_unit->set_out_link(out_link);
+    output_unit->set_credit_link(credit_link);
+    credit_link->setLinkConsumer(this);
+    out_link->setSourceQueue(output_unit->getOutQueue());
+
+    m_output_unit.push_back(output_unit);
+
+    m_routing_unit->addRoute(routing_table_entry);
+    m_routing_unit->addWeight(link_weight);
+    m_routing_unit->addOutDirection(outport_dirn, port_num);
+}
+
+PortDirection
+Router::getOutportDirection(int outport)
+{
+    return m_output_unit[outport]->get_direction();
+}
+
+PortDirection
+Router::getInportDirection(int inport)
+{
+    return m_input_unit[inport]->get_direction();
+}
+
+int
+Router::route_compute(RouteInfo *route, int inport,
+PortDirection inport_dirn)
+{
+    return m_routing_unit->outportCompute(route, inport, inport_dirn);
+}
+
+void
+Router::route_central_compute(RouteInfo *route, int inport,
+PortDirection inport_dirn, std::vector<int> *outputlist)
+{
+    m_routing_unit->outportCompute(route, inport, inport_dirn);//outputCentralCompute(route, inport, inport_dirn, outputlist);
+}
+
+
+
+void
+Router::grant_switch(int inport, flit *t_flit)
+{
+    m_switch->update_sw_winner(inport, t_flit);
+}
+
+void
+Router::schedule_wakeup(Cycles time)
+{
+    // wake up after time cycles
+    scheduleEvent(time);
+}
+
+std::string
+Router::getPortDirectionName(PortDirection direction)
+{
+    // PortDirection is actually a string
+    // If not, then this function should add a switch
+    // statement to convert direction to a string
+    // that can be printed out
+    return direction;
+}
+
+void
+Router::insertSSR(PortDirection inport_dirn, SSR* t_ssr)
+{
+    DPRINTF(RubyNetwork,
+    "Router %d Inport %s received SSR from src_hops "
+     "%d for bypass = %d for Outport %s\n",
+            get_id(), inport_dirn, t_ssr->get_src_hops(),
+            t_ssr->get_bypass_req(), t_ssr->get_outport_dirn());
+
+    int inport = m_routing_unit->getInportIdx(inport_dirn);
+    int outport = m_routing_unit->getOutportIdx(
+        t_ssr->get_outport_dirn());
+
+    t_ssr->set_inport(inport);
+
+    // Update SSR if dest bypass enabled
+    if (t_ssr->get_src_hops() > 0 && !t_ssr->get_bypass_req()) {
+        // dest or turning Router
+        RouteInfo* route = t_ssr->get_ref_flit()->get_route();
+        bool is_dest = (route->dest_router == m_id);
+
+        if (get_net_ptr()->isSMARTdestBypass() && is_dest) {
+            outport = m_routing_unit->lookupRoutingTable(
+                route->vnet, route->net_dest);
+            PortDirection outport_dirn = m_output_unit[outport]
+            ->get_direction();
+
+            t_ssr->set_outport_dirn(outport_dirn);
+            t_ssr->set_bypass_req(true);
+        } else {
+            delete t_ssr;
+            return;
+        }
+    }
+    m_output_unit[outport]->insertSSR(t_ssr);
+}
+
+bool
+Router::smart_vc_select(int inport, int outport, flit *t_flit)
+{
+    // VC Selection
+    int vnet = t_flit->get_vnet();
+    bool has_free_vc = m_output_unit[outport]->has_free_vc(vnet);
+    if (!has_free_vc)
+        return false;
+
+    // Update VC in flit
+    int invc = t_flit->get_vc();
+    int outvc;
+    switch(t_flit->get_type()){
+        case HEAD_:case HEAD_TAIL_:
+            outvc = m_output_unit[outport]->select_free_vc(vnet,t_flit);
+            m_input_unit[inport]->set_inject_vc_table(invc,
+            t_flit->get_route()->src_router);
+            //m_output_unit[outport]->set_inject_vc_table(outvc,
+            //t_flit->get_route()->src_router);
+            m_input_unit[inport]->grant_outvc(invc, outvc);
+        break;
+        case BODY_:case TAIL_:
+            outvc = m_input_unit[inport]->get_outvc(invc);
+        break;
+        default:
+
+        break;
+    }
+
+    if (outvc == -1 || outvc == -2 )
+        return false;
+    else if (!m_output_unit[outport]->has_credit(outvc))
+    // if don't have credit then return false
+        return false;
+    else
+        t_flit->set_vc(outvc);
+    m_output_unit[outport]->decrement_credit(outvc);
+
+    // Send credit for VCid flit came with
+    // Verify input VC is free and IDLE
+    assert(!(m_input_unit[inport]->isReady(invc, curCycle())));
+    //assert(m_input_unit[inport]->is_vc_idle(invc));
+
+    // Send credit for VCid flit came with
+    switch(t_flit->get_type()){
+        case TAIL_:case HEAD_TAIL_:
+            //m_output_unit[outport]->set_inject_vc_table(outvc,-1);
+            m_input_unit[inport]->grant_outvc(invc, -1);
+            m_input_unit[inport]->set_vc_idle(invc,curCycle());
+            m_input_unit[inport]->increment_credit(invc, true,
+             curCycle());
+        break;
+        default:
+            m_input_unit[inport]->increment_credit(invc, false,
+             curCycle());
+        break;
+    }
+
+
+    return true;
+}
+
+void
+Router::smart_route_update(int inport, int outport,
+flit* t_flit)
+{
+    // Update route in flit
+    // Call route_compute so that x_hops/y_hops decremented
+    int check_outport = route_compute(t_flit->get_route(),
+        inport, m_input_unit[inport]->get_direction());
+    assert(check_outport == outport);
+    t_flit->set_outport(outport);
+}
+
+bool
+Router::try_smart_bypass(int inport,
+PortDirection outport_dirn, flit *t_flit)
+{
+    int outport = m_routing_unit->getOutportIdx(outport_dirn);
+    //Check outport
+    //if outport is in use then
+    //refuse head or head tail flit
+    if (m_sw_alloc->get_outport_use(outport)&&
+    ((t_flit->get_type()==HEAD_) ||
+    (t_flit->get_type()==HEAD_TAIL_)))
+        return false;
+    // Update VC
+    bool has_vc = smart_vc_select(inport, outport, t_flit);
+    if (!has_vc)
+        return false;
+
+    // Update Route
+    smart_route_update(inport, outport, t_flit);
+
+    DPRINTF(RubyNetwork, "Router %d Inport %s and \
+    Outport %d successful SMART Bypass for Flit %s\n",
+            get_id(), getPortDirectionName(
+                m_input_unit[inport]->get_direction()), outport_dirn,
+                 *t_flit);
+
+    //set outport status
+    // one outport is free when tail or head_tail_
+
+    //set outport pkt route
+    //1.when head_ set route src,dest
+    //2.when tail_ head_tail_ set 0
+    switch(t_flit->get_type()){
+        case HEAD_:
+            m_output_unit[outport]->set_pkt_route(
+                t_flit->get_route()->src_router,
+                t_flit->get_route()->dest_router,
+                t_flit->get_vc()
+            );
+        case BODY_:
+            m_sw_alloc->set_outport_in_use(outport,true);
+            break;
+        case TAIL_:
+        case HEAD_TAIL_:
+            m_sw_alloc->set_outport_in_use(outport,false);
+            m_output_unit[outport]->set_pkt_route(-1,-1,-1);
+            break;
+        default:
+            break;
+    }
+    // Add flit to output link
+    m_output_unit[outport]->smart_bypass(t_flit);
+    t_flit->increment_hops(); // for stats
+
+    return true;
+}
+//Process dest node
+bool
+Router::try_central_bypass(int inport,
+int outport_dirn, flit *t_flit)
+{
+    int outport = outport_dirn;
+    if(outport==0)
+        //return false;
+        outport=1;
+
+
+    DPRINTF(RubyNetwork, "Router %d Inport %s and \
+    Outport %d successful SMART Bypass for Flit %s\n",
+            get_id(), getPortDirectionName(
+                m_input_unit[inport]->get_direction()), outport_dirn,
+                 *t_flit);
+
+    //set outport status
+    // one outport is free when tail or head_tail_
+
+    //set outport pkt route
+    //1.when head_ set route src,dest
+    //2.when tail_ head_tail_ set 0
+    switch(t_flit->get_type()){
+        case HEAD_:
+            m_output_unit[outport]->set_pkt_route(
+                t_flit->get_route()->src_router,
+                t_flit->get_route()->dest_router,
+                t_flit->get_vc()
+            );
+        case BODY_:
+            m_sw_alloc->set_outport_in_use(outport,true);
+            break;
+        case TAIL_:
+        case HEAD_TAIL_:
+            m_sw_alloc->set_outport_in_use(outport,false);
+            m_output_unit[outport]->set_pkt_route(-1,-1,-1);
+            break;
+        default:
+            break;
+    }
+    // Add flit to output central_bypass
+    m_output_unit[outport]->central_bypass(t_flit);
+    t_flit->increment_hops(); // for stats
+    //receive the packet
+
+  
+    return true;
+}
+
+void
+Router::regStats()
+{
+    BasicRouter::regStats();
+
+    m_buffer_reads
+        .name(name() + ".buffer_reads")
+        .flags(Stats::nozero)
+    ;
+
+    m_buffer_writes
+        .name(name() + ".buffer_writes")
+        .flags(Stats::nozero)
+    ;
+
+    m_crossbar_activity
+        .name(name() + ".crossbar_activity")
+        .flags(Stats::nozero)
+    ;
+
+    m_sw_input_arbiter_activity
+        .name(name() + ".sw_input_arbiter_activity")
+        .flags(Stats::nozero)
+    ;
+
+    m_sw_output_arbiter_activity
+        .name(name() + ".sw_output_arbiter_activity")
+        .flags(Stats::nozero)
+    ;
+}
+
+void
+Router::collateStats()
+{
+    for (int j = 0; j < m_virtual_networks; j++) {
+        for (int i = 0; i < m_input_unit.size(); i++) {
+            m_buffer_reads += m_input_unit[i]->
+            get_buf_read_activity(j);
+            m_buffer_writes += m_input_unit[i]->
+            get_buf_write_activity(j);
+        }
+    }
+
+    m_sw_input_arbiter_activity = m_sw_alloc->
+    get_input_arbiter_activity();
+    m_sw_output_arbiter_activity = m_sw_alloc->
+    get_output_arbiter_activity();
+    m_crossbar_activity = m_switch->get_crossbar_activity();
+}
+
+void
+Router::resetStats()
+{
+    for (int j = 0; j < m_virtual_networks; j++) {
+        for (int i = 0; i < m_input_unit.size(); i++) {
+            m_input_unit[i]->resetStats();
+        }
+    }
+
+    m_switch->resetStats();
+    m_sw_alloc->resetStats();
+}
+
+void
+Router::printFaultVector(ostream& out)
+{
+    int temperature_celcius = BASELINE_TEMPERATURE_CELCIUS;
+    int num_fault_types = m_network_ptr->
+    fault_model->number_of_fault_types;
+    float fault_vector[num_fault_types];
+    get_fault_vector(temperature_celcius, fault_vector);
+    out << "Router-" << m_id << " fault vector: " << endl;
+    for (int fault_type_index = 0; fault_type_index < num_fault_types;
+         fault_type_index++) {
+        out << " - probability of (";
+        out <<
+        m_network_ptr->fault_model->fault_type_to_string(fault_type_index);
+        out << ") = ";
+        out << fault_vector[fault_type_index] << endl;
+    }
+}
+
+void
+Router::printAggregateFaultProbability(std::ostream& out)
+{
+    int temperature_celcius = BASELINE_TEMPERATURE_CELCIUS;
+    float aggregate_fault_prob;
+    get_aggregate_fault_probability(temperature_celcius,
+                                    &aggregate_fault_prob);
+    out << "Router-" << m_id << " fault probability: ";
+    out << aggregate_fault_prob << endl;
+}
+
+uint32_t
+Router::functionalWrite(Packet *pkt)
+{
+    uint32_t num_functional_writes = 0;
+    num_functional_writes += m_switch->functionalWrite(pkt);
+
+    for (uint32_t i = 0; i < m_input_unit.size(); i++) {
+        num_functional_writes += m_input_unit[i]->functionalWrite(pkt);
+    }
+
+    for (uint32_t i = 0; i < m_output_unit.size(); i++) {
+        num_functional_writes += m_output_unit[i]->functionalWrite(pkt);
+    }
+
+    return num_functional_writes;
+}
+
+Router *
+GarnetRouterParams::create()
+{
+    return new Router(this);
 }
+
+//Update task
+void Router::update_task(){
+    static Cycles cur = curCycle();
+    //return when the task effective
+    //a.k.a current cycle<end time
+    if (m_curTask!= nullptr && cur < m_curTask->m_end_time)
+        return;
+    //check whether is expired
+    else if (m_curTask != nullptr)
+        delete m_curTask;
+    //check for the json task file
+
+    //initialize
+    std::ifstream ifs ("timepoints.json");
+    Json::Reader reader;
+    Json::Value obj;
+    bool b = reader.parse(ifs,obj);
+    assert(b);
+
+    for (Json::Value::const_iterator it = obj.begin();
+        it!= obj.end();++it){
+        //skip the iterator to the current time
+        while (cur>Cycles((*it)[0]["timePoint"].asInt())){
+            it++;
+        }
+
+        int begin_time =  (*it)[0]["period"][0].asInt();
+        int end_time =  (*it)[0]["period"][1].asInt();
+        int inport,outport;
+
+        //cursed iterator for finding the right settings of the router
+        //be advised that only 1 task would be generated for each
+        //timePorint for every router in the task list
+        Json::Value::const_iterator it_r;
+        for (it_r = (*it)[0]["route"].begin();
+        it_r!= (*it)[0]["route"].end() && (*it_r)[0].asInt() != m_id;
+        ++it_r);
+        if (it_r == (*it)[0]["route"].end())
+            break;
+        else
+            {
+            if ((*it_r)[1].asString()=="N")
+                inport = m_routing_unit->getInportIdx("North");
+            else if ((*it_r)[1].asString()=="S")
+                inport = m_routing_unit->getInportIdx("South");
+            else if ((*it_r)[1].asString()=="W")
+                inport = m_routing_unit->getInportIdx("West");
+            else if ((*it_r)[1].asString()=="E")
+                inport = m_routing_unit->getInportIdx("East");
+            else if ((*it_r)[1].asString()=="P")
+                inport = 0;
+            //this is because inport local have 2 ports
+            //inport[0]==>flit inport
+            //while getinportIdx("Local") would return 1
+            if ((*it_r)[2].asString()=="N")
+                outport = m_routing_unit->getOutportIdx("North");
+            else if ((*it_r)[2].asString()=="S")
+                outport = m_routing_unit->getOutportIdx("South");
+            else if ((*it_r)[2].asString()=="W")
+                outport = m_routing_unit->getOutportIdx("West");
+            else if ((*it_r)[2].asString()=="E")
+                outport = m_routing_unit->getOutportIdx("East");
+            else if ((*it_r)[2].asString()=="P")
+                outport = m_routing_unit->getOutportIdx("Local");}
+
+            m_curTask= new task{
+                Cycles(begin_time),
+                Cycles(end_time),
+                inport,
+                outport
+            };
+            DPRINTF(RubyNetwork,
+    "Router %d Task Period %lld to %lld Inport %s Outport %s \n",
+        get_id(), m_curTask->m_begin_time, m_curTask->m_end_time,
+        getInportDirection(m_curTask->m_inport_id),
+        getOutportDirection(m_curTask->m_outport_id));
+            break;
+        }
+
+
+
+}
+
diff --git a/src/mem/ruby/network/garnet2.0/Router.hh b/src/mem/ruby/network/garnet2.0/Router.hh
index fa118b4..1f8b2e6 100644
--- a/src/mem/ruby/network/garnet2.0/Router.hh
+++ b/src/mem/ruby/network/garnet2.0/Router.hh
@@ -34,15 +34,21 @@
 #ifndef __MEM_RUBY_NETWORK_GARNET2_0_ROUTER_HH__
 #define __MEM_RUBY_NETWORK_GARNET2_0_ROUTER_HH__
 
+#include <jsoncpp/json/json.h>
+
+#include <fstream>
 #include <iostream>
 #include <vector>
+#include <string>
 
 #include "mem/ruby/common/Consumer.hh"
 #include "mem/ruby/common/NetDest.hh"
 #include "mem/ruby/network/BasicRouter.hh"
 #include "mem/ruby/network/garnet2.0/CommonTypes.hh"
 #include "mem/ruby/network/garnet2.0/GarnetNetwork.hh"
+#include "mem/ruby/network/garnet2.0/SSR.hh"
 #include "mem/ruby/network/garnet2.0/flit.hh"
+#include "mem/ruby/network/garnet2.0/task.hh"
 #include "params/GarnetRouter.hh"
 
 class NetworkLink;
@@ -54,6 +60,107 @@ class SwitchAllocator;
 class CrossbarSwitch;
 class FaultModel;
 
+/*class Router : public BasicRouter, public Consumer
+{
+  public:
+    typedef GarnetRouterParams Params;
+    Router(const Params *p);
+
+    ~Router();
+
+    void wakeup();
+    void print(std::ostream& out) const {};
+
+    void init();
+    void addInPort(PortDirection inport_dirn, NetworkLink *link,
+                   CreditLink *credit_link);
+    void addOutPort(PortDirection outport_dirn, NetworkLink *link,
+                    const NetDest& routing_table_entry,
+                    int link_weight, CreditLink *credit_link);
+
+    Cycles get_pipe_stages(){ return m_latency; }
+    int get_num_vcs()       { return m_num_vcs; }
+    int get_num_vnets()     { return m_virtual_networks; }
+    int get_vc_per_vnet()   { return m_vc_per_vnet; }
+    int get_num_inports()   { return m_input_unit.size(); }
+    int get_num_outports()  { return m_output_unit.size(); }
+    int get_id()            { return m_id; }
+
+    void init_net_ptr(GarnetNetwork* net_ptr)
+    {
+        m_network_ptr = net_ptr;
+    }
+
+    GarnetNetwork* get_net_ptr()                    { return m_network_ptr; }
+    std::vector<InputUnit *>& get_inputUnit_ref()   { return m_input_unit; }
+    std::vector<OutputUnit *>& get_outputUnit_ref() { return m_output_unit; }
+    PortDirection getOutportDirection(int outport);
+    PortDirection getInportDirection(int inport);
+
+    int route_compute(RouteInfo *route, int inport, PortDirection direction);
+    void grant_switch(int inport, flit *t_flit);
+    void schedule_wakeup(Cycles time);
+
+    // SMART NoC
+    struct SSR_prio_local
+    {
+        bool operator()(const SSR *lhs, const SSR *rhs) const
+        {
+            if (lhs->m_time == rhs->m_time)
+                // reverse the following for prio_bypass
+                return lhs->m_src_hops > rhs->m_src_hops;
+            else
+                return lhs->m_time > rhs->m_time;
+        }
+    };
+
+    void insertSSR(PortDirection inport_dirn, SSR* t_ssr);
+    bool try_smart_bypass(int inport, PortDirection outport_dirn, flit* t_flit);
+    bool smart_vc_select(int inport, int outport, flit* t_flit);
+    void smart_route_update(int inport, int outport, flit* t_flit);
+
+    std::string getPortDirectionName(PortDirection direction);
+    void printFaultVector(std::ostream& out);
+    void printAggregateFaultProbability(std::ostream& out);
+
+    void regStats();
+    void collateStats();
+    void resetStats();
+
+    // For Fault Model:
+    bool get_fault_vector(int temperature, float fault_vector[]) {
+        return m_network_ptr->fault_model->fault_vector(m_id, temperature,
+                                                        fault_vector);
+    }
+    bool get_aggregate_fault_probability(int temperature,
+                                         float *aggregate_fault_prob) {
+        return m_network_ptr->fault_model->fault_prob(m_id, temperature,
+                                                      aggregate_fault_prob);
+    }
+
+    uint32_t functionalWrite(Packet *);
+
+  private:
+    Cycles m_latency;
+    int m_virtual_networks, m_num_vcs, m_vc_per_vnet;
+    GarnetNetwork *m_network_ptr;
+
+    std::vector<InputUnit *> m_input_unit;
+    std::vector<OutputUnit *> m_output_unit;
+    RoutingUnit *m_routing_unit;
+    SwitchAllocator *m_sw_alloc;
+    CrossbarSwitch *m_switch;
+
+    // Statistical variables required for power computations
+    Stats::Scalar m_buffer_reads;
+    Stats::Scalar m_buffer_writes;
+
+    Stats::Scalar m_sw_input_arbiter_activity;
+    Stats::Scalar m_sw_output_arbiter_activity;
+
+    Stats::Scalar m_crossbar_activity;
+};*/
+
 class Router : public BasicRouter, public Consumer
 {
   public:
@@ -91,10 +198,32 @@ class Router : public BasicRouter, public Consumer
     PortDirection getOutportDirection(int outport);
     PortDirection getInportDirection(int inport);
 
-    int route_compute(RouteInfo route, int inport, PortDirection direction);
+    int route_compute(RouteInfo *route, int inport, PortDirection direction);
+    void route_central_compute(RouteInfo *route, int inport, PortDirection direction, std::vector<int> *outputlist);
     void grant_switch(int inport, flit *t_flit);
     void schedule_wakeup(Cycles time);
 
+    // SMART NoC
+    struct SSR_prio_local
+    {
+        bool operator()(const SSR *lhs, const SSR *rhs) const
+        {
+            if (lhs->m_time == rhs->m_time)
+                // reverse the following for prio_bypass
+                return lhs->m_src_hops > rhs->m_src_hops;
+            else
+                return lhs->m_time > rhs->m_time;
+        }
+    };
+
+    void insertSSR(PortDirection inport_dirn, SSR* t_ssr);
+    bool try_smart_bypass(int inport, PortDirection outport_dirn,
+     flit* t_flit);
+    bool try_central_bypass(int inport, int outport_dirn,
+     flit* t_flit);
+    bool smart_vc_select(int inport, int outport, flit* t_flit);
+    void smart_route_update(int inport, int outport, flit* t_flit);
+
     std::string getPortDirectionName(PortDirection direction);
     void printFaultVector(std::ostream& out);
     void printAggregateFaultProbability(std::ostream& out);
@@ -116,6 +245,12 @@ class Router : public BasicRouter, public Consumer
 
     uint32_t functionalWrite(Packet *);
 
+    //For task management--adding task, removing task from the table
+    //(which is called update)
+    task *getTask(){
+        return m_curTask;
+    }
+    void update_task();
   private:
     Cycles m_latency;
     int m_virtual_networks, m_num_vcs, m_vc_per_vnet;
@@ -127,6 +262,8 @@ class Router : public BasicRouter, public Consumer
     SwitchAllocator *m_sw_alloc;
     CrossbarSwitch *m_switch;
 
+    //For task
+    task *m_curTask;
     // Statistical variables required for power computations
     Stats::Scalar m_buffer_reads;
     Stats::Scalar m_buffer_writes;
@@ -137,4 +274,5 @@ class Router : public BasicRouter, public Consumer
     Stats::Scalar m_crossbar_activity;
 };
 
-#endif // __MEM_RUBY_NETWORK_GARNET2_0_ROUTER_HH__
+#endif // __MEM_RUBY_NETWORK_GARNET2_0_CTRLED_ROUTER_HH__
+
diff --git a/src/mem/ruby/network/garnet2.0/RoutingUnit.cc b/src/mem/ruby/network/garnet2.0/RoutingUnit.cc
index b39bb3c..0eff93f 100644
--- a/src/mem/ruby/network/garnet2.0/RoutingUnit.cc
+++ b/src/mem/ruby/network/garnet2.0/RoutingUnit.cc
@@ -112,6 +112,7 @@ RoutingUnit::lookupRoutingTable(int vnet, NetDest msg_destination)
         candidate = rand() % num_candidates;
 
     output_link = output_link_candidates.at(candidate);
+
     return output_link;
 }
 
@@ -137,38 +138,47 @@ RoutingUnit::addOutDirection(PortDirection outport_dirn, int outport_idx)
 // table is provided here.
 
 int
-RoutingUnit::outportCompute(RouteInfo route, int inport,
+RoutingUnit::outportCompute(RouteInfo *route, int inport,
                             PortDirection inport_dirn)
 {
     int outport = -1;
 
-    if (route.dest_router == m_router->get_id()) {
+    /*
+    if (route->dest_router == m_router->get_id()) {
 
         // Multiple NIs may be connected to this router,
         // all with output port direction = "Local"
         // Get exact outport id from table
-        outport = lookupRoutingTable(route.vnet, route.net_dest);
+        outport = lookupRoutingTable(route->vnet, route->net_dest);
         return outport;
     }
+    */
 
     // Routing Algorithm set in GarnetNetwork.py
     // Can be over-ridden from command line using --routing-algorithm = 1
+    // Routing 
     RoutingAlgorithm routing_algorithm =
         (RoutingAlgorithm) m_router->get_net_ptr()->getRoutingAlgorithm();
+    //std::cout<<"switching algorithm "<<routing_algorithm<<std::endl;
 
     switch (routing_algorithm) {
         case TABLE_:  outport =
-            lookupRoutingTable(route.vnet, route.net_dest); break;
+            lookupRoutingTable(route->vnet, route->net_dest); break;
         case XY_:     outport =
             outportComputeXY(route, inport, inport_dirn); break;
         // any custom algorithm
-        case CUSTOM_: outport =
-            outportComputeCustom(route, inport, inport_dirn); break;
+        case CUSTOM_: 
+
+        outport =
+            outportComputeCustom(route, inport, inport_dirn); 
+
+            break;
         default: outport =
-            lookupRoutingTable(route.vnet, route.net_dest); break;
+            lookupRoutingTable(route->vnet, route->net_dest); break;
     }
 
     assert(outport != -1);
+    //std::cout<<outport<<std::endl;
     return outport;
 }
 
@@ -176,7 +186,7 @@ RoutingUnit::outportCompute(RouteInfo route, int inport,
 // Only for reference purpose in a Mesh
 // By default Garnet uses the routing table
 int
-RoutingUnit::outportComputeXY(RouteInfo route,
+RoutingUnit::outportComputeXY(RouteInfo *route,
                               int inport,
                               PortDirection inport_dirn)
 {
@@ -190,7 +200,7 @@ RoutingUnit::outportComputeXY(RouteInfo route,
     int my_x = my_id % num_cols;
     int my_y = my_id / num_cols;
 
-    int dest_id = route.dest_router;
+    int dest_id = route->dest_router;
     int dest_x = dest_id % num_cols;
     int dest_y = dest_id / num_cols;
 
@@ -200,10 +210,23 @@ RoutingUnit::outportComputeXY(RouteInfo route,
     bool x_dirn = (dest_x >= my_x);
     bool y_dirn = (dest_y >= my_y);
 
-    // already checked that in outportCompute() function
-    assert(!(x_hops == 0 && y_hops == 0));
+    if (inport_dirn == "Local") {
+        // Initialize
+        route->x_hops_remaining = x_hops;
+        route->y_hops_remaining = y_hops;
+    } else if (inport_dirn == "West" || inport_dirn == "East") {
+        route->x_hops_remaining--;
+    } else if (inport_dirn == "North" || inport_dirn == "South") {
+        route->y_hops_remaining--;
+    } else {
+        assert(0);
+    }
 
-    if (x_hops > 0) {
+    if (x_hops == 0 && y_hops == 0) {
+        // lookup routing table for exact outport
+        route->outport_dirn = "Local";
+        return lookupRoutingTable(route->vnet, route->net_dest);
+    } else if (x_hops > 0) {
         if (x_dirn) {
             assert(inport_dirn == "Local" || inport_dirn == "West");
             outport_dirn = "East";
@@ -228,15 +251,44 @@ RoutingUnit::outportComputeXY(RouteInfo route,
         panic("x_hops == y_hops == 0");
     }
 
+    route->outport_dirn = outport_dirn;
     return m_outports_dirn2idx[outport_dirn];
 }
 
 // Template for implementing custom routing algorithm
 // using port directions. (Example adaptive)
 int
-RoutingUnit::outportComputeCustom(RouteInfo route,
+RoutingUnit::outportComputeCustom(RouteInfo *route,
                                  int inport,
                                  PortDirection inport_dirn)
 {
-    panic("%s placeholder executed", __FUNCTION__);
+    
+    int M5_VAR_USED num_rows = m_router->get_net_ptr()->getNumRows();
+    int num_cols = m_router->get_net_ptr()->getNumCols();
+    assert(num_rows > 0 && num_cols > 0);
+
+    int my_id = m_router->get_id();
+
+    
+
+    string result;
+    int i = my_id;
+    if(inport_dirn == "Local")
+        result = networkPath[i].pport;
+    else if(inport_dirn=="East")
+        result = networkPath[i].east;
+    else if(inport_dirn=="West")
+        result = networkPath[i].west;
+    else if(inport_dirn=="North")
+        result = networkPath[i].north;
+    else if(inport_dirn=="South")
+        result = networkPath[i].south;
+
+
+
+    //std::cout<<"in routingunit.cc  this is the output port "<<inport_dirn<<result<<" router id: "<<my_id<<" Cycle "<<m_router->curCycle()<<std::endl;
+    
+
+
+    return m_outports_dirn2idx[result];
 }
diff --git a/src/mem/ruby/network/garnet2.0/RoutingUnit.hh b/src/mem/ruby/network/garnet2.0/RoutingUnit.hh
index 0623e54..b2de540 100644
--- a/src/mem/ruby/network/garnet2.0/RoutingUnit.hh
+++ b/src/mem/ruby/network/garnet2.0/RoutingUnit.hh
@@ -38,6 +38,7 @@
 #include "mem/ruby/common/NetDest.hh"
 #include "mem/ruby/network/garnet2.0/CommonTypes.hh"
 #include "mem/ruby/network/garnet2.0/GarnetNetwork.hh"
+#include "cpu/testers/garnet_synthetic_traffic/GarnetSyntheticTraffic.hh"
 #include "mem/ruby/network/garnet2.0/flit.hh"
 
 class InputUnit;
@@ -47,10 +48,13 @@ class RoutingUnit
 {
   public:
     RoutingUnit(Router *router);
-    int outportCompute(RouteInfo route,
+    int outportCompute(RouteInfo *route,
                       int inport,
                       PortDirection inport_dirn);
 
+    int getInportIdx(PortDirection dirn) { return m_inports_dirn2idx[dirn]; }
+    int getOutportIdx(PortDirection dirn) { return m_outports_dirn2idx[dirn]; }
+
     // Topology-agnostic Routing Table based routing (default)
     void addRoute(const NetDest& routing_table_entry);
     void addWeight(int link_weight);
@@ -63,12 +67,12 @@ class RoutingUnit
     void addOutDirection(PortDirection outport_dirn, int outport);
 
     // Routing for Mesh
-    int outportComputeXY(RouteInfo route,
+    int outportComputeXY(RouteInfo *route,
                          int inport,
                          PortDirection inport_dirn);
 
     // Custom Routing Algorithm using Port Directions
-    int outportComputeCustom(RouteInfo route,
+    int outportComputeCustom(RouteInfo *route,
                              int inport,
                              PortDirection inport_dirn);
 
diff --git a/src/mem/ruby/network/garnet2.0/SConscript b/src/mem/ruby/network/garnet2.0/SConscript
index 866bab9..8f84d08 100644
--- a/src/mem/ruby/network/garnet2.0/SConscript
+++ b/src/mem/ruby/network/garnet2.0/SConscript
@@ -41,6 +41,7 @@ Source('GarnetNetwork.cc')
 Source('InputUnit.cc')
 Source('NetworkInterface.cc')
 Source('NetworkLink.cc')
+Source('CreditLink.cc')
 Source('OutVcState.cc')
 Source('OutputUnit.cc')
 Source('Router.cc')
@@ -51,3 +52,4 @@ Source('VirtualChannel.cc')
 Source('flitBuffer.cc')
 Source('flit.cc')
 Source('Credit.cc')
+Source('SSR.cc')
diff --git a/src/mem/ruby/network/garnet2.0/SSR.cc b/src/mem/ruby/network/garnet2.0/SSR.cc
new file mode 100644
index 0000000..788f488
--- /dev/null
+++ b/src/mem/ruby/network/garnet2.0/SSR.cc
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2016 Georgia Institute of Technology
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Author:  Tushar Krishna
+ */
+
+
+#include "mem/ruby/network/garnet2.0/SSR.hh"
+
+SSR::SSR(int vnet, int src_hops,int src_hops_2,bool bypass_req,
+         PortDirection outport_dirn,PortDirection outport_dirn_2,
+          flit* ref_flit, Cycles curTime)
+{
+    m_vnet = vnet;
+    m_src_hops = src_hops;
+    m_src_hops_2 = src_hops_2;
+    m_bypass_req = bypass_req;
+    m_inport = -1;
+    m_outport_dirn = outport_dirn;
+    m_outport_dirn_2 = outport_dirn_2;
+    m_ref_flit = ref_flit;
+    m_time = curTime;
+}
diff --git a/src/mem/ruby/network/garnet2.0/SSR.hh b/src/mem/ruby/network/garnet2.0/SSR.hh
new file mode 100644
index 0000000..856867c
--- /dev/null
+++ b/src/mem/ruby/network/garnet2.0/SSR.hh
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2016 Georgia Institute of Technology
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met: redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer;
+ * redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution;
+ * neither the name of the copyright holders nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Author:  Tushar Krishna
+ */
+
+
+#ifndef __MEM_RUBY_NETWORK_GARNET_SSR_HH__
+#define __MEM_RUBY_NETWORK_GARNET_SSR_HH__
+
+#include <cassert>
+#include <iostream>
+
+#include "base/types.hh"
+#include "mem/ruby/network/garnet2.0/CommonTypes.hh"
+#include "mem/ruby/network/garnet2.0/GarnetNetwork.hh"
+#include "mem/ruby/network/garnet2.0/flit.hh"
+
+// SSR Signal
+// Carries m_bypass_req,
+// m_src_hops,
+// m_vnet,
+// and *m_ref_flit (pointer to the flit it corresponds to)
+
+class SSR //: public flit
+{
+  public:
+    SSR() {};
+    SSR(int vnet, int src_hops,int src_hops_2,bool bypass_req,
+         PortDirection outport_dirn,PortDirection outport_dirn_2,
+          flit* ref_flit, Cycles curTime);
+
+    int get_vnet()        { return m_vnet; }
+    int get_src_hops()    { return m_src_hops; }
+    int get_src_hops_2()    { return m_src_hops_2; }
+    bool get_bypass_req() { return m_bypass_req; }
+    void set_bypass_req(bool bypass_req)
+    {
+        m_bypass_req = bypass_req;
+    }
+    void set_inport(int inport)
+    {
+        m_inport = inport;
+    }
+    int get_inport() { return m_inport; }
+
+    PortDirection
+        get_outport_dirn(){ return m_outport_dirn; }
+
+    PortDirection
+        get_outport_dirn_2(){ return m_outport_dirn_2; }
+
+    void set_outport_dirn(PortDirection outport_dirn)
+    {
+        m_outport_dirn = outport_dirn;
+    }
+
+    void set_outport_dirn_2(PortDirection outport_dirn)
+    {
+        m_outport_dirn_2 = outport_dirn;
+    }
+    flit* get_ref_flit()  { return m_ref_flit; }
+    Cycles get_time()     { return m_time; }
+    void set_time(Cycles time) { m_time = time; }
+
+//  private:
+    int m_vnet;
+    int m_src_hops;
+    int m_src_hops_2;//2D outport dirn 2
+    bool m_bypass_req;
+    int m_inport;
+    PortDirection m_outport_dirn;
+    PortDirection m_outport_dirn_2;//2D outport dirn 2
+    flit* m_ref_flit;
+    Cycles m_time;
+};
+
+#endif // __MEM_RUBY_NETWORK_GARNET_SSR_HH__
diff --git a/src/mem/ruby/network/garnet2.0/SwitchAllocator.cc b/src/mem/ruby/network/garnet2.0/SwitchAllocator.cc
index 1e9d0e6..8c24922 100644
--- a/src/mem/ruby/network/garnet2.0/SwitchAllocator.cc
+++ b/src/mem/ruby/network/garnet2.0/SwitchAllocator.cc
@@ -30,6 +30,7 @@
  *          Tushar Krishna
  */
 
+#include <algorithm>
 
 #include "mem/ruby/network/garnet2.0/SwitchAllocator.hh"
 
@@ -45,7 +46,6 @@ SwitchAllocator::SwitchAllocator(Router *router)
     m_router = router;
     m_num_vcs = m_router->get_num_vcs();
     m_vc_per_vnet = m_router->get_vc_per_vnet();
-
     m_input_arbiter_activity = 0;
     m_output_arbiter_activity = 0;
 }
@@ -62,7 +62,7 @@ SwitchAllocator::init()
     m_round_robin_invc.resize(m_num_inports);
     m_port_requests.resize(m_num_outports);
     m_vc_winners.resize(m_num_outports);
-
+    m_in_use_outport.resize(m_num_outports);
     for (int i = 0; i < m_num_inports; i++) {
         m_round_robin_invc[i] = 0;
     }
@@ -72,7 +72,7 @@ SwitchAllocator::init()
         m_vc_winners[i].resize(m_num_inports);
 
         m_round_robin_inport[i] = 0;
-
+        m_in_use_outport[i] = false;
         for (int j = 0; j < m_num_inports; j++) {
             m_port_requests[i][j] = false; // [outport][inport]
         }
@@ -95,7 +95,13 @@ SwitchAllocator::wakeup()
     arbitrate_outports(); // Second stage of allocation
 
     clear_request_vector();
+
+    //std::cout<<"Switch Allocator.cc Wakeup router "<<m_router->get_id()<<" "<<m_router->curCycle()<<std::endl;
+    m_router->schedule_wakeup(Cycles(0));
     check_for_wakeup();
+
+    // SA-G
+    arbitrate_ssr();
 }
 
 /*
@@ -187,9 +193,9 @@ SwitchAllocator::arbitrate_outports()
                 int outvc = m_input_unit[inport]->get_outvc(invc);
                 if (outvc == -1) {
                     // VC Allocation - select any free VC from outport
-                    outvc = vc_allocate(outport, inport, invc);
+                    outvc = vc_allocate(outport,
+                    inport, invc,m_input_unit[inport]->peekTopFlit(invc));
                 }
-
                 // remove flit from Input VC
                 flit *t_flit = m_input_unit[inport]->getTopFlit(invc);
 
@@ -222,8 +228,118 @@ SwitchAllocator::arbitrate_outports()
                 m_output_unit[outport]->decrement_credit(outvc);
 
                 // flit ready for Switch Traversal
-                t_flit->advance_stage(ST_, m_router->curCycle());
+                GarnetNetwork *net_ptr = m_router->get_net_ptr();
+                if (net_ptr->isSMART()) {
+
+                    // Wait for one-cycle (for SA-G) before doing ST
+                    // Local SSR insertion guarantees router will wake up next cycle
+                    // and let flit do ST
+                    Cycles sag_delay = Cycles(1);
+
+                    // Prio = Local => Local flit guaranteed to do ST
+                    t_flit->advance_stage(ST_, m_router->curCycle() + sag_delay);
+                    t_flit->set_time(m_router->curCycle() + sag_delay);
+
+                    // Send SSR
+                    // SSR sent this cycle in the code to allow routers to
+                    // perform SA-G next cycle.
+                    // In reality, SSR + SA-G will happen in the same cycle
+
+                    // Local SSR (for self)
+                    SSR *t_ssr = new SSR(t_flit->get_vnet(),
+                                    0, 0,// 0 hops
+                                    false, // no bypass req
+                                    m_output_unit[outport]->get_direction(),
+                                    m_output_unit[outport]->get_direction(),
+                                    t_flit,
+                                    m_router->curCycle() + Cycles(1));
+
+                    m_router->insertSSR(m_input_unit[inport]->get_direction(), t_ssr);
+
+                    // SSRs to neighbors
+                    // number of hops to bypass
+                    RouteInfo *route = t_flit->get_route();
+
+                    // XY Routing
+                    int hops_remaining = (route->x_hops_remaining > 0) ? 
+                                          route->x_hops_remaining :
+                                          route->y_hops_remaining;
+
+                    int hpc_max = net_ptr->getHPCmax();
+                    int req_hops = std::min(hops_remaining, hpc_max);
+                    int req_hops_x = std::min(route->x_hops_remaining,
+                                                hpc_max);
+                    int req_hops_y = std::min(route->y_hops_remaining,
+                                                hpc_max);
+                    int req_hops_all = std::min(req_hops_x+req_hops_y,
+                                                hpc_max);
+                    if (req_hops_x > 0 || req_hops_y > 0) {
+
+                        SSR* t_ssr = new SSR(t_flit->get_vnet(), req_hops_x,
+                            req_hops_y,
+                            // arbitrary. SSR is replicated at every router
+                            // and actual value set
+                            true,
+                            m_output_unit[outport]->get_direction(),
+                            m_output_unit[outport]->get_direction(),
+                            t_flit,
+                            m_router->curCycle() + Cycles(1)); // valid for next cycle
+                        DPRINTF(RubyNetwork,
+                        "Router %d Output port %s Sending SSR for hops = %d\n",
+                        m_router->get_id(),
+                        m_output_unit[outport]->get_direction(),
+                        req_hops);
+                        if (net_ptr->isSMART2D()){
+                            // SSR Traversal is magical right now
+                            //need to find out which axis is the first
+                            if (m_output_unit[outport]->get_direction()\
+                                =="West"||
+                            m_output_unit[outport]->get_direction()\
+                            =="East"){
+                                //x axis first, y axis second
+                                net_ptr->sendSSR_2D(m_router->get_id(),
+                                    t_flit->get_route()->dest_router,
+                                            m_output_unit[outport]->\
+                                            get_direction(),
+                                        req_hops_x,req_hops_all-req_hops_x,\
+                                         t_ssr);
+                            }
+                            else if (m_output_unit[outport]->get_direction()\
+                                =="North"||
+                            m_output_unit[outport]->get_direction()\
+                            =="South"){
+                                //y axis first, y axis second
+                                net_ptr->sendSSR_2D(m_router->get_id(),
+                                    t_flit->get_route()->dest_router,
+                                            m_output_unit[outport]->\
+                                            get_direction(),
+                                            req_hops_y,\
+                                            req_hops_all-req_hops_y,\
+                                            t_ssr);
+                            }
+                        } else {
+                        // SSR Traversal is magical right now
+                        net_ptr->sendSSR(m_router->get_id(),
+                                         m_output_unit[outport]->get_direction(),
+                                         req_hops, t_ssr);
+                        }
+                    }
+                } else {
+                    DPRINTF(RubyNetwork, "Baseline NoC");
+                    //std::cout<<"SwitchAllocator.cc ++++++++++++++ Baseline NoC"<<std::endl;
+
+                    
+                    t_flit->advance_stage(ST_, m_router->curCycle());
+                    t_flit->set_time(m_router->curCycle());
+                }
+
                 m_router->grant_switch(inport, t_flit);
+                //now can set the outport free if the outport is used before
+                if (t_flit->get_type() == TAIL_){
+                    m_in_use_outport[outport]=false;
+                    m_output_unit[outport]->set_pkt_route(-1,-1,-1);
+                }
+
                 m_output_arbiter_activity++;
 
                 if ((t_flit->get_type() == TAIL_) ||
@@ -244,8 +360,10 @@ SwitchAllocator::arbitrate_outports()
                 } else {
                     // Send a credit back
                     // but do not indicate that the VC is idle
+                    //Cycles a = Cycles(1);
+                    
                     m_input_unit[inport]->increment_credit(invc, false,
-                        m_router->curCycle());
+                      m_router->curCycle());
                 }
 
                 // remove this request
@@ -333,16 +451,59 @@ SwitchAllocator::send_allowed(int inport, int invc, int outport, int outvc)
             }
         }
     }
-
+    //smart network:allow 1 packet to be sent before another
+    if (m_router->get_net_ptr()->isSMART()){
+        flit* t_flit = m_input_unit[inport]->peekTopFlit(invc);
+        int t_route_des = t_flit->get_route()->dest_router;
+        int t_route_src = t_flit->get_route()->src_router;
+        int t_route_invc = invc;
+        int m_pkt_route_src=m_output_unit[outport]->get_curr_pkt_src();
+        int m_pkt_route_dest=m_output_unit[outport]->get_curr_pkt_dest();
+        int m_pkt_invc=m_output_unit[outport]->get_curr_pkt_invc();
+
+        if (m_in_use_outport[outport] &&(
+        m_pkt_route_src != t_route_src
+        || m_pkt_route_dest !=t_route_des
+        || m_pkt_invc !=t_route_invc
+        )){
+            return false;
+        }
+        else{
+            switch (m_input_unit[inport]->peekTopFlit(invc)->get_type())
+            {
+            case HEAD_:
+                m_in_use_outport[outport]=true;
+                m_pkt_route=t_flit->get_route();
+                m_pkt_route_dest= t_route_des;
+                m_pkt_route_src= t_route_src;
+                m_pkt_invc = t_route_invc;
+                break;
+            /* case TAIL_:
+                m_in_use_outport[outport]=false; moved to outport arbitrate
+                m_pkt_route=nullptr;
+                m_pkt_route_dest= -1;
+                m_pkt_route_src= -1;
+                m_pkt_invc = -1;
+                break;
+                */
+            default:
+                break;
+            }
+            m_output_unit[outport]->set_pkt_route(
+                m_pkt_route_src,m_pkt_route_dest,m_pkt_invc
+            );
+            return true;
+        }
+    }
     return true;
 }
 
 // Assign a free VC to the winner of the output port.
-int
-SwitchAllocator::vc_allocate(int outport, int inport, int invc)
+int           
+SwitchAllocator::vc_allocate(int outport, int inport, int invc,flit* t_flit)
 {
     // Select a free VC from the output port
-    int outvc = m_output_unit[outport]->select_free_vc(get_vnet(invc));
+    int outvc = m_output_unit[outport]->select_free_vc(get_vnet(invc),t_flit);
 
     // has to get a valid VC since it checked before performing SA
     assert(outvc != -1);
@@ -356,11 +517,12 @@ void
 SwitchAllocator::check_for_wakeup()
 {
     Cycles nextCycle = m_router->curCycle() + Cycles(1);
-
+    
     for (int i = 0; i < m_num_inports; i++) {
         for (int j = 0; j < m_num_vcs; j++) {
-            if (m_input_unit[i]->need_stage(j, SA_, nextCycle)) {
-                m_router->schedule_wakeup(Cycles(1));
+            if (m_input_unit[i]->need_stage(j, ST_, nextCycle)) {
+                //std::cout<<"Switch Allocator.cc Wakeup router "<<m_router->get_id()<<" "<<m_router->curCycle()<<std::endl;
+                m_router->schedule_wakeup(Cycles(0));
                 return;
             }
         }
@@ -388,6 +550,45 @@ SwitchAllocator::clear_request_vector()
     }
 }
 
+// SMART NoC
+// SA-G Stage
+void
+SwitchAllocator::arbitrate_ssr()
+{
+    for (int o = 0; o < m_num_outports; o++) {
+
+        // Read SSR at the top of the SSR request queue (Highest Priority)   
+        if (m_output_unit[o]->isReadySSR()) {
+
+            // Grant SSR at head of prio queue
+            // as it has highest priority
+            SSR* t_ssr = m_output_unit[o]->getTopSSR();
+            //judging the condition
+            //SMART Bypass is available when
+            //1.outport is free
+            //2.outport is not free && outport dest/src is final src/dest
+            if (!m_in_use_outport[o] ||
+            (m_in_use_outport[o] &&
+            (t_ssr->get_ref_flit()->get_route()->dest_router
+            == m_output_unit[o]->get_curr_pkt_dest()) &&
+            (t_ssr->get_ref_flit()->get_route()->src_router
+            == m_output_unit[o]->get_curr_pkt_src())))
+            /*//DPRINTF(RubyNetwork, "SwitchAllocator at Rourer %d
+            granting SSR for inport %d for outport %d", m_router->get_id()
+            , m_router->getPortDirectionName(
+                m_input_unit[t_ssr->get_inport()]->get_direction()),
+                 m_router->getPortDirectionName(
+                     m_output_unit[o]->get_direction()));
+            */
+            // Push grant to prio queue in input unit
+            m_input_unit[t_ssr->get_inport()]->grantSSR(t_ssr);
+
+            // Clear SSR request queue for this cycle
+            m_output_unit[o]->clearSSRreqs();
+        }
+    }
+}
+
 void
 SwitchAllocator::resetStats()
 {
diff --git a/src/mem/ruby/network/garnet2.0/SwitchAllocator.hh b/src/mem/ruby/network/garnet2.0/SwitchAllocator.hh
index 2b16afc..09c27a6 100644
--- a/src/mem/ruby/network/garnet2.0/SwitchAllocator.hh
+++ b/src/mem/ruby/network/garnet2.0/SwitchAllocator.hh
@@ -39,6 +39,7 @@
 
 #include "mem/ruby/common/Consumer.hh"
 #include "mem/ruby/network/garnet2.0/CommonTypes.hh"
+#include "mem/ruby/network/garnet2.0/flit.hh"
 
 class Router;
 class InputUnit;
@@ -57,8 +58,11 @@ class SwitchAllocator : public Consumer
     void arbitrate_inports();
     void arbitrate_outports();
     bool send_allowed(int inport, int invc, int outport, int outvc);
-    int vc_allocate(int outport, int inport, int invc);
-
+    int vc_allocate(int outport, int inport, int invc,flit* t_flit);
+    void arbitrate_ssr();
+    void set_outport_in_use(int outport, bool status){
+      m_in_use_outport[outport]=status;
+    }
     inline double
     get_input_arbiter_activity()
     {
@@ -69,22 +73,28 @@ class SwitchAllocator : public Consumer
     {
         return m_output_arbiter_activity;
     }
-
+    inline bool
+    get_outport_use(int outport)
+    {
+        return m_in_use_outport[outport];
+    }
     void resetStats();
 
   private:
     int m_num_inports, m_num_outports;
     int m_num_vcs, m_vc_per_vnet;
-
+    bool m_pkt_is_being_sent;
     double m_input_arbiter_activity, m_output_arbiter_activity;
 
     Router *m_router;
+    RouteInfo *m_pkt_route;
     std::vector<int> m_round_robin_invc;
     std::vector<int> m_round_robin_inport;
     std::vector<std::vector<bool>> m_port_requests;
     std::vector<std::vector<int>> m_vc_winners; // a list for each outport
     std::vector<InputUnit *> m_input_unit;
     std::vector<OutputUnit *> m_output_unit;
+    std::vector<bool> m_in_use_outport;//outport in use flag for smart
 };
 
 #endif // __MEM_RUBY_NETWORK_GARNET2_0_SWITCHALLOCATOR_HH__
diff --git a/src/mem/ruby/network/garnet2.0/flit.cc b/src/mem/ruby/network/garnet2.0/flit.cc
index 60f1082..9c0a458 100644
--- a/src/mem/ruby/network/garnet2.0/flit.cc
+++ b/src/mem/ruby/network/garnet2.0/flit.cc
@@ -75,6 +75,7 @@ flit::print(std::ostream& out) const
     out << "Dest NI=" << m_route.dest_ni << " ";
     out << "Dest Router=" << m_route.dest_router << " ";
     out << "Enqueue Time=" << m_enqueue_time << " ";
+    out << "Valid Time=" << m_time << " ";
     out << "]";
 }
 
diff --git a/src/mem/ruby/network/garnet2.0/flit.hh b/src/mem/ruby/network/garnet2.0/flit.hh
index da582ef..26cd08c 100644
--- a/src/mem/ruby/network/garnet2.0/flit.hh
+++ b/src/mem/ruby/network/garnet2.0/flit.hh
@@ -56,7 +56,7 @@ class flit
     Cycles get_time() { return m_time; }
     int get_vnet() { return m_vnet; }
     int get_vc() { return m_vc; }
-    RouteInfo get_route() { return m_route; }
+    RouteInfo* get_route() { return &m_route; }
     MsgPtr& get_msg_ptr() { return m_msg_ptr; }
     flit_type get_type() { return m_type; }
     std::pair<flit_stage, Cycles> get_stage() { return m_stage; }
@@ -64,12 +64,14 @@ class flit
 
     void set_outport(int port) { m_outport = port; }
     void set_time(Cycles time) { m_time = time; }
-    void set_vc(int vc) { m_vc = vc; }
+    void set_vc(int vc) {
+        m_vc = vc; }
     void set_route(RouteInfo route) { m_route = route; }
     void set_src_delay(Cycles delay) { src_delay = delay; }
     void set_dequeue_time(Cycles time) { m_dequeue_time = time; }
 
     void increment_hops() { m_route.hops_traversed++; }
+    void increment_smart_hops() { m_route.smart_hops_traversed++; }
     void print(std::ostream& out) const;
 
     bool
diff --git a/src/mem/ruby/network/garnet2.0/task.hh b/src/mem/ruby/network/garnet2.0/task.hh
new file mode 100644
index 0000000..af67f45
--- /dev/null
+++ b/src/mem/ruby/network/garnet2.0/task.hh
@@ -0,0 +1,20 @@
+
+#ifndef __MEM_RUBY_NETWORK_GARNET_TASK_HH__
+#define __MEM_RUBY_NETWORK_GARNET_TASK_HH__
+
+#include <cassert>
+#include <iostream>
+
+#include "base/types.hh"
+#include "mem/ruby/network/garnet2.0/CommonTypes.hh"
+#include "mem/ruby/network/garnet2.0/GarnetNetwork.hh"
+#include "mem/ruby/network/garnet2.0/flit.hh"
+
+struct task{
+      Cycles m_begin_time;
+      Cycles m_end_time;
+      int m_inport_id;
+      int m_outport_id;
+    };
+
+#endif
\ No newline at end of file
diff --git a/src/mem/ruby/network/simple/PerfectSwitch.cc b/src/mem/ruby/network/simple/PerfectSwitch.cc
index 156b96d..220d39d 100644
--- a/src/mem/ruby/network/simple/PerfectSwitch.cc
+++ b/src/mem/ruby/network/simple/PerfectSwitch.cc
@@ -274,7 +274,7 @@ PerfectSwitch::operateMessageBuffer(MessageBuffer *buffer, int incoming,
             DPRINTF(RubyNetwork, "Enqueuing net msg from "
                     "inport[%d][%d] to outport [%d][%d].\n",
                     incoming, vnet, outgoing, vnet);
-
+            
             m_out[outgoing][vnet]->enqueue(msg_ptr, current_time,
                                            m_switch->cyclesToTicks(Cycles(1)));
         }
diff --git a/src/mem/ruby/network/simple/SimpleNetwork.cc b/src/mem/ruby/network/simple/SimpleNetwork.cc
index 56f948f..fe99d68 100644
--- a/src/mem/ruby/network/simple/SimpleNetwork.cc
+++ b/src/mem/ruby/network/simple/SimpleNetwork.cc
@@ -46,7 +46,8 @@ using m5::stl_helpers::deletePointers;
 SimpleNetwork::SimpleNetwork(const Params *p)
     : Network(p), m_buffer_size(p->buffer_size),
       m_endpoint_bandwidth(p->endpoint_bandwidth),
-      m_adaptive_routing(p->adaptive_routing)
+      m_adaptive_routing(p->adaptive_routing),
+      num_rows(p->num_rows)
 {
     // record the routers
     for (vector<BasicRouter*>::const_iterator i = p->routers.begin();
@@ -58,6 +59,7 @@ SimpleNetwork::SimpleNetwork(const Params *p)
 
     m_int_link_buffers = p->int_link_buffers;
     m_num_connected_buffers = 0;
+    graph_file = p->filename;
 }
 
 void
diff --git a/src/mem/ruby/network/simple/SimpleNetwork.hh b/src/mem/ruby/network/simple/SimpleNetwork.hh
index 8b870e7..ff6a813 100644
--- a/src/mem/ruby/network/simple/SimpleNetwork.hh
+++ b/src/mem/ruby/network/simple/SimpleNetwork.hh
@@ -33,6 +33,7 @@
 #include <vector>
 
 #include "mem/ruby/network/Network.hh"
+#include "cpu/testers/garnet_synthetic_traffic/GarnetSyntheticTraffic.hh"
 #include "params/SimpleNetwork.hh"
 
 class NetDest;
@@ -73,6 +74,8 @@ class SimpleNetwork : public Network
     bool functionalRead(Packet *pkt);
     uint32_t functionalWrite(Packet *pkt);
 
+
+
   private:
     void addLink(SwitchID src, SwitchID dest, int link_latency);
     void makeLink(SwitchID src, SwitchID dest,
@@ -89,7 +92,23 @@ class SimpleNetwork : public Network
     const int m_buffer_size;
     const int m_endpoint_bandwidth;
     const bool m_adaptive_routing;
-
+    // Configuration
+    int num_rows;
+    int num_cols;
+    uint32_t ni_flit_size;
+    uint32_t vcs_per_vnet;
+    uint32_t buffers_per_ctrl_vc;
+    uint32_t buffers_per_data_vc;
+    int routing_algorithm;
+    bool enable_smart;
+    bool enable_smart2D;
+    bool single_flit;
+    bool enable_central;
+    int smart_hpcmax;
+    std::string m_filename;
+    bool smart_dest_bypass;
+    bool enable_fault_model;
+    
     //Statistical variables
     Stats::Formula m_msg_counts[MessageSizeType_NUM];
     Stats::Formula m_msg_bytes[MessageSizeType_NUM];
diff --git a/src/mem/ruby/network/simple/SimpleNetwork.py b/src/mem/ruby/network/simple/SimpleNetwork.py
index 1f86f99..077ebcb 100644
--- a/src/mem/ruby/network/simple/SimpleNetwork.py
+++ b/src/mem/ruby/network/simple/SimpleNetwork.py
@@ -41,7 +41,27 @@ class SimpleNetwork(RubyNetwork):
         "default buffer size; 0 indicates infinite buffering");
     endpoint_bandwidth = Param.Int(1000, "bandwidth adjustment factor");
     adaptive_routing = Param.Bool(False, "enable adaptive routing");
-    int_link_buffers = VectorParam.MessageBuffer("Buffers for int_links")
+    int_link_buffers = VectorParam.MessageBuffer("Buffers for int_links");
+    num_rows = Param.Int(0, "number of rows if 2D (mesh/torus/..) topology");
+    ni_flit_size = Param.UInt32(16, "network interface flit size in bytes")
+    vcs_per_vnet = Param.UInt32(4, "virtual channels per virtual network");
+    buffers_per_data_vc = Param.UInt32(4, "buffers per data virtual channel");
+    buffers_per_ctrl_vc = Param.UInt32(1, "buffers per ctrl virtual channel");
+    routing_algorithm = Param.Int(0,
+        "0: Weight-based Table, 1: XY, 2: Custom");
+    enable_smart = Param.Bool(False, "enable SMART (only 1D supported currently)");
+    enable_smart2D = Param.Bool(False, "enable SMART 2D (alpha)");
+
+    enable_single_flit = Param.Bool(False,"Enable Single Flit traffic");
+    enable_central = Param.Bool(False,"Enable Central Controlled");
+
+    smart_hpcmax = Param.Int(4, "HPC_max for SMART");
+    smart_dest_bypass = Param.Bool(False, "enable SMART destination bypass");
+    enable_fault_model = Param.Bool(False, "enable network fault model");
+    fault_model = Param.FaultModel(NULL, "network fault model");
+    garnet_deadlock_threshold = Param.UInt32(50000,
+                              "network-level deadlock threshold")
+    filename = Param.String("h264dl.g", "filename for task graph");
 
     def setup_buffers(self):
         # Note that all SimpleNetwork MessageBuffers are currently ordered
diff --git a/src/mem/ruby/slicc_interface/AbstractController.cc b/src/mem/ruby/slicc_interface/AbstractController.cc
index c953e82..0238ea5 100644
--- a/src/mem/ruby/slicc_interface/AbstractController.cc
+++ b/src/mem/ruby/slicc_interface/AbstractController.cc
@@ -351,7 +351,7 @@ AbstractController::recvTimingResp(PacketPtr pkt)
     } else {
         panic("Incorrect packet type received from memory controller!");
     }
-
+    
     getMemoryQueue()->enqueue(msg, clockEdge(), cyclesToTicks(Cycles(1)));
     delete pkt;
 }
diff --git a/src/mem/ruby/slicc_interface/Message.hh b/src/mem/ruby/slicc_interface/Message.hh
index c62b4e1..74f636d 100644
--- a/src/mem/ruby/slicc_interface/Message.hh
+++ b/src/mem/ruby/slicc_interface/Message.hh
@@ -43,6 +43,8 @@ typedef std::shared_ptr<Message> MsgPtr;
 class Message
 {
   public:
+    int realSrc = -1;
+    int realDst = -1;
     Message(Tick curTime)
         : m_time(curTime),
           m_LastEnqueueTime(curTime),
@@ -98,6 +100,9 @@ class Message
     virtual NetDest& getDestination()
     { panic("getDestination() called on wrong message!"); }
 
+    int getrealSrc(){ return realSrc;}
+    int getrealDst(){ return realDst;}
+
     int getIncomingLink() const { return incoming_link; }
     void setIncomingLink(int link) { incoming_link = link; }
     int getVnet() const { return vnet; }
@@ -112,6 +117,7 @@ class Message
     // Variables for required network traversal
     int incoming_link;
     int vnet;
+
 };
 
 inline bool
diff --git a/src/mem/ruby/slicc_interface/RubyRequest.hh b/src/mem/ruby/slicc_interface/RubyRequest.hh
index 6c84f38..8479754 100644
--- a/src/mem/ruby/slicc_interface/RubyRequest.hh
+++ b/src/mem/ruby/slicc_interface/RubyRequest.hh
@@ -62,6 +62,7 @@ class RubyRequest : public Message
     HSASegment m_segment;
 
 
+
     RubyRequest(Tick curTime, uint64_t _paddr, uint8_t* _data, int _len,
         uint64_t _pc, RubyRequestType _type, RubyAccessMode _access_mode,
         PacketPtr _pkt, PrefetchBit _pb = PrefetchBit_No,
diff --git a/src/mem/ruby/system/DMASequencer.cc b/src/mem/ruby/system/DMASequencer.cc
index 0ad8a20..6d69a71 100644
--- a/src/mem/ruby/system/DMASequencer.cc
+++ b/src/mem/ruby/system/DMASequencer.cc
@@ -111,6 +111,7 @@ DMASequencer::makeRequest(PacketPtr pkt)
     m_outstanding_count++;
 
     assert(m_mandatory_q_ptr != NULL);
+    
     m_mandatory_q_ptr->enqueue(msg, clockEdge(), cyclesToTicks(Cycles(1)));
     active_request.bytes_issued += msg->getLen();
 
@@ -161,6 +162,7 @@ DMASequencer::issueNext(const Addr& address)
     }
 
     assert(m_mandatory_q_ptr != NULL);
+
     m_mandatory_q_ptr->enqueue(msg, clockEdge(), cyclesToTicks(Cycles(1)));
     active_request.bytes_issued += msg->getLen();
     DPRINTF(RubyDma,
diff --git a/src/mem/ruby/system/GPUCoalescer.cc b/src/mem/ruby/system/GPUCoalescer.cc
index 61ee2ae..61d8b52 100644
--- a/src/mem/ruby/system/GPUCoalescer.cc
+++ b/src/mem/ruby/system/GPUCoalescer.cc
@@ -953,6 +953,7 @@ GPUCoalescer::issueRequest(PacketPtr pkt, RubyRequestType secondary_type)
     assert(latency > 0);
 
     assert(m_mandatory_q_ptr);
+    std::cout<<"GPUCoalescer"<<std::endl;
     m_mandatory_q_ptr->enqueue(msg, clockEdge(), latency);
 }
 
diff --git a/src/mem/ruby/system/Sequencer.cc b/src/mem/ruby/system/Sequencer.cc
index ba67311..5be57f7 100644
--- a/src/mem/ruby/system/Sequencer.cc
+++ b/src/mem/ruby/system/Sequencer.cc
@@ -640,7 +640,10 @@ Sequencer::issueRequest(PacketPtr pkt, RubyRequestType secondary_type)
                                       pkt->getSize(), pc, secondary_type,
                                       RubyAccessMode_Supervisor, pkt,
                                       PrefetchBit_No, proc_id, core_id);
+    msg->realSrc = pkt->realSrc;
+    msg->realDst = pkt->realDst;
 
+    //std::cout<<"Sequencer "<<pkt->getAddr()<<std::endl;
     DPRINTFR(ProtocolTrace, "%15s %3s %10s%20s %6s>%-6s %#x %s\n",
             curTick(), m_version, "Seq", "Begin", "", "",
             printAddress(msg->getPhysicalAddress()),
@@ -651,6 +654,7 @@ Sequencer::issueRequest(PacketPtr pkt, RubyRequestType secondary_type)
     assert(latency > 0);
 
     assert(m_mandatory_q_ptr != NULL);
+
     m_mandatory_q_ptr->enqueue(msg, clockEdge(), latency);
 }
 
diff --git a/src/mem/ruby/system/VIPERCoalescer.cc b/src/mem/ruby/system/VIPERCoalescer.cc
index c332a55..4d609dd 100644
--- a/src/mem/ruby/system/VIPERCoalescer.cc
+++ b/src/mem/ruby/system/VIPERCoalescer.cc
@@ -221,6 +221,8 @@ VIPERCoalescer::invL1()
         m_mandatory_q_ptr->enqueue(msg, clockEdge(), m_data_cache_hit_latency);
         m_outstanding_inv++;
     }
+    std::cout<<"VIPECoalescer"<<std::endl;
+
     DPRINTF(GPUCoalescer,
             "There are %d Invalidatons outstanding after Cache Walk\n",
             m_outstanding_inv);
@@ -248,6 +250,8 @@ VIPERCoalescer::wbL1()
         m_mandatory_q_ptr->enqueue(msg, clockEdge(), m_data_cache_hit_latency);
         m_outstanding_wb++;
     }
+        std::cout<<"VIPECoalescer"<<std::endl;
+
     DPRINTF(GPUCoalescer,
             "There are %d Writebacks outstanding after Cache Walk\n",
             m_outstanding_wb);
@@ -272,6 +276,8 @@ VIPERCoalescer::invwbL1()
         m_mandatory_q_ptr->enqueue(msg, clockEdge(), m_data_cache_hit_latency);
         m_outstanding_inv++;
     }
+        std::cout<<"VIPECoalescer"<<std::endl;
+
     // Walk the cache
     for (int i = 0; i< size; i++) {
         Addr addr = m_dataCache_ptr->getAddressAtIdx(i);
diff --git a/src/sim/clocked_object.hh b/src/sim/clocked_object.hh
index b89e1ce..ca0851a 100644
--- a/src/sim/clocked_object.hh
+++ b/src/sim/clocked_object.hh
@@ -62,6 +62,7 @@
  * typically inherit from this class. Objects that need SimObject
  * functionality as well should inherit from ClockedObject.
  */
+
 class Clocked
 {
 
diff --git a/src/systemc/ext/systemc b/src/systemc/ext/systemc
index e248550..59d962d 100644
--- a/src/systemc/ext/systemc
+++ b/src/systemc/ext/systemc
@@ -34,7 +34,8 @@
 // assume that the sc_bind macro will work without explicitly including the
 // boost headers. This is in contradiction to the spec which says boost isn't
 // a required dependency.
-#include <boost/bind.hpp>
+// for passing the build I commented the boost library include
+//#include <boost/bind.hpp>
 
 #include "channel/_channel.hh"
 #include "core/_core.hh"
diff --git a/src/taskGraph.json b/src/taskGraph.json
new file mode 100644
index 0000000..a76c07c
--- /dev/null
+++ b/src/taskGraph.json
@@ -0,0 +1 @@
+{"1": {"total_needSend": 3, "out_links": [["2", 2, [], 0, 0, -1], ["3", 1, [[0, "S"]], 1, 2, 1]], "total_needReceive": 0, "exe_time": 1}, "2": {"total_needSend": 7, "out_links": [["4", 3, [[0, "E"]], 4, 7, 2], ["5", 4, [], 0, 0, -1]], "total_needReceive": 2, "exe_time": 3}, "3": {"total_needSend": 2, "out_links": [["6", 2, [], 0, 0, -1]], "total_needReceive": 1, "exe_time": 2}, "4": {"total_needSend": 2, "out_links": [["7", 2, [], 0, 0, -1]], "total_needReceive": 3, "exe_time": 5}, "5": {"total_needSend": 2, "out_links": [["7", 2, [[0, "E"]], 6, 8, 3]], "total_needReceive": 4, "exe_time": 2}, "6": {"total_needSend": 1, "out_links": [["7", 1, [[2, "N"], [0, "E"]], 6, 7, 4]], "total_needReceive": 2, "exe_time": 4}, "7": {"total_needSend": 0, "out_links": [], "total_needReceive": 5, "exe_time": 1}}
\ No newline at end of file
-- 
2.7.4

